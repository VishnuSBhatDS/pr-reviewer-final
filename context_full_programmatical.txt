# Context for 1 files
# Repo: /Users/dealshare/Downloads/cart-service

=== IMPORT com.dealshare.service.cartservice.dtos.CartParamsTransferModelDTO ===
# /Users/dealshare/Downloads/cart-service/src/main/java/com/dealshare/service/cartservice/dtos/CartParamsTransferModelDTO.java

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CartParamsTransferModelDTO {
    private String appsFlyerId;
    private String deviceId;
    private String platform;
    private Boolean isFirstPurchase;
    private String advertisingId;
    private Boolean isOfflineToOnlineFirstPurchase;
    private Long addressId;
    private Long palId;
    private String instanceId;
}

=== IMPORT com.dealshare.service.cartservice.entities.CartConfig ===
# /Users/dealshare/Downloads/cart-service/src/main/java/com/dealshare/service/cartservice/entities/CartConfig.java

@Entity
@Data
@Table(name = "cart_config")
public class CartConfig {

    @Id
    @Column(name = "id")
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private Long amount;

    @Column(name = "consumer_type")
    private String consumerType;

    @Column(name = "location_type")
    private String locationType;

    @Column(name = "user_segment")
    private String userSegment;

    @Column(name = "locale")
    private String locale;

    @Column(name = "location_id")
    private Integer locationId;

    private String title;

    private String message;

    @Column(name = "is_active")
    private Integer isActive;

    @Column(name = "config_name")
    private String configName;

    @Column(name = "config_meta")
    private String configMeta;

    @Column(name = "start_date")
    private Date startDate;

    @Column(name = "end_date")
    private Date endDate;

    @Column(name = "created_date")
    private Date createDate;

    @Column(name = "modified_date",updatable = false,insertable = false)
    @LastModifiedDate
    private Date modifiedDate;

}

=== IMPORT com.dealshare.service.cartservice.entities.UsersAddressEntity ===
# /Users/dealshare/Downloads/cart-service/src/main/java/com/dealshare/service/cartservice/entities/UsersAddressEntity.java

@Data
@Entity
@Table(name = "user_address")
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class UsersAddressEntity {

    @Id
    @GeneratedValue
    @Column(name = "id")
    private Long id;

    @Column(name = "address")
    private String address;

    @Column(name = "user_id")
    private Long userId;

    @Column(name = "pal_id")
    private Integer palId;

    @Column(name = "city")
    private String city;

    @Column(name = "state")
    private String state;

    @Column(name = "pincode")
    private String pincode;


    @Transient
    private String aName;
    @Transient
    private String stateName;
    @Transient
    private String cityName;

    @Column(name = "varified_address")
    private Boolean verifiedAddress;

    @Column(name = "lat_long_type")
    private String latLongType;

    @Column(name= "pal_area")
    private String palArea;

    @Column(name = "pal_pincode")
    private String palPincode;

    @Column(name= "pal_warehouse")
    private String palWarehouse;

    @Column(name = "`long`")
    private String longitude;

    @Column(name = "lat")
    private String latitude;

    @Column(name = "pal_warehouse_id")
    private Long palWarehouseId;
}

=== IMPORT com.dealshare.service.cartservice.feemodule.models.dto.CartConfigFilter ===
# /Users/dealshare/Downloads/cart-service/src/main/java/com/dealshare/service/cartservice/feemodule/models/dto/CartConfigFilter.java

@Data
@JsonIgnoreProperties(ignoreUnknown = true)
@Builder
public class CartConfigFilter {

    private Long amount;
    private String consumerType;
    private String locationType;
    private Integer locationId;
    private String userSegment;
    private String locale;
    private Integer isActive;
    private String configName;
    private LocalDateTime startDate;
    private LocalDateTime endDate;
}

=== IMPORT com.dealshare.service.cartservice.feemodule.models.dto.WarehouseResponseDto ===
# /Users/dealshare/Downloads/cart-service/src/main/java/com/dealshare/service/cartservice/feemodule/models/dto/WarehouseResponseDto.java

@Getter
@Slf4j
public class WarehouseResponseDto {

    private final Map<Integer,String> warehouses;
    private final CartConfigMetaData metadata;

    public WarehouseResponseDto(Map<Integer,String> warehouses) {
        this.warehouses = warehouses;
        this.metadata = buildMetaData();
    }

    private CartConfigMetaData buildMetaData() {
        ObjectMapper objectMapper = new ObjectMapper();

        Map<String, String> titleMap = new HashMap<>();
        titleMap.put("en", "Order more & Get Free shipping");
        titleMap.put("hi", "ऑर्डर करें और मुफ्त डिलीवरी पाएं");
        titleMap.put("ben", "আরও অর্ডার করুন এবং বিনামূল্যে শিপিং পান");

        String titleJson = "";
        try {
            titleJson = objectMapper.writeValueAsString(titleMap);
        } catch (Exception e) {
            log.error(e.getMessage());
        }

        Map<String, String> messageMap = new HashMap<>();
        messageMap.put("en", "Add items worth ₹${ORDER_VALUE} more to get free delivery");
        messageMap.put("hi", "फ्री डिलीवरी प्राप्त करने के लिए ₹${ORDER_VALUE} के और आइटम जोड़ें");
        messageMap.put("ben", "ফ্ফ্রি ডেলিভারির জন্য আরও ₹${ORDER_VALUE} মূল্যের আইটেম যোগ করুন");

        JsonNode messageNode = objectMapper.valueToTree(messageMap);

        Map<String, String> configMetaMap = new HashMap<>();
        configMetaMap.put("delivery_fee", "19");
        configMetaMap.put("minimum_order_value", "399");

        JsonNode configMetaNode = objectMapper.valueToTree(configMetaMap);

        CartConfigModel deliveryFeeTemplate = new CartConfigModel();
        deliveryFeeTemplate.setId(100319L);
        deliveryFeeTemplate.setAmount(399L);
        deliveryFeeTemplate.setConsumerType("B2C");
        deliveryFeeTemplate.setLocationType("WAREHOUSE");
        deliveryFeeTemplate.setLocationId(519);
        deliveryFeeTemplate.setUserSegment("normal");
        deliveryFeeTemplate.setLocale("en");
        deliveryFeeTemplate.setTitle(titleJson);
        deliveryFeeTemplate.setMessage(messageNode);
        deliveryFeeTemplate.setIsActive(true);
        deliveryFeeTemplate.setConfigName("DELIVERY_FEES");
        deliveryFeeTemplate.setConfigMeta(configMetaNode);
        deliveryFeeTemplate.setStartDate(new Date(2025-1900, 6, 7, 12, 46, 47));
        deliveryFeeTemplate.setEndDate(new Date(2031-1900, 3, 30, 7, 40, 23));
        deliveryFeeTemplate.setCreateDate(null);
        deliveryFeeTemplate.setModifiedDate(null);

        CartConfigFilter cartConfigFilterTemplate = CartConfigFilter.builder()
                .amount(399L)
                .consumerType("B2C")
                .locationType("WAREHOUSE")
                .locationId(0)
                .userSegment("ALL")
                .locale("en")
                .isActive(1)
                .configName("DELIVERY_FEES")
                .startDate(null)
                .endDate(null)
                .build();

        Map<String, CartConfigModel> cartConfigModelMap = new HashMap<>();
        cartConfigModelMap.put("DELIVERY_FEES", deliveryFeeTemplate);

        return CartConfigMetaData.builder()
                .cartConfigTemplate(cartConfigModelMap)
                .cartConfigFilterTemplate(cartConfigFilterTemplate)
                .build();
    }

    @Builder
    @Getter
    private static class CartConfigMetaData {
        private Map<String, CartConfigModel> cartConfigTemplate;
        private CartConfigFilter cartConfigFilterTemplate;
    }
}

=== IMPORT com.dealshare.service.cartservice.models.ActiveClusterUserMovModel ===
# /Users/dealshare/Downloads/cart-service/src/main/java/com/dealshare/service/cartservice/models/ActiveClusterUserMovModel.java

@Data
public class ActiveClusterUserMovModel {

    private List<Integer> clusterIds;
    private List<String> userRanks;
    private Long mov;
    private String stateName;
    private List<String> clusterNames;
}

=== IMPORT com.dealshare.service.cartservice.models.CartConfigModel ===
# /Users/dealshare/Downloads/cart-service/src/main/java/com/dealshare/service/cartservice/models/CartConfigModel.java

@Data
public class CartConfigModel {
    private Long id;
    private Long amount;
    private String consumerType;
    private String locationType;
    private Integer locationId;
    private String userSegment;
    private String locale;
    private String title;
    private JsonNode message;
    private Boolean isActive;
    private String configName;
    private JsonNode configMeta;
    private Date startDate;
    private Date endDate;
    private Date createDate;
    private Date modifiedDate;
}

=== IMPORT com.dealshare.service.cartservice.models.ClusterMovRequestModel ===
# /Users/dealshare/Downloads/cart-service/src/main/java/com/dealshare/service/cartservice/models/ClusterMovRequestModel.java

@Data
public class ClusterMovRequestModel {
    private List<Integer> clusterIds;
    private Long movAmount;
    private List<String> userRanks;
    private String cartConfigMeta;
}

=== IMPORT com.dealshare.service.cartservice.models.LocationV3Model ===
# /Users/dealshare/Downloads/cart-service/src/main/java/com/dealshare/service/cartservice/models/LocationV3Model.java

@Data
public class LocationV3Model {

    private String pincode;

    private List<Integer> clusterIds;

    private Integer b2bWarehouse;

    private Integer spokeWarehouse;

    private List<Integer> spoke;

    private Integer hub;

    private List<Integer> hubs;

    private Boolean allowParentWarehouseOrder;

    private Boolean isServicable;

    private Long cityId;

    private Long stateId;

    private String cityName;

    private String stateName;

    private List<WarehouseDetails> warehouseDetails;

    private Boolean isMarketPlacePincode = false;

    Map<WarehouseType,List<WarehouseDetails>> warehouseTypeMap;

    boolean isServeByO2O;

    private long palId;

    private Boolean palServiceabilityEnabled = false;

    private Boolean isPalServedByStore = false;
}

=== IMPORT com.dealshare.service.cartservice.models.OrdConfigModel ===
# /Users/dealshare/Downloads/cart-service/src/main/java/com/dealshare/service/cartservice/models/OrdConfigModel.java

@Data
public class OrdConfigModel {
    private Long amount;
    private String message;
    private Long noOfOrdAllowedInCart;
    private String greyOutButtonMessage;
}

=== IMPORT com.dealshare.service.cartservice.models.UserCart ===
# /Users/dealshare/Downloads/cart-service/src/main/java/com/dealshare/service/cartservice/models/UserCart.java

@Data
public class UserCart {
    private Long userId;
    @JsonIgnore
    private String userRank;
    private String phone;
    private Long cartId;
    private List<CartItem> cartItems;
    private Map<String,String> cartUpdateResponse;
    private String cartStatus;
    private BigDecimal totalPromotionDiscount;
    private BigDecimal totalCartPromotionDiscount;
    private CartApplicablePromotion cartPromotion;
    private BigDecimal totalPrice;
    private BigDecimal totalExcludeDealsPrice;
    @JsonIgnore
    private BigDecimal totalMpPrice = BigDecimal.ZERO;
    @JsonIgnore
    private BigDecimal totalRNM = BigDecimal.ZERO;
    private BigDecimal rtgsHandlingFee;
    private BigDecimal rtgsDiscountFee;
    private BigDecimal totalDiscount;
    private BigDecimal totalMrp;
    private BigDecimal freeShipping;
    private Boolean expressApplied = false;
    private BigDecimal expressShipping = BigDecimal.ZERO;
    private Boolean expressAvailable = false;
    private Boolean isCheckOutAllow;
    private Map<String, String> homePageMessageToast;
    private Map<String, String> expressMessageToast;
    private Boolean isOrdAddedToCart = false;
    private Map<String, String> checkoutMessage;
    private Map<String, String> checkoutTitle;
    private Boolean isAddToBagAllowed;
    private Map<String, String> isAddToBagAllowedMessage;
    private String greyOutButtonMessage;
    private BigDecimal minOrderValue;
    private String messageTextColor;
    private String messageBgColor;
    private Map<String, Object> feesMap;
    private String deliveryIcon;
    private String deliveryFeeMessage;
    private String deliveryFeeCancellationMessage ;
    private Boolean expressDeliveryOptButton = false;
    private Boolean oldCheckOutFlow = Boolean.FALSE;
    @JsonIgnore
    private Integer ordCartMov;
    @JsonIgnore
    private Boolean newUser;
    @JsonIgnore
    private Integer totalOrdsInCart;
    private Long cartConfigId=0l;
    private CartMessage cartMessage;
    private Map<String,Long> config;
    private Long ordGlobalMov;
    private Boolean applyWalletCashback;
    private Boolean applyRefund;
    private Integer totalAvailableWalletCashback;
    private Integer totalAppliedWalletCashback;
    private Integer totalAvailableRefund;
    private Integer totalAppliedRefund;
    private Integer totalUserSpecificDiscount;
    private Integer totalUsableCashback;
    private Integer totalUsableRefund;
    private String cartDiscountLabel;
    @JsonIgnore
    private Map<String, DealInventoryStatusModel> inventoryMap;
    private DiscountPreference promotionPreference;
    @JsonIgnore
    private List<DiscountSummaryItem> discountSummaryItems = new ArrayList<>();
}

=== REVERSE DEPENDENCY ===
# /Users/dealshare/Downloads/cart-service/src/main/java/com/dealshare/service/cartservice/services/impl/OfferCommServiceImpl.java

package com.dealshare.service.cartservice.services.impl;

import com.dealshare.common.dtos.common.LocationInfo;
import com.dealshare.common.dtos.common.ResponseDealData;
import com.dealshare.common.dtos.common.UserInfo;
import com.dealshare.common.dtos.common.cta.CtaComponent;
import com.dealshare.common.dtos.common.enums.WarehouseType;
import com.dealshare.common.dtos.orchestration.cp.cartservice.request.OfferCommFcRequest;
import com.dealshare.common.dtos.orchestration.cp.cartservice.response.OfferCommData;
import com.dealshare.common.dtos.orchestration.cp.cartservice.response.OfferCommFcResponse;
import com.dealshare.productaggregatorservice.models.productaggregator.DealDataRequestModel;
import com.dealshare.productaggregatorservice.models.productaggregator.DealDataResponseModel;
import com.dealshare.service.cartservice.entities.CartConfig;
import com.dealshare.service.cartservice.enums.Discount.BusinessModel;
import com.dealshare.service.cartservice.enums.Discount.Source;
import com.dealshare.service.cartservice.enums.DownstreamService;
import com.dealshare.service.cartservice.exceptions.NotAcceptableValidationException;
import com.dealshare.service.cartservice.feignclients.DiscountServiceClientWrapper;
import com.dealshare.service.cartservice.feignclients.LocationServiceClientWrapper;
import com.dealshare.service.cartservice.mappers.DtoMapper;
import com.dealshare.service.cartservice.models.CartAddOns.DealListModel;
import com.dealshare.service.cartservice.models.CartDiscount.CartPageDeal;
import com.dealshare.service.cartservice.models.CartDiscount.CartPromotionsResponse;
import com.dealshare.service.cartservice.models.Discount.*;
import com.dealshare.service.cartservice.models.Discount.GetAvailableOffersRequest;
import com.dealshare.service.cartservice.models.Discount.GetAvailableOffersResponse;
import com.dealshare.service.cartservice.models.HomePageStrip;
import com.dealshare.service.cartservice.models.HomePageStripRequest;
import com.dealshare.service.cartservice.models.LocationV3Model;
import com.dealshare.service.cartservice.models.MessageStrip;
import com.dealshare.service.cartservice.models.OfferResponseModel;
import com.dealshare.service.cartservice.models.StaticPropertiesRequestModel;
import com.dealshare.service.cartservice.models.UserCacheModel;
import com.dealshare.service.cartservice.services.CartConfigService;
import com.dealshare.service.cartservice.services.CartItemService;
import com.dealshare.service.cartservice.services.CartServiceV4;
import com.dealshare.service.cartservice.services.DiscountService;
import com.dealshare.service.cartservice.services.OfferCommService;
import com.dealshare.service.cartservice.services.ProductAggregatorService;
import com.dealshare.service.cartservice.services.StaticPropertyService;
import com.dealshare.service.cartservice.services.UserService;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;
import lombok.extern.slf4j.Slf4j;
import org.mapstruct.factory.Mappers;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;

import static com.dealshare.service.cartservice.constants.AppConstant.BILL_BUSTER;
import static com.dealshare.service.cartservice.constants.AppConstant.DEAL_PRODUCT_PROMOTION;
import static com.dealshare.service.cartservice.constants.AppConstant.LD;
import static com.dealshare.service.cartservice.constants.AppConstant.ORD;
import static com.dealshare.service.cartservice.constants.OfferCommConstant.*;
import static com.dealshare.service.cartservice.utils.CommonUtils.getCtaComponent;
import static com.dealshare.service.cartservice.utils.CommonUtils.isPromotionAvailableInWarehouse;

@Service
@Slf4j
public class OfferCommServiceImpl implements OfferCommService {

    @Autowired
    private CartConfigService cartConfigService;

    @Autowired
    private DiscountService discountService;

    @Autowired
    private StaticPropertyService staticPropertyService;

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    CartItemService cartItemService;

    @Autowired
    private CartServiceV4Impl cartServiceV4;

    @Autowired
    ProductAggregatorService productAggregatorService;

    private final DtoMapper dtoMapper = Mappers.getMapper(DtoMapper.class);

    @Value("${deal.box.deepLink}")
    private String dealBoxDeepLink;

    @Value("${coupon.box.deepLink}")
    private String couponBoxDeepLink;

    @Override
    public OfferCommFcResponse getAllOfferCommForUser(
        OfferCommFcRequest offerCommRequest, String lang) {
        Map<String, List<OfferCommData>> offerComMap = new HashMap<>();

        OfferCommFcResponse offerCommFcResponse =
            getAllOfferCommForUser(offerCommRequest.getUserInfo(),
                    offerCommRequest.getLocationInfo(), lang);
        if(Objects.nonNull(offerCommRequest.getFcId())) {
            offerComMap.put(offerCommRequest.getFcId(), offerCommFcResponse.getOfferCommList());
        }
        offerCommFcResponse.setFcOfferComMap(offerComMap);
        return offerCommFcResponse;
    }

    @Override
    public OfferCommFcResponse getAllOfferCommForUser(UserInfo userInfo, LocationInfo locationInfo,
                                                      String lang) {
        CartConfig cartConfig = null;
        GetAvailableOffersResponse getAvailableOffersResponse = null;
        Map<String, Map<String, String>> staticPropertyMap = new HashMap<>();

        CompletableFuture<CartConfig> cartConfigCompletableFuture = CompletableFuture
            .supplyAsync(() -> cartConfigService
                .getCartConfigForCluster(locationInfo.getClusters()));
        CompletableFuture<GetAvailableOffersResponse> availableOffersResponseCompletableFuture =
            CompletableFuture
                .supplyAsync(() -> {
                    GetAvailableOffersRequest getAvailableOffersRequest =
                        GetAvailableOffersRequest.builder()
                            .userId(userInfo.getUserId())
                            .source(Source.APP)
                            .businessModel(BusinessModel.B2C)
                            .userInfo(userInfo).locationInfo(locationInfo).build();
                    return discountService.getAvailableOffersForUser(getAvailableOffersRequest,
                        lang);
                });
        CompletableFuture<Map<String, Map<String, String>>> staticPropertyCompletableFuture =
            CompletableFuture
                .supplyAsync(() -> getStaticPropertiesForOfferComm(lang));
        CompletableFuture<Void> completableFuture = CompletableFuture.allOf(
            cartConfigCompletableFuture, availableOffersResponseCompletableFuture,
            staticPropertyCompletableFuture);

        try {
            completableFuture.get();
            cartConfig = cartConfigCompletableFuture.get();
            getAvailableOffersResponse = availableOffersResponseCompletableFuture.get();
            staticPropertyMap = staticPropertyCompletableFuture.get();
        } catch (Exception e) {
            log.error("Exception in fetching offer communication {}", e.getMessage());
        }
        return getResponse(cartConfig, getAvailableOffersResponse, staticPropertyMap, lang,
                getSpokes(locationInfo), getClusters(locationInfo));
    }

    @Override
    public OfferCommFcResponse getAllCartOfferCommunicationV2(
        List<OfferCommFcRequest> offerCommRequests, String lang) {

        OfferCommFcResponse response = new OfferCommFcResponse();
        response.setFcOfferComMap(new HashMap<>());

        if (CollectionUtils.isEmpty(offerCommRequests)) {
            return response;
        }

        OfferCommFcRequest offerCommFcRequest = offerCommRequests.get(0);

        List<Integer> spokes = getSpokes(offerCommFcRequest.getLocationInfo());
        List<Integer> clusters = getClusters(offerCommFcRequest.getLocationInfo());

        CartConfig cartConfig = null;
        GetAvailableOffersResponse getAvailableOffersResponse = null;
        Map<String, Map<String, String>> staticPropertyMap = new HashMap<>();

        CompletableFuture<CartConfig> cartConfigCompletableFuture = CompletableFuture
            .supplyAsync(() -> cartConfigService
                .getCartConfigForCluster(offerCommFcRequest.getLocationInfo().getClusters()));
        CompletableFuture<GetAvailableOffersResponse> availableOffersResponseCompletableFuture =
            CompletableFuture
                .supplyAsync(() -> {
                    GetAvailableOffersRequest getAvailableOffersRequest =
                        GetAvailableOffersRequest.builder()
                            .userId(offerCommFcRequest.getUserInfo().getUserId())
                            .source(Source.APP)
                            .businessModel(BusinessModel.B2C).build();
                    return discountService.getAvailableOffersForUser(getAvailableOffersRequest,
                        lang);
                });
        CompletableFuture<Map<String, Map<String, String>>> staticPropertyCompletableFuture =
            CompletableFuture
                .supplyAsync(() -> getStaticPropertiesForOfferComm(lang));
        CompletableFuture<Void> completableFuture = CompletableFuture.allOf(
            cartConfigCompletableFuture, availableOffersResponseCompletableFuture,
            staticPropertyCompletableFuture);

        try {
            completableFuture.get();
            cartConfig = cartConfigCompletableFuture.get();
            getAvailableOffersResponse = availableOffersResponseCompletableFuture.get();
            staticPropertyMap = staticPropertyCompletableFuture.get();
        } catch (Exception e) {
            log.error("Exception in fetching offer communication List {}", e.getMessage());
        }

        List<AvailablePromotion> allAvailablePromotionList =
            Objects.nonNull(getAvailableOffersResponse)
                ? getAvailableOffersResponse.getAvailablePromotions() : new ArrayList<>();

        for (OfferCommFcRequest offerCommRequest : offerCommRequests) {

            String planType = Optional.ofNullable(offerCommRequest)
                .map(req -> req.getOfferCommMetadata())
                .map(metadata -> metadata.getPromotionPlanType())
                .map(promotionPlanType -> promotionPlanType.getValue())
                .orElse(null);

            List<AvailablePromotion> availablePromotions;
            if (!StringUtils.isEmpty(planType) && !CollectionUtils.isEmpty(
                allAvailablePromotionList)) {
                availablePromotions =
                    allAvailablePromotionList.stream().filter(
                        availablePromotion -> planType.equalsIgnoreCase(
                            availablePromotion.getPlanType())).collect(Collectors.toList());
                getAvailableOffersResponse.setAvailablePromotions(availablePromotions);
            }

            List<OfferCommData> offerCommDataList =
                getResponse(cartConfig, getAvailableOffersResponse, staticPropertyMap, lang,
                    spokes, clusters).getOfferCommList();
            if(Objects.nonNull(offerCommRequest.getFcId())) {
                response.getFcOfferComMap().put(offerCommRequest.getFcId(), offerCommDataList);
            }
        }
        return response;
    }

    @Override
    public List<CartPageDeal> getAllProductPromotions(HomePageStripRequest pageStripRequest,
                                                      String lang, Long userIdFinal, Long pincode,
                                                      Long palId) {
        try {
            List<CartPageDeal> cartPageDeals = new ArrayList<>();
            Map<String, Map<String, String>> staticPropertyMap= getStaticPropertiesForOfferComm(lang);

            Map<String, String> propertyMap = staticPropertyMap.getOrDefault(
                    staticPropertyService.getKey(OFFER_COMM_WIDGET, COUPON_COMM, lang),
                    new HashMap<>());

            String dealBoxBgImage = propertyMap.getOrDefault(DEAL_BOX_IMG, COUPON_COMM_DEFAULT_BGIMAGE);
            HomePageStrip homePageStrip =
                cartServiceV4.getHomePageStrip(pageStripRequest, lang, userIdFinal, pincode,
                    palId);
            if (Objects.nonNull(homePageStrip) && Objects.nonNull(
                homePageStrip.getDiscountCommunication())) {
                CartPromotionsResponse cartPromotionsResponse =
                    homePageStrip.getDiscountCommunication()
                        .getCartPromotionsResponse();

                if (Objects.nonNull(cartPromotionsResponse)) {

                    cartPageDeals.addAll(cartPromotionsResponse.getCartPageLds());
                    cartPageDeals.addAll(cartPromotionsResponse.getCartPageOrds());
                }
                if (!CollectionUtils.isEmpty(cartPageDeals)) {
                    cartPageDeals.forEach(
                        cartPageDeal -> cartPageDeal.setDealBoxBgImage(dealBoxBgImage));

                    Set<Long> dealIds = cartPageDeals.stream()
                        .filter(cartPageDeal -> !CollectionUtils.isEmpty(cartPageDeal.getDealIds()))
                        .flatMap(cartPageDeal -> cartPageDeal.getDealIds().stream())
                        .collect(Collectors.toSet());

                    if (!CollectionUtils.isEmpty(dealIds)) {

                        List<String> serviceViewList =
                            Arrays.asList(
                                DownstreamService.DEAL_INDEX_SERVICE_VIEW.getServiceViewName(),
                                DownstreamService.PRICING_SERVICE_VIEW.getServiceViewName());

                        UserCacheModel userCacheModel = new UserCacheModel();
                        userCacheModel.setId(userIdFinal);
                        userCacheModel.setPincode(pincode);
                        userCacheModel.setSource(pageStripRequest.getSource());
                        userCacheModel.setLang(lang);

                        DealDataRequestModel dealDataRequestModel =
                            cartServiceV4.prepareRequestModelForProductAggregator(userCacheModel,
                                null,
                                new ArrayList<>(dealIds),
                                serviceViewList);

                        if (!CollectionUtils.isEmpty(dealIds)) {
                            DealDataResponseModel dealDataResponseModel =
                                productAggregatorService.getDealDataResponseModel(
                                    dealDataRequestModel);

                            Map<Long, DealListModel> dealListModelMap =
                                dealDataResponseModel.getResponseDealDataList()
                                    .stream().collect(
                                        Collectors.toMap(ResponseDealData::getId,
                                            dtoMapper::toDealListModel,
                                            (d1, d2) -> d1));

                            cartPageDeals.forEach(cartPageDeal -> {
                                cartPageDeal.setDealDetails(cartPageDeal.getDealIds().stream()
                                    .map(dealListModelMap::get).collect(Collectors.toList()));
                            });
                        }
                    }
                }
            }
            if(!CollectionUtils.isEmpty(cartPageDeals)) {
                cartPageDeals.forEach(cartPageDeal -> {
                    MessageStrip offerCom = cartPageDeal.getOfferCommSection();
                    if (Objects.nonNull(offerCom) && !StringUtils.isEmpty(cartPageDeal.getTnc())) {
                        offerCom.setTncList(Arrays.asList(cartPageDeal.getTnc().split("\n")));
                        offerCom.getTncList().removeIf(s -> StringUtils.isEmpty(s.trim()));
                    }
                });
            }
            return cartPageDeals;
        } catch(NotAcceptableValidationException e) {
            log.error(
                    "NotAcceptableValidationException occurred while fetching AllProductPromotions, userId: {}, request: {}",
                    userIdFinal, pageStripRequest);
            throw e;
        } catch(Exception e) {
            log.error(
                "Exception occurred while fetching AllProductPromotions, userId: {}, request: {}",
                userIdFinal, pageStripRequest);
            log.error("Exception occurred while fetching AllProductPromotions: msg: {}",
                e.getMessage());
            throw new RuntimeException("Error occurred while fetching AllProductPromotions");
        }
    }


    private OfferCommFcResponse getResponse (
            CartConfig cartConfig, GetAvailableOffersResponse getAvailableOffersResponse,
            Map < String, Map < String, String >> staticPropertyMap, String
        lang, List < Integer > spokes, List <Integer> clusters){

            OfferCommFcResponse offerCommFcResponse = new OfferCommFcResponse();
            List<OfferCommData> offerCommDataList = new ArrayList<>();
            if (Objects.isNull(spokes)) {
                spokes = new ArrayList<>();
            }
            if (Objects.nonNull(cartConfig)) {
                Map<String, String> deliveryCommPropertyMap = staticPropertyMap
                    .getOrDefault(
                        staticPropertyService.getKey(OFFER_COMM_WIDGET, DELIVERY_COMM, lang),
                        new HashMap<>());
                if(Objects.isNull(deliveryCommPropertyMap)) {
                    deliveryCommPropertyMap = new HashMap<>();
                }
                populateDeliveryCommResponse(cartConfig.getAmount(), deliveryCommPropertyMap,
                    offerCommDataList);
            }
            if (Objects.nonNull(getAvailableOffersResponse) && !CollectionUtils.isEmpty(
                getAvailableOffersResponse.getAvailablePromotions())) {
                Map<String, String> couponCommPropertyMap = staticPropertyMap
                    .getOrDefault(
                        staticPropertyService.getKey(OFFER_COMM_WIDGET, COUPON_COMM, lang),
                        new HashMap<>());
                populateCouponCommResponse(getAvailableOffersResponse.getAvailablePromotions(),
                    couponCommPropertyMap, offerCommDataList, spokes, clusters);
            }
            if (offerCommDataList.isEmpty()) {
                offerCommDataList = null;
            }
            offerCommFcResponse.setOfferCommList(offerCommDataList);
            return offerCommFcResponse;
        }

        private void populateDeliveryCommResponse (Long amount, Map < String, String > propertyMap,
            List < OfferCommData > offerCommDataList){
            OfferCommData offerCommData = new OfferCommData();
            if (propertyMap.containsKey("showWidget") && Objects.nonNull(
                propertyMap.get("showWidget"))
                && propertyMap.get("showWidget").equalsIgnoreCase("true")) {
                offerCommData.setTitle(
                    String.format(propertyMap.getOrDefault("title", DELIVERY_COMM_DEFAULT_TITLE),
                        amount));
                offerCommData.setSubtitle(
                    propertyMap.getOrDefault("subTitle", DELIVERY_COMM_DEFAULT_SUBTITLE));
                offerCommData.setIcon(propertyMap.getOrDefault("icon", DELIVERY_COMM_DEFAULT_ICON));
                offerCommData.setBgImage(
                    propertyMap.getOrDefault("bgImage", DELIVERY_COMM_DEFAULT_BGIMAGE));
                offerCommDataList.add(offerCommData);
            }
        }

        private void populateCouponCommResponse (List < AvailablePromotion > availablePromotions,
            Map < String, String > propertyMap,
            List < OfferCommData > offerCommDataList,
            List <Integer> spokes, List <Integer> clusters){

            CtaComponent dealCta = getCtaComponent(dealBoxDeepLink);
            CtaComponent couponCta = getCtaComponent(couponBoxDeepLink);
            String couponImage = propertyMap.getOrDefault("billBusterBgImage", COUPON_COMM_DEFAULT_BGIMAGE);
            String productPromotionImage = propertyMap.getOrDefault("productPromotionBgImage", COUPON_COMM_DEFAULT_BGIMAGE);

            Set<Long> offerIds = availablePromotions.stream()
                .filter(availablePromotion -> DEAL_PRODUCT_PROMOTION.equalsIgnoreCase(
                    availablePromotion.getPlanType()))
                .filter(
                    availablePromotion -> !CollectionUtils.isEmpty(availablePromotion.getDealIds()))
                .flatMap(availablePromotion -> availablePromotion.getDealIds().stream())
                .collect(Collectors.toSet());

            Map<Long, OfferResponseModel> offerResponseModels = new HashMap<>();
            if(!CollectionUtils.isEmpty(offerIds)) {
                offerResponseModels.putAll(
                    cartItemService.getOffersByOfferIds(new ArrayList<>(offerIds)));
            }
            for (AvailablePromotion availablePromotion : availablePromotions) {
                if (Objects.nonNull(availablePromotion.getOfferCommunicationData())
                    && Objects.nonNull(availablePromotion.getOfferCommunicationData().getTitle())) {
                    OfferCommData offerCommData = new OfferCommData();
                    List<Long> dealIds = availablePromotion.getDealIds();
                    if (DEAL_PRODUCT_PROMOTION.equalsIgnoreCase(availablePromotion.getPlanType())) {
                        if (CollectionUtils.isEmpty(dealIds) || dealIds.stream()
                            .noneMatch(
                                id -> isPromotionAvailableInWarehouse(id, offerResponseModels,
                                    spokes, clusters))) {
                            continue;
                        }
                        offerCommData.setCta(dealCta);
                    } else if (BILL_BUSTER.equalsIgnoreCase(availablePromotion.getPlanType())) {
                        offerCommData.setCta(couponCta);
                    }
                    offerCommData.setTitle(
                        availablePromotion.getOfferCommunicationData().getTitle());
                    offerCommData.setSubtitle(
                        availablePromotion.getOfferCommunicationData().getSubtitle());
                    if (!CollectionUtils.isEmpty(dealIds) && dealIds.size() == 1 && Objects.nonNull(
                        offerResponseModels.get(dealIds.get(0)))) {
                        offerCommData.setIcon(offerResponseModels.get(dealIds.get(0)).getImage());
                    } else {
                        offerCommData.setIcon(availablePromotion.getOfferCommunicationIcon());
                    }
                    if (DEAL_PRODUCT_PROMOTION.equalsIgnoreCase(availablePromotion.getPlanType())) {
                        offerCommData.setBgImage(productPromotionImage);
                    } else {
                        offerCommData.setBgImage(couponImage);
                    }
                    offerCommDataList.add(offerCommData);
                }
            }
        }

        private Map<String, Map<String, String>> getStaticPropertiesForOfferComm (String lang){
            List<StaticPropertiesRequestModel> staticPropertiesRequestModels = new ArrayList<>();
            StaticPropertiesRequestModel deliveryRequestModel =
                StaticPropertiesRequestModel.builder()
                    .propertyKey(OFFER_COMM_WIDGET).propertyName(DELIVERY_COMM).lang(lang).build();
            StaticPropertiesRequestModel couponRequestModel = StaticPropertiesRequestModel.builder()
                .propertyKey(OFFER_COMM_WIDGET).propertyName(COUPON_COMM).lang(lang).build();
            staticPropertiesRequestModels.add(deliveryRequestModel);
            staticPropertiesRequestModels.add(couponRequestModel);
            Map<String, String> staticPropertyResponseMap = staticPropertyService
                .getMultiStaticPropertyMap(lang, staticPropertiesRequestModels);

            Map<String, Map<String, String>> staticPropertyMap = new HashMap<>();
            for (String key : staticPropertyResponseMap.keySet()) {
                try {
                    Map<String, String> valueMap =
                        objectMapper.readValue(staticPropertyResponseMap.get(key),
                            new TypeReference<Map<String, String>>() {
                            });
                    staticPropertyMap.put(key, valueMap);
                } catch (Exception e) {
                    log.error("Exception to parse the value for key " + key);
                }
            }
            return staticPropertyMap;
        }

        private List<Integer> getSpokes(LocationInfo locationInfo) {
            Map<WarehouseType, List<Integer>> warehouseTypeListMap = locationInfo.getWarehouseTypeListMap();

            Set<Integer> spokes = warehouseTypeListMap != null ?
                warehouseTypeListMap.values().stream()
                    .filter(list -> !CollectionUtils.isEmpty(list))
                    .flatMap(List::stream)
                    .collect(Collectors.toSet())
                : new HashSet<>();

            return new ArrayList<>(spokes);
        }

    private List<Integer> getClusters(LocationInfo locationInfo) {
        return Objects.nonNull(locationInfo) ?
            locationInfo.getClusters() : new ArrayList<>();
    }


}


=== REVERSE DEPENDENCY ===
# /Users/dealshare/Downloads/cart-service/src/main/java/com/dealshare/service/cartservice/services/impl/CartConfigV2ServiceImpl.java

package com.dealshare.service.cartservice.services.impl;

import com.dealshare.service.cartservice.adapters.CartConfigCacheMapper;
import com.dealshare.service.cartservice.constants.AppConstant;
import com.dealshare.service.cartservice.constants.CartConfigConstant;
import com.dealshare.service.cartservice.dtos.CartParamsTransferModelDTO;
import com.dealshare.service.cartservice.entities.CartConfig;
import com.dealshare.service.cartservice.entities.User;
import com.dealshare.service.cartservice.entities.UsersAddressEntity;
import com.dealshare.service.cartservice.enums.DealType;
import com.dealshare.service.cartservice.enums.Language;
import com.dealshare.service.cartservice.exceptions.ValidationException;
import com.dealshare.service.cartservice.feemodule.enums.FeesType;
import com.dealshare.service.cartservice.feemodule.models.DeliveryFeeDataModel;
import com.dealshare.service.cartservice.feemodule.models.PlatformFeeDataModel;
import com.dealshare.service.cartservice.feignclients.ChatServiceClient;
import com.dealshare.service.cartservice.models.*;
import com.dealshare.service.cartservice.services.*;
import com.dealshare.service.cartservice.utils.CartConfigUtils;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;
import org.springframework.util.ObjectUtils;

import java.io.IOException;
import java.math.BigDecimal;
import java.util.*;
import java.util.stream.Collectors;


@Slf4j
@Service
public class CartConfigV2ServiceImpl implements CartConfigV2Service {

    private static final String MAX_ALLOWED_ORD_IN_CART = "maxOrdAllowed";
    private static final String CONFIGURED_ORD_MOV = "configuredMov";
    private static final String NEXT_ORD_ALLOWED_IN_CART = "nextOrdAllowedInCart";


    @Autowired
    CartConfigService cartConfigService;

    @Autowired
    @Qualifier("RankingCacheServiceImpl")
    CacheService rankingCacheService;

    @Autowired
    DeliveryFeeService deliveryFeeService;

    @Autowired
    CartLevelDeliveryFeeServiceImpl cartLevelDeliveryFeeService;

    @Autowired
    PricingService pricingService;

    @Autowired
    CartConfigUtils cartConfigUtils;

    @Autowired
    CartConfigCacheMapper cartConfigCacheMapper;

    @Autowired
    ObjectMapper objectMapper;

    @Value(("${delivery.icon}"))
    String deliveryIcon;

    @Autowired
    ChatServiceClient chatServiceClient;

    @Autowired
    private MovComputationService movComputationService;


    @Override
    public UserCart getCartConfig(String pinCode, UserCart userCart, String source,
                                  User user, LocationV3Model locationV3Model, Boolean cartLevelDeliveryFee, Boolean deliveryFeeCentralisationFlow,
                                  Integer warehouseId, UsersAddressEntity usersAddressEntity,CartParamsTransferModelDTO cartParamsTransferModelDTO) throws IOException {
           userCart.setUserRank(user.getUserRank());
          return cartConfigService.getCartConfig(pinCode, userCart, source, locationV3Model, cartLevelDeliveryFee, deliveryFeeCentralisationFlow, warehouseId,usersAddressEntity,cartParamsTransferModelDTO);
    }

    @Override
    public void computeCartConfigV2(UserCartV2Model userCart, List<Integer> clusters, Boolean cartLevelDeliveryFee,
                                    Boolean deliveryFeeCentralisationFlow, Integer warehouseId, CartParamsTransferModelDTO cartParamsTransferModelDTO) throws IOException {
        if (CollectionUtils.isEmpty(userCart.getCartItems()))  return;

        String specialDealType = userCart.getTotalOrdsInCart() > 0 ? DealType.ORD.name() : "";
        if (CollectionUtils.isEmpty(clusters)) {
            /** if cluster not available then using 0 as a cluster Id*/
            clusters = new ArrayList<>(Arrays.asList(0));
        }

        computeDeliveryFeeConfig(userCart, clusters, cartLevelDeliveryFee, deliveryFeeCentralisationFlow, warehouseId,cartParamsTransferModelDTO);

        if (userCart.getUser().getIsNewUser() && ObjectUtils.isEmpty(specialDealType)) {

            /** same functionality as fetchCorrectUserSegmentForNewUser function in CartConfigServiceImpl */
            String userRank = userCart.getTotalOrdsInCart() > 0
                    ? userCart.getUser().getUserRank() : AppConstant.NEW_USER_SEGMENT;

            /** Compute Delivery Fee Config for New User */
            computeConfigForNewUser(userCart, clusters, userRank, cartLevelDeliveryFee, deliveryFeeCentralisationFlow, warehouseId);
        }
    }

    private void computeDeliveryFeeConfig(UserCartV2Model userCart, List<Integer> clusters, Boolean cartLevelDeliveryFee, Boolean deliveryFeeCentralisationFlow, Integer warehouseId,CartParamsTransferModelDTO cartParamsTransferModelDTO) throws IOException {
        UserCacheModel user = userCart.getUser();
        DeliveryConfig deliveryConfig = new DeliveryConfig();

        deliveryConfig.setCartValue(userCart.getCartPricingSummaryModel().getTotalPrice());
        BigDecimal movComputeAmount = movComputationService.getMovComputeAmount(userCart, cartLevelDeliveryFee, deliveryFeeCentralisationFlow);
        deliveryConfig.setMovComputeAmount(movComputeAmount);

        // refactor required for delivery and ord config - next phase
        CartConfig cartConfig = null;
        // get cart level delivery config here based on what location param we decide, either pincode or warehouse
        if(cartLevelDeliveryFee || deliveryFeeCentralisationFlow){
            cartConfig = cartLevelDeliveryFeeService.fetchCartLevelConfigForDeliveryFee(warehouseId, user.getSource(), user.getId(), user.getUserRank(),
                    cartLevelDeliveryFee, deliveryFeeCentralisationFlow);
        } else {
            cartConfig = deliveryFeeService.fetchCartConfigForDeliveryFee(clusters.get(0), user.getSource(),clusters);
        }

        if(ObjectUtils.isEmpty(cartConfig)){
            log.error("computeDeliveryFeeConfig : cartConfig Empty for user : {}, clusters : {}, " +
                    "received cartConfig from fetchCartConfigForDeliveryFee function", user, clusters);
            throw new ValidationException("Cart Config for Delivery fee not present");
        }
        deliveryConfig.setIsRefundApplied(false);

        // refactor required for delivery and ord config - next phase
        Map<String, Object> feesModelMap = deliveryFeeService.appendCartTitleAndDesc(
                    deliveryConfig,
                    cartConfig,
                    clusters.get(0),
                    user.getSource(),
                    user.getId(),
                    null, // not required
                    user.getPincode().toString(),
                cartLevelDeliveryFee,
                deliveryFeeCentralisationFlow, userCart.getCartId(),userCart.getDiscountSummaryItems(),warehouseId,user.getUserRank(),null,user,cartParamsTransferModelDTO);
        if(deliveryFeeCentralisationFlow){
            mapFeesToUserCart(feesModelMap, userCart, user);
            userCart.setFeesMap(feesModelMap);
        } else {
            userCart.getCartPricingSummaryModel().setTotalPrice(deliveryConfig.getCartValue());
            userCart.setIsCheckOutAllow(deliveryConfig.getIsCheckOutAllow() && userCart.getIsCheckOutAllow());

            if(!ObjectUtils.isEmpty(deliveryConfig.getCheckoutMessage())){
                userCart.setCheckoutMessage(deliveryConfig.getCheckoutMessage().containsKey(user.getLang())
                                ? deliveryConfig.getCheckoutMessage().get(user.getLang())
                                : deliveryConfig.getCheckoutMessage().get(Language.DEFAULT.getValue()));
            }

            userCart.setDeliveryFeeConfigModel(DeliveryFeeConfigModel.builder()
                    .deliveryFee(deliveryConfig.getFreeShipping())
                    .deliveryFeeCancellationMessage(deliveryConfig.getDeliveryFeeCancellationMessage())
                    .deliveryIcon(deliveryIcon)
                    .build());

            if (userCart.getTotalExpiredDealsInCart() == userCart.getCartItems().size()) {
                userCart.getDeliveryFeeConfigModel().setDeliveryFee(new BigDecimal(0));
            }
        }

    }

    private void mapFeesToUserCart(Map<String, Object> feesModelMap, UserCartV2Model userCart, UserCacheModel user){
        for(Map.Entry<String, Object> entry:feesModelMap.entrySet()){
            if(entry.getKey().equals(FeesType.DELIVERY_FEES.name())){
                DeliveryFeeDataModel deliveryFeeDataModel = (DeliveryFeeDataModel) entry.getValue();
                BigDecimal totalValue = userCart.getCartPricingSummaryModel().getTotalPrice().add(BigDecimal.valueOf(deliveryFeeDataModel.getDeliveryFee()));
                userCart.getCartPricingSummaryModel().setTotalPrice(totalValue);
                Map<String, String> messageTitle = deliveryFeeDataModel.getDeliveryFeeMessages().getCartTitle();
                Map<String, String> messageDesc = deliveryFeeDataModel.getDeliveryFeeMessages().getCartDesc();
                if(!ObjectUtils.isEmpty(messageDesc)){
                    userCart.setCheckoutMessage(
                            messageDesc.containsKey(user.getLang())
                                    ? messageDesc.get(user.getLang())
                                    : messageDesc.get(Language.DEFAULT.getValue()));
                }
            }
            else {
                PlatformFeeDataModel platformFeeDataModel = (PlatformFeeDataModel) entry.getValue();
                BigDecimal totalValue = userCart.getCartPricingSummaryModel().getTotalPrice().add(BigDecimal.valueOf(platformFeeDataModel.getFees()));
                userCart.getCartPricingSummaryModel().setTotalPrice(totalValue);
            }
        }
    }

    // refactor required for delivery and ord config - next phase
    private void computeConfigForNewUser(UserCartV2Model userCart,
                                         List<Integer> clusters,
                                         String newUserRank,
                                         Boolean cartLevelDeliveryFee,
                                         Boolean deliveryFeeCentralisationFlow,
                                         Integer warehouseId){
        String source = userCart.getUser().getSource();
        String lang = userCart.getUser().getSource();

        userCart.getCartPricingSummaryModel().setTotalPrice(userCart.getCartPricingSummaryModel().getTotalPrice().subtract(userCart.getDeliveryFeeConfigModel().getDeliveryFee()));
        userCart.getDeliveryFeeConfigModel().setDeliveryFee(new BigDecimal(0));
        userCart.setIsCheckOutAllow(Boolean.TRUE);
        List<String> keys = new ArrayList<>();

        if(cartLevelDeliveryFee){
            // TODO add cart level delivery fee config
            keys.add(String.format(CartConfigConstant.NEW_USER_CART_LEVEL_DELFEE_CONFIG_KEY_FORMAT, newUserRank, warehouseId, source));
            // fallback key with zero warehouseId
            keys.add(String.format(CartConfigConstant.NEW_USER_CART_LEVEL_DELFEE_CONFIG_KEY_FORMAT, newUserRank, 0, source));
        }
        else {
            keys = clusters.stream()
                    .map(clusterId -> String.format(CartConfigConstant.NEW_USER_CART_CONFIG_KEY_FORMAT, newUserRank, clusterId, source))
                    .collect(Collectors.toList());
            // fallback key with zero clusterId
            keys.add(String.format(CartConfigConstant.NEW_USER_CART_CONFIG_KEY_FORMAT, newUserRank, 0, source));
        }

        CartConfig cartConfig = cartConfigUtils.getCartConfigFromRedis(keys);
        if (ObjectUtils.isEmpty(cartConfig)) return;

        try {
            Map<String, String> deliveryFeeMap = new HashMap<>();
            long movComputeAmount = movComputationService.getMovComputeAmount(userCart, cartLevelDeliveryFee, deliveryFeeCentralisationFlow).longValue();
            try {
                deliveryFeeMap = objectMapper.readValue(cartConfig.getConfigMeta(), new TypeReference<HashMap<String, String>>(){});
            } catch (Exception e) {
                log.error("Error fetching config meta for userCart : {}, Exception : {}", userCart, e.getMessage());
            }
            if (!ObjectUtils.isEmpty(deliveryFeeMap) && movComputeAmount < cartConfig.getAmount()) {

                userCart.getDeliveryFeeConfigModel()
                        .setDeliveryFee(new BigDecimal(deliveryFeeMap.get(CartConfigConstant.DELIVERY_FEE)));
                try {
                    Map<String, String> messageDesc = objectMapper.readValue(cartConfig.getMessage(), new TypeReference<HashMap<String, String>>(){});
                    for (String key : messageDesc.keySet()) {
                        messageDesc.put(key, messageDesc.get(key).split("/n")[0]
                                .replace("${ORDER_VALUE}", cartConfig.getAmount() - movComputeAmount + "")
                                .replace("${DELIVERY_FEE}", deliveryFeeMap.get(CartConfigConstant.DELIVERY_FEE)));
                    }
                    userCart.setCheckoutMessage(!ObjectUtils.isEmpty(messageDesc.get(lang)) ?
                            messageDesc.get(lang) :
                            messageDesc.get(Language.DEFAULT.getValue()));

                } catch (Exception e) {
                    log.error("error setting checkout message and checkout title for cart : {}", userCart);
                    userCart.setCheckoutMessage(null);
                }
                userCart.getCartPricingSummaryModel().setTotalPrice(userCart.getCartPricingSummaryModel().getTotalPrice().add(userCart.getDeliveryFeeConfigModel().getDeliveryFee()));
            } else {
                userCart.setCheckoutMessage(null);
            }
        } catch (Exception e) {
            log.error("computeConfigForNewUser : {}", e.getMessage());
        }
    }

}


=== REVERSE DEPENDENCY ===
# /Users/dealshare/Downloads/cart-service/src/main/java/com/dealshare/service/cartservice/services/impl/CartConfigServiceImpl.java

package com.dealshare.service.cartservice.services.impl;

import com.dealshare.common.dtos.orchestration.cp.cartservice.request.OfferCommFcRequest;
import com.dealshare.common.dtos.orchestration.cp.cartservice.response.OfferCommData;
import com.dealshare.service.cartservice.adapters.CartConfigCacheMapper;
import com.dealshare.service.cartservice.adapters.CartConfigMapper;
import com.dealshare.service.cartservice.constants.AppConstant;
import com.dealshare.service.cartservice.constants.AppSource;
import com.dealshare.service.cartservice.constants.CartConfigConstant;
import com.dealshare.service.cartservice.constants.DiscountConstants;
import com.dealshare.service.cartservice.daos.StateClusterCartConfigDao;
import com.dealshare.service.cartservice.dtos.CartParamsTransferModelDTO;
import com.dealshare.service.cartservice.entities.*;
import com.dealshare.service.cartservice.enums.Language;
import com.dealshare.service.cartservice.exceptions.ValidationException;
import com.dealshare.service.cartservice.feemodule.enums.FeesType;
import com.dealshare.service.cartservice.feemodule.models.DeliveryFeeDataModel;
import com.dealshare.service.cartservice.feemodule.models.PlatformFeeDataModel;
import com.dealshare.service.cartservice.feemodule.models.dto.CartConfigFilter;
import com.dealshare.service.cartservice.feemodule.models.dto.WarehouseResponseDto;
import com.dealshare.service.cartservice.feignclients.LocationServiceClient;
import com.dealshare.service.cartservice.feignclients.SchemeServiceClientWrapper;
import com.dealshare.service.cartservice.mappers.CartConfigFilterMapper;
import com.dealshare.service.cartservice.models.ActiveClusterUserMovModel;
import com.dealshare.service.cartservice.models.ActiveOrdCartConfigModel;
import com.dealshare.service.cartservice.models.CartConfigCacheModel;
import com.dealshare.service.cartservice.models.CartConfigModel;
import com.dealshare.service.cartservice.models.CartDiscount.DiscountSummaryItem;
import com.dealshare.service.cartservice.models.CartItem;
import com.dealshare.service.cartservice.models.ClusterMovRequestModel;
import com.dealshare.service.cartservice.models.DealDiscountDetail;
import com.dealshare.service.cartservice.models.DeliveryConfig;
import com.dealshare.service.cartservice.models.LocationV3Model;
import com.dealshare.service.cartservice.models.OrdConfigModel;
import com.dealshare.service.cartservice.models.OrderValueModel;
import com.dealshare.service.cartservice.models.UserCart;
import com.dealshare.service.cartservice.repositories.*;
import com.dealshare.service.cartservice.services.CacheService;
import com.dealshare.service.cartservice.services.CartConfigService;
import com.dealshare.service.cartservice.services.DeliveryFeeService;
import com.dealshare.service.cartservice.services.KeycloakService;
import com.dealshare.service.cartservice.services.MovComputationService;
import com.dealshare.service.cartservice.services.PriceChopService;
import com.dealshare.service.cartservice.services.PricingService;
import com.dealshare.service.cartservice.services.UserSessionService;
import com.dealshare.service.cartservice.services.helper.CartConfigCacheHelper;
import com.dealshare.service.cartservice.utils.CartConfigUtils;
import com.dealshare.service.cartservice.utils.CommonUtils;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.IOException;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.data.domain.*;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringUtils;

import static com.dealshare.service.cartservice.constants.AppConstant.*;
import static com.dealshare.service.cartservice.constants.CartConfigConstant.MAX_PRODUCTS_ALLOWED;

@Slf4j
@Service
public class CartConfigServiceImpl implements CartConfigService {

    @Autowired
    private LocationServiceClient locationServiceClient;


    @Autowired
    private CartConfigCacheHelper cartConfigCacheHelper;

    @Autowired
    private MessageSource messageSource;

    @Autowired
    private CartConfigRepository cartConfigRepository;

    @Autowired
    private CartRepository cartRepository;

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private PriceChopService priceChopService;

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private CartConfigMapper cartConfigMapper;

    @Autowired
    private CartConfigFilterMapper cartConfigFilterMapper;

    @Autowired
    private SchemeServiceClientWrapper schemeServiceClientWrapper;

    @Autowired
    private WarehouseRepository warehouseRepository;

    @Autowired
    private GrowthbookService growthbookService;

    @Autowired
    @Qualifier("CacheServiceImpl")
    private CacheService cacheService;

    @Autowired
    @Qualifier("RankingCacheServiceImpl")
    private CacheService rankingCacheService;

    @Autowired
    private DeliveryFeeService deliveryFeeService;

    @Autowired
    private CartLevelDeliveryFeeServiceImpl cartLevelDeliveryFeeService;

    @Autowired
    private PricingService pricingService;

    @Autowired
    private StateClusterCartConfigDao stateClusterCartConfigDao;

    @Autowired
    private CartConfigUtils cartConfigUtils;

    @Autowired
    private CartConfigCacheMapper cartConfigCacheMapper;

    @Autowired
    private MovComputationService movComputationService;

    @Autowired
    private KeycloakService keycloakService;

    @Autowired
    private UserAddressesRepository userAddressesRepository;

    @Autowired
    private UserSessionService userSessionService;

    private static final String ORD_MOV_PRICE_POINTS = "ordMovPricePoints";
    private static final String MAX_ALLOWED_ORD_IN_CART = "maxOrdAllowed";
    private static final String CONFIGURED_ORD_MOV = "configuredMov";
    private static final String NEXT_ORD_ALLOWED_IN_CART = "nextOrdAllowedInCart";
    private static final String ORD_CART_CONFIG_NAME = "ONE_RUPEE_DEAL_VALUE";
    private static final String ALL_LOCATIONS = "All Locations";

    private static final String NEW_USER_CART_CONFIG_KEY_FORMAT = "CART_CONFIG:%s:CLUSTER:%d:MINIMUM_BAG_VALUE_NEW:%s";

    private static final String NEW_USER_CART_LEVEL_DELFEE_CONFIG_KEY_FORMAT = "CART_CONFIG:%s:WAREHOUSE:%d:MINIMUM_CART_VALUE:%s";


    @Override
    public UserCart getCartConfig(String pinCode, UserCart userCart, String source, LocationV3Model locationV3Model,
                                  Boolean cartLevelDeliveryFee, Boolean deliveryFeeCentralisationFlow, Integer warehouseId, UsersAddressEntity usersAddressEntity,CartParamsTransferModelDTO cartParamsTransferModelDTO)
            throws IOException {
        userCart.setFreeShipping(new BigDecimal(0));
        if (CollectionUtils.isEmpty(userCart.getCartItems())) return userCart;
        String specialDealType = findOutIfSpecialDealTypesExist(userCart);
        DeliveryConfig deliveryConfig = new DeliveryConfig();
        if (!CollectionUtils.isEmpty(locationV3Model.getClusterIds())) {
            userCart = addConfigForDealsWithClusterInfo(userCart, source, locationV3Model, deliveryConfig, cartLevelDeliveryFee, deliveryFeeCentralisationFlow, warehouseId,usersAddressEntity,cartParamsTransferModelDTO);
        } else {
            userCart.setMinOrderValue(new BigDecimal(0));
            userCart = this.defaultCartConfig(userCart, 0, source, pinCode,usersAddressEntity,cartParamsTransferModelDTO);
        }
        if (!specialDealType.isEmpty()) {
            userCart = processConfigForSpecialCarts(userCart, source, specialDealType, locationV3Model);
        }
        Boolean newUser = schemeServiceClientWrapper.getNewUser("en", pinCode, userCart.getUserId());
        userCart.setNewUser(newUser);
        if (newUser) {
            String userRank = fetchCorrectUserSegmentForNewUser(userCart, specialDealType);
            computeConfigForNewUser(userCart, locationV3Model, userRank, source, specialDealType, cartLevelDeliveryFee, deliveryFeeCentralisationFlow, warehouseId);
        }
        return userCart;
    }

    private String fetchCorrectUserSegmentForNewUser(UserCart userCart, String specialDealType) {
        switch (specialDealType) {
            case ORD:
                return userCart.getUserRank();
            default:
                return NEW_USER_SEGMENT;
        }
    }

    private void computeConfigForNewUser(UserCart userCart, LocationV3Model locationV3Model, String userRank, String source,
                                         String specialDealType, Boolean cartLevelDeliveryFee, Boolean deliveryFeeCentralisationFlow,  Integer warehouseId){
        if (!ObjectUtils.isEmpty(specialDealType)) return;
        userCart.setTotalPrice(userCart.getTotalPrice().subtract(userCart.getFreeShipping()));
        userCart.setFreeShipping(new BigDecimal(0));
        userCart.setIsCheckOutAllow(true);
        CartConfig cartConfig = null;
        List<Integer> clusterIds = locationV3Model.getClusterIds();
        if(cartLevelDeliveryFee){
            cartConfig = cartConfigUtils.getCartConfigFromRedis(String.format(NEW_USER_CART_LEVEL_DELFEE_CONFIG_KEY_FORMAT, userRank, warehouseId, source));
        }
        else {
            for (Integer clusterId : clusterIds) {
                try {
                    cartConfig = cartConfigUtils.getCartConfigFromRedis(String.format(NEW_USER_CART_CONFIG_KEY_FORMAT, userRank, clusterId, source));
                } catch (Exception e) {
                    log.error("Error fetching new user cart config for cluster id : {}", clusterId);
                }
                if (!ObjectUtils.isEmpty(cartConfig)) {
                    break;
                }
            }
        }

        if(ObjectUtils.isEmpty(cartConfig)){
            if(cartLevelDeliveryFee) {
                cartConfig = cartConfigUtils.getCartConfigFromRedis(String.format(NEW_USER_CART_LEVEL_DELFEE_CONFIG_KEY_FORMAT, userRank, 0, source));
            }
            else {
                cartConfig = cartConfigUtils.getCartConfigFromRedis(String.format(NEW_USER_CART_CONFIG_KEY_FORMAT, userRank, 0, source));
            }
        }
        Long mov = cartConfig.getAmount();

        if (ObjectUtils.isEmpty(cartConfig)) return;
        try {
            Map<String, String> deliveryFee = new HashMap<>();
            userCart.setCartConfigId(cartConfig.getId());
            Map<String,Long> movConfig = new HashMap<>();
            if(userCart.getConfig()!=null) movConfig = userCart.getConfig();
            movConfig.put(cartLevelDeliveryFee ? MINIMUM_CART_VALUE : MINIMUM_BAG_VALUE_NEW, cartConfig.getId());
            userCart.setConfig(movConfig);
            float movComputeAmount = movComputationService.getMovComputeAmount(userCart, cartLevelDeliveryFee, deliveryFeeCentralisationFlow).floatValue();
            try {
                deliveryFee = objectMapper.readValue(cartConfig.getConfigMeta(), Map.class);
            } catch (Exception ee) {
                log.error("---------- Error fetching config meta for cart --------- {}, Exception : {}", userCart, ee.getMessage());
            }
            if (movComputeAmount < cartConfig.getAmount()) {
                try {
                    Map<String, String> messageTitle = objectMapper.readValue(cartConfig.getTitle(), Map.class);
                    Map<String, String> messageDesc = objectMapper.readValue(cartConfig.getMessage(), Map.class);
                    for (String key : messageTitle.keySet()) {
                        messageTitle.put(key, messageTitle.get(key).replace("${DELIVERY_FEE}", deliveryFee.get(AppConstant.DELIVERY_FEE)));
                        messageDesc.put(key, messageDesc.get(key).split("/n")[0].replace("${ORDER_VALUE}", cartConfig.getAmount().floatValue() - movComputeAmount + "").replace("${DELIVERY_FEE}", deliveryFee.get(AppConstant.DELIVERY_FEE)));
                    }
                    userCart.setCheckoutMessage(messageDesc);
                    userCart.setCheckoutTitle(messageTitle);
                } catch (Exception e) {
                    log.error("error setting checkout message and checkout title for cart : {}", userCart);
                    userCart.setCheckoutMessage(null);
                    userCart.setCheckoutTitle(null);
                }
            } else {
                userCart.setCheckoutMessage(null);
                userCart.setCheckoutTitle(null);
            }
            if (!ObjectUtils.isEmpty(deliveryFee) && userCart.getTotalPrice().compareTo(BigDecimal.valueOf(mov)) < 0) {
                userCart.setFreeShipping(new BigDecimal(deliveryFee.get(AppConstant.DELIVERY_FEE)));
                userCart.setTotalPrice(userCart.getTotalPrice().add(userCart.getFreeShipping()));
            }
        } catch (Exception ee) {
            log.error("computeConfigForNewUser : {}", ee.getMessage());
        }
    }

    private String findOutIfSpecialDealTypesExist(UserCart userCart) {
        String specialDealType = "";
        for (CartItem cartItem : userCart.getCartItems()) {
            if (!ObjectUtils.isEmpty(cartItem.getFeaturedDealType()) &&
                    !cartItem.getIsExpired() && cartItem.getFeaturedDealType().equalsIgnoreCase(ORD)) {
                specialDealType = ORD;
                break;
            } else if (!ObjectUtils.isEmpty(cartItem.getSpecialDealType()) &&
                    !cartItem.getIsExpired() && cartItem.getSpecialDealType().equalsIgnoreCase(PRICE_CHOP_TYPE)) {
                specialDealType = PRICE_CHOP_TYPE;
            }
        }
        return specialDealType;
    }

    private UserCart processConfigForSpecialCarts(UserCart userCart, String source, String specialDealType, LocationV3Model locationV3Model) throws IOException {
        switch (specialDealType) {
            // handled in discount-service
//            case ORD:
//                userCart = addCartConfigForOrdCart(userCart, source, locationV3Model);
//                break;
            case PRICE_CHOP_TYPE:
                userCart = priceChopService.addConfigForPriceChopCart(userCart, source);
                break;
        }
        return userCart;
    }

    private UserCart addConfigForDealsWithClusterInfo(UserCart userCart, String source, LocationV3Model locationV3Model,
                                                      DeliveryConfig deliveryConfig, Boolean cartLevelDeliveryFee, Boolean deliveryFeeCentralisationFlow, Integer warehouseId, UsersAddressEntity usersAddressEntity, CartParamsTransferModelDTO cartParamsTransferModelDTO) throws IOException {
        Integer clusterId = locationV3Model.getClusterIds().get(0);
        deliveryFeeService.excludeLocationsFromOnlinePayment(clusterId, deliveryConfig);
        deliveryConfig.setCartValue(new BigDecimal(deliveryFeeService.getCartValue(userCart)));
        BigDecimal movComputeAmount = movComputationService.getMovComputeAmount(userCart, cartLevelDeliveryFee, deliveryFeeCentralisationFlow);
        deliveryConfig.setMovComputeAmount(movComputeAmount);
        // get config for cart level delivery fee
        CartConfig cartConfig;
        if(cartLevelDeliveryFee){
            cartConfig = cartLevelDeliveryFeeService.fetchCartLevelConfigForDeliveryFee(warehouseId, source, userCart.getUserId(), userCart.getUserRank(),
                    cartLevelDeliveryFee, false);
        } else if(deliveryFeeCentralisationFlow){
            cartConfig = cartLevelDeliveryFeeService.fetchConfigForCentralisation(warehouseId, source, userCart);
        } else {
            cartConfig = deliveryFeeService.fetchCartConfigForDeliveryFee(clusterId, source,locationV3Model.getClusterIds());
        }

        if (!ObjectUtils.isEmpty(cartConfig)) {
            deliveryConfig.setIsRefundApplied(deliveryFeeService.isRefundApplied(userCart));
            List<DiscountSummaryItem> discountSummaryItemList = new ArrayList<>();
            if(deliveryFeeCentralisationFlow){
//                mapToDiscountSummaryItem(userCart);
            }
            if(Objects.nonNull(cartParamsTransferModelDTO)){
                cartParamsTransferModelDTO.setPalId(locationV3Model.getPalId());
            }
            Map<String, Object> feesMap = deliveryFeeService.appendCartTitleAndDesc(deliveryConfig, cartConfig, clusterId, source, userCart.getUserId(),
                    userCart.getPhone(), locationV3Model.getPincode(), cartLevelDeliveryFee, deliveryFeeCentralisationFlow, userCart.getCartId(),
                    discountSummaryItemList,warehouseId, userCart.getUserRank(),usersAddressEntity, null,cartParamsTransferModelDTO);
            deliveryFeeService.transferValuesFromDeliveryConfigToUserCart(feesMap, deliveryConfig, userCart);
            userCart.setFeesMap(feesMap);
            // save different config here
            Map<String,Long> movConfig = new HashMap<>();
            if(userCart.getConfig()!=null) movConfig=userCart.getConfig();
            String configValue;
            Long configId = cartConfig.getId();
            if(cartLevelDeliveryFee) {
                configValue = MINIMUM_CART_VALUE;
            }
            else if(deliveryFeeCentralisationFlow) {
                DeliveryFeeDataModel deliveryFeeDataModel = (DeliveryFeeDataModel) feesMap.get(FeesType.DELIVERY_FEES.name());
                configId = deliveryFeeDataModel.getConfigSnapshot().getConfigId();
                configValue = CENTRALISATION_DELIVERY_FEE;
            }
            else{
                configValue = MINIMUM_BAG_VALUE;
            }
            movConfig.put(configValue, configId);
            userCart.setConfig(movConfig);
            userCart.setCartConfigId(configId);
        }
        List<CartItem> userCartItems = userCart.getCartItems().stream().filter(item -> !item.getIsExpired()).collect(Collectors.toList());
        if (CollectionUtils.isEmpty(userCartItems)) {
            userCart.setTotalPrice(userCart.getTotalPrice());
            userCart.setFreeShipping(new BigDecimal(0));
        }
        return userCart;
    }

    private List<DiscountSummaryItem> mapToDiscountSummaryItem(UserCart userCart){
        List<DiscountSummaryItem> discountSummaryItemList = new ArrayList<>();
        for (CartItem cartItem:userCart.getCartItems()){
            for (DealDiscountDetail dealDiscountDetail : cartItem.getDealDiscountDetails()){
                DiscountSummaryItem discountSummaryItem = new DiscountSummaryItem();
                discountSummaryItem.setAmountApplied(dealDiscountDetail.getDiscountAmount());
                discountSummaryItem.setDiscountType(dealDiscountDetail.getDiscountType());
                discountSummaryItem.setDiscountPlanId(dealDiscountDetail.getDiscountPlanId()!=null?dealDiscountDetail.getDiscountPlanId().longValue():null);
                discountSummaryItemList.add(discountSummaryItem);
            }
        }
        return discountSummaryItemList;
    }


    private void checkRestrictionsOnOrdDeal(UserCart userCart, CartConfig cartConfig) throws IOException {
        Integer maxOrdAllowed = Integer.parseInt(DEFAULT_ALLOWED_ORD_IN_CART);
        Integer mov = cartConfig.getAmount().intValue();
        Integer ordsInCart = userCart.getTotalOrdsInCart();
        Integer configuredMov = null;
        Boolean nextOrdAllowedInCart = false;
        try {
            Map<String, String> movResponse = fetchOrdCartMov(ordsInCart, cartConfig);
            maxOrdAllowed = Integer.parseInt(movResponse.get(MAX_ALLOWED_ORD_IN_CART));
            configuredMov = Integer.parseInt(movResponse.get(CONFIGURED_ORD_MOV));
            nextOrdAllowedInCart = Boolean.valueOf(movResponse.get(NEXT_ORD_ALLOWED_IN_CART));
        } catch (Exception e) {
            log.error(" checkRestrictionsOnOrdDeal : {}", e.getMessage());
        }
        mov = (maxOrdAllowed == 1 || ObjectUtils.isEmpty(configuredMov)) ? mov : configuredMov;
        maxOrdAllowed = ObjectUtils.isEmpty(configuredMov) ? 1 : maxOrdAllowed;
        userCart.setOrdCartMov(mov);
        if (maxOrdAllowed > ordsInCart && nextOrdAllowedInCart) {
            userCart.setIsOrdAddedToCart(false);
            userCart.setGreyOutButtonMessage(null);
        } else if (maxOrdAllowed < ordsInCart) {
            this.expireExtraOrdsInCart(userCart, ordsInCart, maxOrdAllowed);
        }
    }

    private void expireExtraOrdsInCart(UserCart userCart, Integer ordsInCart, Integer maxOrdAllowed) {
        int count = 0;
        for (CartItem item : userCart.getCartItems()) {
            if (!item.getIsExpired() &&
                    item.getFeaturedDealType().equalsIgnoreCase(ORD) &&
                    count < (ordsInCart - maxOrdAllowed)) {
                item.setIsExpired(true);
                item.setIsExpiredReson(OUT_OF_STOCK_SLUG);
                count += item.getQuantityChosen();
            }
        }
        if (count > 0) pricingService.setCartPricingData(userCart);
    }

    public Map<String, String> fetchOrdCartMov(Integer activeOrdsInCart, CartConfig cartConfig) throws IOException {
        if (ObjectUtils.isEmpty(cartConfig.getConfigMeta()))
            throw new ValidationException("No multiple ord config found");
        Map<String, String> response = new HashMap<>();
        Map<String, String> ordMovPricePoints = new HashMap<>();
        Map<String, Object> ordMovConfig = objectMapper.readValue(cartConfig.getConfigMeta(), Map.class);
        Object maxOrdAllowedObj = ordMovConfig.get(MAX_ALLOWED_ORD_IN_CART);
        Long mov = cartConfig.getAmount();
        String configuredMov = null;
        String maxOrdAllowed = DEFAULT_ALLOWED_ORD_IN_CART;
        Boolean nextAllowedInCart = false;
        try {
            ordMovPricePoints = objectMapper.convertValue(ordMovConfig.get(ORD_MOV_PRICE_POINTS), Map.class);
            if (!ObjectUtils.isEmpty(maxOrdAllowedObj) &&
                    !ObjectUtils.isEmpty(ordMovPricePoints) && ordMovPricePoints.containsKey(String.valueOf(activeOrdsInCart))) {
                maxOrdAllowed = String.valueOf(maxOrdAllowedObj);
                int desiredCount = activeOrdsInCart > Integer.parseInt(maxOrdAllowed) ? Integer.parseInt(maxOrdAllowed) : activeOrdsInCart;
                configuredMov = ordMovPricePoints.get(String.valueOf(desiredCount));
                nextAllowedInCart = ordMovPricePoints.containsKey(String.valueOf(activeOrdsInCart + 1));
            }
        } catch (Exception e) {
            log.error("fetchOrdCartMov : {}", e.getMessage());
        }
        mov = (maxOrdAllowed.equalsIgnoreCase(DEFAULT_ALLOWED_ORD_IN_CART) || ObjectUtils.isEmpty(configuredMov)) ? mov : Long.parseLong(configuredMov);
        response.put(MAX_ALLOWED_ORD_IN_CART, maxOrdAllowed);
        response.put(CONFIGURED_ORD_MOV, String.valueOf(mov));
        response.put(NEXT_ORD_ALLOWED_IN_CART, String.valueOf(nextAllowedInCart));
        return response;
    }

    @Override
    public List<ActiveClusterUserMovModel> getActiveClusterOrdMov() {
        List<ActiveOrdCartConfigModel> activeOrdCartConfigModels = stateClusterCartConfigDao.findActiveOrds(ORD_CART_CONFIG_NAME, 1);

        List<CartConfig> globals = cartConfigRepository.findAllByConfigNameAndLocationTypeAndLocationIdAndIsActiveAndConsumerTypeAndLocale(ORD_CART_CONFIG_NAME, CLUSTER, 0, 1, "B2C", "en");
        globals.forEach(cartConfig -> {
            ActiveOrdCartConfigModel model = new ActiveOrdCartConfigModel();
            model.setClusterId(0);
            model.setUserRank(cartConfig.getUserSegment());
            model.setMov(cartConfig.getAmount());
            model.setStateName(ALL_LOCATIONS);
            activeOrdCartConfigModels.add(model);
        });

        List<ActiveClusterUserMovModel> response = new ArrayList<>();
        Map<String, ActiveClusterUserMovModel> map = new HashMap<>();
        activeOrdCartConfigModels.forEach(activeOrdCartConfigModel -> {
            if (map.containsKey(activeOrdCartConfigModel.getStateName() + activeOrdCartConfigModel.getMov())) {
                ActiveClusterUserMovModel model = map.get(activeOrdCartConfigModel.getStateName() + activeOrdCartConfigModel.getMov());
                if (!model.getClusterIds().contains(activeOrdCartConfigModel.getClusterId())) {
                    model.getClusterNames().add(activeOrdCartConfigModel.getClusterName());
                    model.getClusterIds().add(activeOrdCartConfigModel.getClusterId());
                }
                if(!model.getUserRanks().contains(activeOrdCartConfigModel.getUserRank()))
                model.getUserRanks().add(activeOrdCartConfigModel.getUserRank());
            } else {
                ActiveClusterUserMovModel model = new ActiveClusterUserMovModel();
                model.setClusterIds(new ArrayList<>());
                model.setClusterNames(new ArrayList<>());
                model.setStateName(activeOrdCartConfigModel.getStateName());
                model.setUserRanks(new ArrayList<>());
                model.setMov(activeOrdCartConfigModel.getMov());
                model.getClusterIds().add(activeOrdCartConfigModel.getClusterId());
                model.getClusterNames().add(activeOrdCartConfigModel.getClusterName());
                model.getUserRanks().add(activeOrdCartConfigModel.getUserRank());
                map.put(activeOrdCartConfigModel.getStateName() + activeOrdCartConfigModel.getMov(), model);
                response.add(model);
            }
        });
        response.sort((Comparator.comparing(ActiveClusterUserMovModel::getStateName)));
        return response;
    }

    @Transactional
    @Override
    public Boolean deleteClusterOrdMov(ActiveClusterUserMovModel activeClusterUserMovModel) {
        List<Integer> clusterIds = activeClusterUserMovModel.getClusterIds();
        if (activeClusterUserMovModel.getClusterIds().isEmpty()) {
            return false;
        }
        if (activeClusterUserMovModel.getClusterIds().contains(0)) {
            clusterIds = new ArrayList<>();
            clusterIds.add(0);
            throw new ValidationException("global mov cannot be deleted");
        }
        List<CartConfig> alreadyPresents = cartConfigRepository.findByConfigNameAndLocationTypeAndLocationIdInAndIsActiveAndUserSegmentIn(ORD_CART_CONFIG_NAME, "CLUSTER", clusterIds, 1, activeClusterUserMovModel.getUserRanks());
        List<String> redisKeys = new ArrayList<>();
        alreadyPresents.forEach(cartConfig -> {
            redisKeys.add("CART_CONFIG:" + cartConfig.getUserSegment() + ":CLUSTER:" + cartConfig.getLocationId() + ":" + ORD_CART_CONFIG_NAME + ":B2C");
            cartConfig.setIsActive(0);
        });
        cacheService.evictMultiple(redisKeys);
        
        // Set the MySQL session variable to track user who made the change
        String username = keycloakService.getCurrentUsername();
        userSessionService.setCartConfigUser(username);
        
        List<CartConfig> savedConfigs = cartConfigRepository.saveAll(alreadyPresents);
        
        return true;
    }

    @Override
    @Transactional
    public CartConfigModel createConfig(CartConfigModel cartConfigModel) throws IOException {

        if(Objects.isNull(cartConfigModel) || Objects.isNull(cartConfigModel.getLocationId()) || Objects.isNull(cartConfigModel.getUserSegment())
            || Objects.isNull(cartConfigModel.getConfigName())) {
            throw new ValidationException("configName or locationId and userSegment cannot be null");
        }


        Optional<CartConfig> cartConfigData = cartConfigRepository.findByConfigNameAndLocationTypeAndLocationIdAndIsActiveAndConsumerTypeAndUserSegment(cartConfigModel.getConfigName(), cartConfigModel.getLocationType(), cartConfigModel.getLocationId(), 1, "B2C", cartConfigModel.getUserSegment());

        if(cartConfigData.isPresent()) {
            throw new  ValidationException("Same config multiple active config can't be present");
        }


        // Set the MySQL session variable to track user who made the change
        String username = keycloakService.getCurrentUsername();
        userSessionService.setCartConfigUser(username);
        
        CartConfig savedConfig = cartConfigRepository.save(cartConfigMapper.mapModelToEntity(cartConfigModel));
        return cartConfigMapper.mapEntityToModel(savedConfig);
    }

    @Override
    public CartConfigModel getCartConfigData(Long configId) throws IOException {
        Optional<CartConfig> cartConfig = cartConfigRepository.findById(configId);
        if (!cartConfig.isPresent()) {
            throw new ValidationException("Cart Config not found");
        }
        return cartConfigMapper.mapEntityToModel(cartConfig.get());
    }

    @Override
    public CartConfig getCartConfig(Long configId) {
        Optional<CartConfig> cartConfig = cartConfigRepository.findById(configId);
        return cartConfig.orElse(null);
    }

    @Override
    public List<CartConfigModel> getAllCartConfig(String source) throws Exception {
        return cartConfigMapper.mapEntityToModel(cartConfigRepository.findAllByConsumerType(source));
    }

    @Override
    @Transactional
    public Boolean addClusterOrdMov(ClusterMovRequestModel clusterMovRequestModel) throws Exception {
        if(clusterMovRequestModel.getMovAmount()<0){
            throw new ValidationException("Mov amount must not be negative");
        }
        Map<Integer,Integer> clusterIdMap = new HashMap<>();
        clusterMovRequestModel.getClusterIds().forEach(clusterId ->{
            if(clusterIdMap.containsKey(clusterId)) throw new ValidationException("Illegal request");
            clusterIdMap.put(clusterId,clusterId);
        });

        Map<String,String> userRankMap = new HashMap<>();
        clusterMovRequestModel.getUserRanks().forEach(userRank ->{
            if(userRankMap.containsKey(userRank)) throw new ValidationException("Illegal request");
            userRankMap.put(userRank,userRank);
        });
        return this.upsertClusterOrdMov(clusterMovRequestModel);
    }

    public boolean upsertClusterOrdMov(ClusterMovRequestModel clusterMovRequestModel){
        List<Integer> clusterIds = clusterMovRequestModel.getClusterIds();
        List<CartConfig> alreadyPresentEntity = cartConfigRepository.findByConfigNameAndLocationTypeAndLocationIdInAndIsActiveAndUserSegmentIn(ORD_CART_CONFIG_NAME, "CLUSTER", clusterIds, 1, clusterMovRequestModel.getUserRanks());
        Map<String,CartConfig> map = new HashMap<>();
        alreadyPresentEntity.forEach(cartConfig -> {
            map.put(cartConfig.getUserSegment()+"::"+cartConfig.getLocationId(),cartConfig);
        });
        List<CartConfig> entities = new ArrayList<>();

        CartConfig globalConfig = null;

            Optional<CartConfig> cartConfigData = cartConfigRepository.findByConfigNameAndLocationTypeAndLocationIdAndIsActiveAndConsumerTypeAndUserSegment(ORD_CART_CONFIG_NAME, CLUSTER, 0, 1, "B2C", "normal");
            if (cartConfigData.isPresent()) {
                globalConfig = cartConfigData.get();
            } else throw new ValidationException("No global Ord cart config found in db for normal user");


        String configMeta = getCartConfigMeta();
        clusterMovRequestModel.setCartConfigMeta(configMeta);
        log.error("Info Log - ConfigMeta : {}", configMeta);
        CartConfig finalGlobal = globalConfig;
        clusterIds.forEach(clusterId -> {
            clusterMovRequestModel.getUserRanks().forEach(s -> {
                    CartConfig cartConfigModel = new CartConfig();
                    cartConfigModel.setConfigMeta(clusterMovRequestModel.getCartConfigMeta());
                    cartConfigModel.setConfigName(ORD_CART_CONFIG_NAME);
                    cartConfigModel.setAmount(clusterMovRequestModel.getMovAmount());
                    cartConfigModel.setConsumerType("B2C");
                    cartConfigModel.setIsActive(1);
                    cartConfigModel.setLocale("en");
                    cartConfigModel.setLocationType("CLUSTER");
                    cartConfigModel.setLocationId(clusterId);
                    cartConfigModel.setUserSegment(s);
                    cartConfigModel.setTitle(finalGlobal.getTitle());
                    cartConfigModel.setMessage(finalGlobal.getMessage());
                    cartConfigModel.setEndDate(finalGlobal.getEndDate());
                    entities.add(cartConfigModel);
            });
        });

        alreadyPresentEntity.forEach(cartConfig -> {
            cartConfig.setIsActive(0);
            entities.add(cartConfig);
        });

        // Set the MySQL session variable to track user who made the change
        String username = keycloakService.getCurrentUsername();
        userSessionService.setCartConfigUser(username);
        
        List<CartConfig> savedConfigs = cartConfigRepository.saveAll(entities);
        
        cacheAllConfigInRedis();
        return true;
    }
    private String getCartConfigMeta(){
        String configMeta = null;
        try{
            configMeta = locationServiceClient.getStaticPropertiesModels("OGS_EXCLUDE").get(0).getPropertyValue();
        }catch (Exception e){
            log.error("Get Cart Config Meta Exception : {}", e.getMessage());
        }
        return configMeta;
    }

    @Override
    @Transactional
    public CartConfigModel updateConfig(CartConfigModel cartConfigModel, Boolean useMeta) throws IOException {
        if(!useMeta){
            cartConfigModel.setConfigMeta(objectMapper.readTree(getCartConfigMeta()));
        }
        Optional<CartConfig> cartConfig = cartConfigRepository.findById(cartConfigModel.getId());
        if (!cartConfig.isPresent()) {
            throw new ValidationException("Cart Config not found");
        }

        if(cartConfigModel.getIsActive().equals(true)){
            Optional<CartConfig> cartConfigData = cartConfigRepository.findByConfigNameAndLocationTypeAndLocationIdAndIsActiveAndConsumerTypeAndUserSegmentAndIdNot(cartConfigModel.getConfigName(), cartConfigModel.getLocationType(), cartConfigModel.getLocationId(), 1, "B2C", cartConfigModel.getUserSegment(),cartConfig.get().getId());

            if(cartConfigData.isPresent()) {
                throw new  ValidationException("Same config multiple active config can't be present");
            }
        }
        
        // Set the MySQL session variable to track user who made the change
        String username = keycloakService.getCurrentUsername();
        userSessionService.setCartConfigUser(username);
        
        CartConfig updatedConfig = cartConfigCacheHelper.saveAndRefreshCache(cartConfigMapper.mapModelToEntity(cartConfigModel));
        return cartConfigMapper.mapEntityToModel(updatedConfig);
    }

    public UserCart defaultCartConfig(UserCart userCart, Integer locationId, String source, String pinCode,UsersAddressEntity usersAddressEntity,CartParamsTransferModelDTO cartParamsTransferModelDTO) throws IOException {
        CartConfig cartConfig = cartConfigUtils.getCartConfigFromRedis("CART_CONFIG:ALL:CLUSTER:0:MINIMUM_BAG_VALUE:" + source);
        if (!ObjectUtils.isEmpty(cartConfig)) {
            userCart = this.appendCartTitleAndDesc(userCart, cartConfig, locationId, source, pinCode,usersAddressEntity,cartParamsTransferModelDTO);
            Map<String,Long> movConfig = new HashMap<>();
            if(userCart.getConfig()!=null) movConfig = userCart.getConfig();
            movConfig.put(MINIMUM_BAG_VALUE, cartConfig.getId());
            userCart.setConfig(movConfig);
            userCart.setCartConfigId(cartConfig.getId());
        }
        return userCart;
    }

    public UserCart appendCartTitleAndDesc(UserCart userCart, CartConfig cartConfig, Integer locationId, String source,
                                           String pinCode,UsersAddressEntity usersAddressEntity,CartParamsTransferModelDTO cartParamsTransferModelDTO) throws IOException {
        try {

            List<Order> cartFeesOrders = orderRepository.getValidOrdersByCartId(userCart.getCartId());
            Long userAddressId = null;
            if (cartFeesOrders != null && !cartFeesOrders.isEmpty() && cartFeesOrders.get(0) != null) {
                userAddressId = cartFeesOrders.get(0).getUserAddressId();
            }

            if (userAddressId == null || userAddressId == 0L) {
                if (usersAddressEntity != null && usersAddressEntity.getId() != null) {
                    userAddressId = usersAddressEntity.getId();
                } else if (cartParamsTransferModelDTO != null && cartParamsTransferModelDTO.getAddressId() != null) {
                    userAddressId = cartParamsTransferModelDTO.getAddressId();
                }
            }

            if (userAddressId == null || userAddressId == 0L) {
                Long addressPalId = null;
                if (cartParamsTransferModelDTO != null && cartParamsTransferModelDTO.getPalId() != null && cartParamsTransferModelDTO.getPalId() > 0L) {
                    addressPalId = cartParamsTransferModelDTO.getPalId();
                }

                if (addressPalId != null) {
                    Optional<List<UserAddress>> userAddressEntityOptional = userAddressesRepository
                            .findByPalIdAndIsActiveAndUserIdAndAddressIsNotNullOrderByModifiedDateDesc(addressPalId, true, userCart.getUserId());

                    if (userAddressEntityOptional.isPresent()) {
                        List<UserAddress> userAddresses = userAddressEntityOptional.get();
                        if (!CollectionUtils.isEmpty(userAddresses) && userAddresses.get(0) != null) {
                            userAddressId = userAddresses.get(0).getId();
                        }
                    }
                }
            }

            if(userAddressId == null || userAddressId == 0L) {
                //log.error("User address id is null or zero, cannot update delivery fee in cart for cartConfigServiceImpl appendCartTitleDesc method, userId: {}, pinCode: {}, cartConfig: {}, cartId : {}", userCart.getUserId(), pinCode, cartConfig,userCart.getCartId());
                userAddressId = 0L;
            }

            OrderValueModel orderValueModel = deliveryFeeService.getOrderValue(userCart.getUserId(),
                    userCart.getPhone(), pinCode,userAddressId);
            long orderValue = orderValueModel.getOrderValue();
            LocalDateTime startTime = orderValueModel.getStartTime();
            LocalDateTime endTime = orderValueModel.getEndTime();

            Map<String, String> deliveryFee = new HashMap<>();
            try {
                deliveryFee = objectMapper.readValue(cartConfig.getConfigMeta(), Map.class);
            } catch (Exception ee) {
                log.error("Exception in appendCartTitleAndDesc {}", ee.getMessage());
            }
            userCart.setMinOrderValue(new BigDecimal(cartConfig.getAmount()));
            AtomicReference<Float> cartValue = new AtomicReference<>();
            cartValue.set(userCart.getTotalPrice().floatValue());

            if (userCart.getMinOrderValue().longValue() > (orderValue + cartValue.get())) {
                Map<String, String> messageTitle = objectMapper.readValue(cartConfig.getTitle(), Map.class);
                Map<String, String> messageDesc = objectMapper.readValue(cartConfig.getMessage(), Map.class);
                for (String key : messageTitle.keySet()) {
                    if (source.equalsIgnoreCase(AppSource.B2B.name()) || locationId == 13 || locationId == 22) {
                        userCart.setIsCheckOutAllow(Boolean.FALSE);
                        messageTitle.put(key, messageTitle.get(key).replace("${AMOUNT}", userCart.getMinOrderValue() + ""));
                        messageDesc.put(key, messageDesc.get(key).split("/n")[0].replace("${REMAINAMOUNT}", userCart.getMinOrderValue().subtract(userCart.getTotalPrice()) + ""));
                    } else {
                        userCart.setIsCheckOutAllow(Boolean.TRUE);
                        messageTitle.put(key, messageTitle.get(key).replace("${DELIVERY_FEE}", deliveryFee.get(AppConstant.DELIVERY_FEE)));
                        messageDesc.put(key, messageDesc.get(key).split("/n")[0].replace("${ORDER_VALUE}", userCart.getMinOrderValue().subtract(BigDecimal.valueOf((orderValue + cartValue.get()))) + "").replace("${DELIVERY_FEE}", deliveryFee.get(AppConstant.DELIVERY_FEE)));
                    }
                }

                userCart.setCheckoutMessage(messageDesc);
                userCart.setCheckoutTitle(messageTitle);
                userCart.setIsAddToBagAllowed(Boolean.TRUE);
                userCart.setMinOrderValue(new BigDecimal(cartConfig.getAmount()));
            } else {
                CartConfig minimumCartConfig = cartConfigUtils.getCartConfigFromRedis("CART_CONFIG:ALL:CLUSTER:" + locationId + ":MINIMUM_BAG_VALUE_COMP:" + source);
                if (!ObjectUtils.isEmpty(minimumCartConfig)) {
                    Map<String, String> messageTitle = objectMapper.readValue(minimumCartConfig.getTitle(), Map.class);
                    Map<String, String> messageDesc = objectMapper.readValue(minimumCartConfig.getMessage(), Map.class);
                    userCart.setCheckoutMessage(messageDesc);
                    userCart.setCheckoutTitle(messageTitle);
                }
            }

            Optional<List<Cart>> cartLists = cartRepository.findCartsBetweenTime(startTime.toString(), endTime.toString(), userCart.getUserId(),userAddressId);
            if (cartLists.isPresent() && !CollectionUtils.isEmpty(cartLists.get())) {
                    List<Cart> cartWithDeliveryFee = cartLists.get().stream().filter(cart -> (cart.getDeliveryFee() > 0)).collect(Collectors.toList());
                    if (cartWithDeliveryFee.isEmpty()) {
                        applyDeliveryFees(userCart, cartConfig, cartValue.get(), orderValue, new BigDecimal(deliveryFee.get(AppConstant.DELIVERY_FEE)));
                    } else {
                        Optional<Cart> cartWithDeliveryFeeAndActiveOrder = cartWithDeliveryFee.stream().filter(cart -> {
                            List<Order> orders = orderRepository.getOrdersByCartIdWithStatusIn(cart.getId(), Arrays.asList("verified", "draft-verified", "completed"));
                            return !orders.isEmpty();
                        }).findFirst();
                        if (!cartWithDeliveryFeeAndActiveOrder.isPresent())
                            applyDeliveryFees(userCart, cartConfig, cartValue.get(), orderValue, new BigDecimal(deliveryFee.get(AppConstant.DELIVERY_FEE)));
                    }
            } else {
                applyDeliveryFees(userCart, cartConfig, cartValue.get(), orderValue, new BigDecimal(deliveryFee.get(AppConstant.DELIVERY_FEE)));
            }
            return userCart;
        } catch (Exception ee) {
            log.error("Exception in appendCartTitleAndDesc {}", ee.getMessage());
        }
        return userCart;
    }

    private void applyDeliveryFees(UserCart userCart, CartConfig cartConfig, Float cartValue, Long orderValue, BigDecimal deliveryFee) {
        if (cartConfig.getAmount() > (cartValue + orderValue)) {
            userCart.setFreeShipping(deliveryFee);
            userCart.setTotalPrice(userCart.getTotalPrice().add(userCart.getFreeShipping()));
            userCart.setMinOrderValue(new BigDecimal(cartConfig.getAmount()));
        }
    }


    public UserCart appendCartTitleAndDescForOneRupeeDeal(UserCart userCart, CartConfig cartConfig, Integer locationId, String source) throws IOException {
        if (!ObjectUtils.isEmpty(cartConfig)) checkRestrictionsOnOrdDeal(userCart, cartConfig);
        if (!ObjectUtils.isEmpty(cartConfig) && !ObjectUtils.isEmpty(userCart.getOrdCartMov()) && isCartWithOrdMovSatisfied(userCart)) {
            userCart.setIsCheckOutAllow(true);
        } else {
            try {
                Map<String, String> message = objectMapper.readValue(cartConfig.getMessage(), Map.class);
                for (String key : message.keySet()) {
                    message.put(key, message.get(key).replace("${AMOUNT}", String.valueOf(userCart.getOrdCartMov() - (userCart.getTotalPrice().subtract(userCart.getTotalMpPrice()).subtract(userCart.getFreeShipping()).subtract(userCart.getTotalExcludeDealsPrice())).floatValue())));
                }
                userCart.setMessageTextColor(messageSource.getMessage("message.text.color", null, LocaleContextHolder.getLocale()));
                userCart.setMessageBgColor(messageSource.getMessage("message.bg.color", null, LocaleContextHolder.getLocale()));
                userCart.setCheckoutTitle(objectMapper.readValue(cartConfig.getTitle(), Map.class));
                userCart.setCheckoutMessage(message);
                userCart.setHomePageMessageToast(message);
            } catch (Exception e) {
                log.error("ORD deal present in the cart but config not present for this user rank!! userId - " + userCart.getUserId() + " error - " + e.getMessage()+" cartConfig - "+cartConfig+" userCart - "+userCart);
            }
            userCart.setIsCheckOutAllow(false);
        }
        return userCart;
    }

    private boolean isCartWithOrdMovSatisfied(UserCart userCart) {
        return userCart.getOrdCartMov() <=
                (userCart.getTotalPrice().floatValue() + userCart.getTotalPromotionDiscount().floatValue() + userCart.getTotalCartPromotionDiscount().floatValue())
                        - userCart.getTotalMpPrice().floatValue()
                        - userCart.getTotalExcludeDealsPrice().floatValue();
    }
    @Override
    public void cacheAllConfigInRedis() {
        Optional<List<CartConfig>> deactivatedCartConfigs = cartConfigRepository.findAllByIsActive(0);
        deactivatedCartConfigs.ifPresent(configs -> configs.forEach(itemEntity -> {
            if (itemEntity.getId() > 25510) {
                CartConfigCacheModel item = cartConfigCacheMapper.mapEntityToModel(itemEntity);
                rankingCacheService.evict("CART_CONFIG:" + item.getUserSegment()
                        + ":" + item.getLocationType() + ":" + item.getLocationId().toString()
                        + ":" + item.getConfigName() + ":" + item.getConsumerType());
            }
        }));

        Optional<List<CartConfig>> cartConfigs = cartConfigRepository.findAllByIsActive(1);
        cartConfigs.ifPresent(configs -> configs.forEach(itemEntity -> {

            CartConfigCacheModel item = cartConfigCacheMapper.mapEntityToModel(itemEntity);

            rankingCacheService.set("CART_CONFIG:" + item.getUserSegment()
                    + ":" + item.getLocationType() + ":" + item.getLocationId().toString()
                    + ":" + item.getConfigName() + ":" + item.getConsumerType(), item, CommonUtils.getSecondsFromTheDates(itemEntity.getEndDate()));
            rankingCacheService.set("CART_CONFIG_ID:"+item.getId(), item, CommonUtils.getSecondsFromTheDates(itemEntity.getEndDate()));

        }));
    }

    @Override
    public OrdConfigModel fetchOrdConfig(String userRank, String source, List<Integer> clusterIds, String lang){
        OrdConfigModel ordConfigModel = new OrdConfigModel();
        CartConfig cartConfig = new CartConfig();
        List<String> keys = new ArrayList<>();
        try{
            clusterIds.forEach(clusterId -> {
                keys.add("CART_CONFIG:" + userRank + ":CLUSTER:" + clusterId + ":ONE_RUPEE_DEAL_VALUE:" + source);
            });
            keys.add("CART_CONFIG:" + userRank + ":CLUSTER:0:ONE_RUPEE_DEAL_VALUE:" + source);
            List<Object> cartConfigs = rankingCacheService.mget(keys,true);

            for (Object config : cartConfigs) {
                if (config != null) {
                    try {
                        CartConfigCacheModel cartConfigCacheModel = (CartConfigCacheModel) config;
                        cartConfig = cartConfigCacheMapper.mapCacheModelToEntity(cartConfigCacheModel);
                    } catch (Exception e){
                        log.error("Parsing error in cartConfig with exception : {}, cartConfig : {}",e.getMessage(), config);
                        CartConfigCacheModel cartConfigCacheModel = objectMapper.convertValue(config, CartConfigCacheModel.class);
                        cartConfig = cartConfigCacheMapper.mapCacheModelToEntity(cartConfigCacheModel);
                    }
                    break;
                }
            }

            Map<String, String> messageDesc = objectMapper.readValue(cartConfig.getMessage(), Map.class);
            String message = StringUtils.isEmpty(messageDesc.get(lang))
                    ? messageDesc.get(Language.DEFAULT.getValue())
                    : messageDesc.get(lang);
            message = message.replace("${AMOUNT}", cartConfig.getAmount().toString());

            ordConfigModel.setAmount(cartConfig.getAmount());
            ordConfigModel.setMessage(message);
            /** hard coding max NoOfOrdAllowedInCart */
            ordConfigModel.setNoOfOrdAllowedInCart(1L);
            ordConfigModel.setGreyOutButtonMessage(messageSource.getMessage("grey.out.button.message",
                    null,
                    LocaleContextHolder.getLocale()));

        }catch (Exception e){
//            log.error("Exception in fetchOrdConfig: {}, cartConfig : {}, keys : {}", e.getMessage(), cartConfig, keys);
        }
        return ordConfigModel;
    }

    @Override
    public Map<String, Object> getCartConfig(
                            Long userId,
                              String phone,
                              String pinCode,
                              List<Integer> clusterIds,
                              String userRank,
                              String source,
                            String lang){
        Map<String, Object> cartConfigs = new HashMap<>();
        try{
            userRank = StringUtils.isEmpty(userRank)?"normal":userRank.trim();
            source = StringUtils.isEmpty(source)?"B2C":source.trim();
            lang = StringUtils.isEmpty(lang)?Language.DEFAULT.getValue():lang.trim();

            OrdConfigModel ordConfigModel = fetchOrdConfig(userRank, source, clusterIds, lang);
            DeliveryConfig deliveryConfig = deliveryFeeService.deliveryFeeConfig(userId, phone,pinCode,source,clusterIds);
            cartConfigs.put(CartConfigConstant.ORD_CONFIG, ordConfigModel);
            cartConfigs.put(CartConfigConstant.DELIVERY_FEE_CONFIG, deliveryConfig);
            // hardcoded MAX_PRODUCTS_ALLOWED_IN_CART
            cartConfigs.put(CartConfigConstant.MAX_PRODUCTS_ALLOWED_IN_CART, MAX_PRODUCTS_ALLOWED);
            return cartConfigs;
        }catch (Exception e){
            log.error("Exception in getConfig : {}", e.getMessage());
        }
        return cartConfigs;
    }

    @Override
    public CartConfig getCartConfigForCluster(List<Integer> clusterIds) {
        Integer clusterId = clusterIds.get(0);
        return deliveryFeeService.fetchCartConfigForDeliveryFee(clusterId, "B2C",clusterIds);
    }

    @Override
    public Page<CartConfigModel> getPagedCartConfigs(CartConfigFilter filter, Pageable pageable) {
        CartConfig cartConfigProbe = cartConfigFilterMapper.mapCartConfigFilterToEntity(filter);

        ExampleMatcher matcher = ExampleMatcher.matching()
                .withIgnoreNullValues()
                .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING)
                .withIgnoreCase();

        Example<CartConfig> example = Example.of(cartConfigProbe,matcher);

        Sort sort = Sort.by(
                Sort.Order.desc("isActive"),
                Sort.Order.desc("id")
        );

        Pageable sortedPageable = PageRequest.of(
                pageable.getPageNumber(),
                pageable.getPageSize(),
                sort
        );

        Set<Integer> activeWarehouseIds = getAllActiveWarehouses().getWarehouses().keySet();

        if (activeWarehouseIds.isEmpty()) {
            return Page.empty(sortedPageable);
        }

        Page<CartConfig> entityPage = cartConfigRepository.findAll(example, sortedPageable);

        List<CartConfigModel> filteredContent = entityPage.getContent()
                .stream()
                .filter(e -> activeWarehouseIds.contains(e.getLocationId()))
                .map(cartConfigFilterMapper::mapCartConfigEntityToModel)
                .collect(Collectors.toList());

        return new PageImpl<>(
                filteredContent,
                sortedPageable,
                entityPage.getTotalElements()
        );
    }

    @Override
    public WarehouseResponseDto getAllActiveWarehouses() {
        List<Object[]> warehouses = warehouseRepository.findDistinctDcIds();
        Map<Integer,String> activeWarehouses = warehouses.stream()
                    .filter(w -> growthbookService.getRiderWarehouseEnabled((Integer) w[0], null).isEnable())
                    .collect(Collectors.toMap(
                            w -> (Integer) w[0],
                            w-> (String) w[1]
                    ));
        return new WarehouseResponseDto(activeWarehouses);
    }
}

=== REVERSE DEPENDENCY ===
# /Users/dealshare/Downloads/cart-service/src/main/java/com/dealshare/service/cartservice/feemodule/controllers/FeesController.java

package com.dealshare.service.cartservice.feemodule.controllers;
import com.dealshare.service.cartservice.feemodule.entities.CartConfig;
import com.dealshare.service.cartservice.feemodule.entities.CartFees;
import com.dealshare.service.cartservice.feemodule.entities.FeeConfiguration;
import com.dealshare.service.cartservice.feemodule.entities.ShipmentFees;
import com.dealshare.service.cartservice.feemodule.models.*;
import com.dealshare.service.cartservice.feemodule.models.dto.CartConfigFilter;
import com.dealshare.service.cartservice.feemodule.models.dto.WarehouseResponseDto;
import com.dealshare.service.cartservice.feemodule.models.revertfees.RevertFeesRequest;
import com.dealshare.service.cartservice.feemodule.models.updatefees.UpdateCartFeesRequest;
import com.dealshare.service.cartservice.feemodule.models.getfees.GetFeesRequest;
import com.dealshare.service.cartservice.feemodule.models.updatefees.UpdateShipmentFeesRequest;
import com.dealshare.service.cartservice.feemodule.services.FeesService;
import com.dealshare.service.cartservice.models.CartConfigModel;
import com.dealshare.service.cartservice.services.CartConfigService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.List;

@Slf4j
@RequestMapping("/v1/fees/")
@RestController
@Validated
@RequiredArgsConstructor
@CrossOrigin(origins = "*", maxAge = 3600)
public class FeesController {

    private final CartConfigService cartConfigService;

    @Autowired
    private FeesService feesService;

    @PostMapping("/compute-cart-fees")
    public ResponseEntity<?> computeCartFees(@Valid @RequestBody ComputeCartFeesRequest computeFeesRequest) {
        log.error("Centralisation Compute Cart Fees Request : {}", computeFeesRequest);
        return new ResponseEntity<>(feesService.computeCartFees(computeFeesRequest), HttpStatus.OK);
    }

    @PostMapping("/compute-shipment-fees")
    public ResponseEntity<?> computeShipmentFees(@Valid @RequestBody ComputeShipmentFeesRequest computeShipmentFeesRequest) {
//        log.error("Centralisation Compute Shipment Fees Request : {}", computeShipmentFeesRequest);
        return new ResponseEntity<>(feesService.computeShipmentFees(computeShipmentFeesRequest), HttpStatus.OK);
    }

    @PostMapping("/update-cart-fees")
    public ResponseEntity<?> updateCartFees(@Valid @RequestBody UpdateCartFeesRequest request) {
        log.error("Centralisation Update Cart Fees Request : {}", request);
        return new ResponseEntity<>(feesService.updateCartFees(request), HttpStatus.OK);
    }

    @PostMapping("/update-shipment-fees")
    public ResponseEntity<?> updateShipmentFees(@Valid @RequestBody UpdateShipmentFeesRequest request) {
//        log.error("Centralisation Update Shipment Fees Request : {}", request);
        return new ResponseEntity<>(feesService.updateShipmentFees(request), HttpStatus.OK);
    }

    @PostMapping("/revert-fees")
    public ResponseEntity<?> revertFees(@Valid @RequestBody RevertFeesRequest revertFeesRequest) {
        log.error("Centralisation Revert Fees Request : {}", revertFeesRequest);
        return new ResponseEntity<>(feesService.revertFees(revertFeesRequest), HttpStatus.OK);
    }

    @PostMapping("/get-fees")
    public ResponseEntity<?> getFees(@Valid @RequestBody GetFeesRequest getFeesRequest) {
        return new ResponseEntity<>(feesService.getFees(getFeesRequest), HttpStatus.OK);
    }

    @PostMapping("/cart/cart-config-benefits")
    public ResponseEntity<?> updateCartConfigBenefits(@RequestBody SyncCartConfigUsesModel request){
        return new ResponseEntity<>(feesService.updateCartConfigBenefits(request), HttpStatus.OK);
    }

    @PostMapping("/centralisation-config")
    public ResponseEntity<?> getCentralisationConfig(@Valid @RequestBody CentralisationConfigRequest request) {
        return new ResponseEntity<>(feesService.getCentralisationConfig(request), HttpStatus.OK);
    }

    @PostMapping("/saveAndUpdateShipmentCartFees")
    public ResponseEntity<?> saveAndUpdateShipmentCartFees(@Valid @RequestBody ShipmentFeesRequest shipmentFeesRequest) {
        return new ResponseEntity<>(feesService.saveAndUpdateShipmentCartFees(shipmentFeesRequest), HttpStatus.OK);
    }

    @PostMapping("/saveAndUpdateCartFees")
    public ResponseEntity<?> saveAndUpdateCartFees(@Valid @RequestBody CartFees requestCartFees) {
        return new ResponseEntity<>(feesService.saveAndUpdateCartFees(requestCartFees), HttpStatus.OK);
    }

    @PostMapping("/create-generic-fee")
    public ResponseEntity<?> createFeeInSystem(@Valid @RequestBody GenericFeeRequest createFeeRequest) {
        log.error("Centralisation Create Fee Request : {}", createFeeRequest);
        FeeConfiguration feeConfiguration =  feesService.createSystemFees(createFeeRequest);
        return new ResponseEntity<>(feeConfiguration, HttpStatus.OK);
    }

    @PostMapping("/update-generic-fee")
    public ResponseEntity<?> updateFeeInSystem(@Valid @RequestBody GenericFeeRequest updateFeeRequest) {
        log.error("Centralisation Update Fee Request : {}", updateFeeRequest);
        FeeConfiguration feeConfiguration =  feesService.updateSystemFees(updateFeeRequest);
        return new ResponseEntity<>(feeConfiguration, HttpStatus.OK);
    }

    @GetMapping("/get-generic-fee/{code}")
    public ResponseEntity<?> getFeeInSystem(@PathVariable String code) {
        log.error("Centralisation Get Fee Request : {}", code);
        FeeConfiguration feeConfiguration = feesService.getSystemFeeByCode(code);
        if (feeConfiguration == null) {
            return new ResponseEntity<>("Fee not found", HttpStatus.NOT_FOUND);
        }
        return new ResponseEntity<>(feeConfiguration, HttpStatus.OK);
    }

    @PostMapping("/cart-configs")
    public ResponseEntity<Page<CartConfigModel>> getConfigs(
            @Valid @RequestBody CartConfigFilter filter,
            @PageableDefault(size = 1000) Pageable pageable) {
        Page<CartConfigModel> page = cartConfigService.getPagedCartConfigs(filter, pageable);
        return ResponseEntity.ok(page);
    }

    @GetMapping("/warehouses")
    public ResponseEntity<?> getAllActiveWarehouses(){
        WarehouseResponseDto warehouseResponseDto = cartConfigService.getAllActiveWarehouses();
        if(warehouseResponseDto==null){
            return new ResponseEntity<>("Warehouses not found", HttpStatus.NOT_FOUND);
        }
        return ResponseEntity.ok(warehouseResponseDto);
    }
}


=== REVERSE DEPENDENCY ===
# /Users/dealshare/Downloads/cart-service/src/main/java/com/dealshare/service/cartservice/utils/CartConfigUtils.java

package com.dealshare.service.cartservice.utils;

import com.dealshare.service.cartservice.adapters.CartConfigCacheMapper;
import com.dealshare.service.cartservice.constants.CartConfigConstant;
import com.dealshare.service.cartservice.entities.CartConfig;
import com.dealshare.service.cartservice.enums.EmailConstants;
import com.dealshare.service.cartservice.enums.EmailSubject;
import com.dealshare.service.cartservice.enums.ExceptionMessages;
import com.dealshare.service.cartservice.exceptions.ValidationException;
import com.dealshare.service.cartservice.feemodule.entities.UserCartConfigBenefits;
import com.dealshare.service.cartservice.feemodule.services.FeesService;
import com.dealshare.service.cartservice.feignclients.ChatServiceClient;
import com.dealshare.service.cartservice.models.CartConfigCacheModel;
import com.dealshare.service.cartservice.models.UserCart;
import com.dealshare.service.cartservice.services.CacheService;
import com.dealshare.service.cartservice.services.CartConfigService;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.util.ObjectUtils;

import java.util.*;
import java.util.stream.Collectors;

import static com.dealshare.service.cartservice.feemodule.enums.FeesType.DELIVERY_FEES;

@Component
@Slf4j
public class CartConfigUtils {

    @Autowired
    @Qualifier("RankingCacheServiceImpl")
    private CacheService cacheService;

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private CartConfigCacheMapper cartConfigCacheMapper;

    @Autowired
    private FeesService feesService;

    @Autowired
    private CartConfigService cartConfigService;

    @Autowired
    ChatServiceClient chatServiceClient;

    public CartConfig getCartConfigFromRedis(String cacheKey){
        CartConfig cartConfig = null;
        Object cacheObject = cacheService.get(cacheKey);
        CartConfigCacheModel cartConfigCacheModel;
        try {
            cartConfigCacheModel = (CartConfigCacheModel) cacheObject;
        } catch (Exception e){
            log.error("Parsing error of cart Config for cacheKey : {} with exception : {}", cacheKey, e.getMessage());
            cartConfigCacheModel = objectMapper.convertValue(cacheObject, CartConfigCacheModel.class);
        }
        if(!ObjectUtils.isEmpty(cartConfigCacheModel)){
            cartConfig = cartConfigCacheMapper.mapCacheModelToEntity(cartConfigCacheModel);
        }
        return cartConfig;
    }

    public CartConfig fetchUserCartConfigBenefits(String cacheKey, Long userId, String locationType, Integer locationId) {
        List<UserCartConfigBenefits> userCartConfigBenefits = feesService.getUserCartConfigBenefitsForUserForLocation(
                userId, locationType, locationId);
        if (userCartConfigBenefits != null && !userCartConfigBenefits.isEmpty()) {
            for(UserCartConfigBenefits userCartConfigBenefitsItem : userCartConfigBenefits) {
                CartConfig cartConfig = cartConfigService.getCartConfig(userCartConfigBenefitsItem.getConfigId());
                if (cartConfig != null && cartConfig.getConfigName().equalsIgnoreCase(DELIVERY_FEES.toString())) {
                    return cartConfig;
                }
            }
        }

        CartConfig cartConfig = this.getCartConfigFromRedis(cacheKey);
        if (cartConfig != null) {
            UserCartConfigBenefits userRankCartConfigBenefits = feesService.getUserCartConfigBenefitsForUserAndConfigForLocation(
                    userId, cartConfig.getId(), locationType, locationId);
            if (userRankCartConfigBenefits == null) {
                return cartConfig;
            } else if (userRankCartConfigBenefits.getAllowedBenefits() - userRankCartConfigBenefits.getUsedBenefits() < 1) {
                return null;
            }
        }

        return null;
    }

    public CartConfigCacheModel fetchUserCartConfigBenefitsCentralization(String cacheKey, Long userId, String locationType, Integer locationId,String configName) {
        CartConfigCacheModel cartConfigCacheModel = null;
        List<UserCartConfigBenefits> userCartConfigBenefits = feesService.getUserCartConfigBenefitsForUserForLocation(
                userId, locationType, locationId);
        if (userCartConfigBenefits != null && !userCartConfigBenefits.isEmpty()) {
            List<CartConfig> cartConfigs = userCartConfigBenefits.stream()
                    .map(userCartConfigBenefitsItem -> cartConfigService.getCartConfig(userCartConfigBenefitsItem.getConfigId()))
                    .filter(Objects::nonNull)
                    .collect(Collectors.toList());
            for(CartConfig cartConfig : cartConfigs){
                if (cartConfig.getConfigName().equalsIgnoreCase(configName)) {
                    cartConfigCacheModel = objectMapper.convertValue(cartConfig, CartConfigCacheModel.class);
                    return cartConfigCacheModel;
                }
            }
        }

        cartConfigCacheModel = objectMapper.convertValue(cacheService.get(cacheKey), CartConfigCacheModel.class);
        if (cartConfigCacheModel != null) {
            UserCartConfigBenefits userRankCartConfigBenefits = feesService.getUserCartConfigBenefitsForUserAndConfigForLocation(
                    userId, cartConfigCacheModel.getId(), locationType, locationId);
            if (userRankCartConfigBenefits == null) {
                return cartConfigCacheModel;
            } else if (userRankCartConfigBenefits.getAllowedBenefits() - userRankCartConfigBenefits.getUsedBenefits() < 1) {
                return null;
            }
        }

        return null;
    }

    public CartConfig getCartConfigFromRedis(List<String> cacheKeys){
        CartConfig cartConfig = null;
        List<Object> cartConfigObjets = cacheService.mget(cacheKeys, true);

        for(Object cartConfigObject : cartConfigObjets) {
            if (cartConfigObject != null) {
                CartConfigCacheModel cartConfigCacheModel;
                try {
                    cartConfigCacheModel = (CartConfigCacheModel) cartConfigObject;
                } catch (Exception e){
                    log.error("Parsing failed of cart Config for cacheKey : {} with exception : {}", cacheKeys, e.getMessage());
                    cartConfigCacheModel = objectMapper.convertValue(cartConfigObject, CartConfigCacheModel.class);
                }
                if(!ObjectUtils.isEmpty(cartConfigCacheModel)){
                    cartConfig = cartConfigCacheMapper.mapCacheModelToEntity(cartConfigCacheModel);
                    break;
                }
            }
        }
        return cartConfig;
    }

    // refactor required for delivery and ord config - next phase
    public CartConfig  getOrdCartConfig(List<Integer> clusters,
                                        String userRank,
                                        String cartSource){


        List<String> keys = clusters.stream()
                .map(clusterId -> String.format(CartConfigConstant.ORD_CART_CONFIG_KEY_FORMAT, userRank.trim(), clusterId, cartSource.trim()))
                .collect(Collectors.toList());

        CartConfig cartConfig = getCartConfigFromRedis(keys);

        // fallback - refactor required
        if ((ObjectUtils.isEmpty(cartConfig))) {
            cartConfig = getCartConfigFromRedis("CART_CONFIG:" + userRank.trim() + ":CLUSTER:0:ONE_RUPEE_DEAL_VALUE:" + cartSource.trim());
            if(ObjectUtils.isEmpty(cartConfig)) {
                cartConfig = getCartConfigFromRedis("CART_CONFIG:" + "normal" + ":CLUSTER:0:ONE_RUPEE_DEAL_VALUE:" + "B2C");
            }
        }
        if(ObjectUtils.isEmpty(cartConfig)){
            chatServiceClient.sendEmailToMultiple(CommonUtils.prepareEmailRequestModel(EmailSubject.ORD_CONFIG_NOT_FOUND.getValue(),
                    String.format("User Rank : %s, Clusters : %s, cartSource : %s", userRank, clusters, cartSource)));
            throw new ValidationException(ExceptionMessages.SOMETHING_WENT_WRONG.getValue());
        }
        return cartConfig;
    }


}


=== REVERSE DEPENDENCY ===
# /Users/dealshare/Downloads/cart-service/src/main/java/com/dealshare/service/cartservice/services/impl/MyOrderServiceImpl.java

package com.dealshare.service.cartservice.services.impl;

import com.dealshare.common.dtos.common.LocationInfo;
import com.dealshare.common.dtos.common.ResponseDealData;
import com.dealshare.common.dtos.common.UserInfo;
import com.dealshare.common.dtos.common.enums.WarehouseType;
import com.dealshare.common.dtos.ingestion.*;
import com.dealshare.common.dtos.orders.mov.GetMovV2RequestBody;
import com.dealshare.productaggregatorservice.models.productaggregator.DealDataRequestModel;
import com.dealshare.productaggregatorservice.models.productaggregator.DealDataResponseModel;
import com.dealshare.service.cartservice.adapters.OrderDetailMapper;
import com.dealshare.service.cartservice.constants.*;
import com.dealshare.service.cartservice.daos.OrderDao;
import com.dealshare.service.cartservice.dtos.BulkOrderReturnWalletUpdate;
import com.dealshare.service.cartservice.dtos.OrderDetailsSummaryDto;
import com.dealshare.service.cartservice.dtos.OrderSmsUpdatesDto;
import com.dealshare.service.cartservice.entities.Package;
import com.dealshare.service.cartservice.entities.*;
import com.dealshare.service.cartservice.enums.DownstreamService;
import com.dealshare.service.cartservice.enums.Language;
import com.dealshare.service.cartservice.enums.StaticPropertiesKeyName;
import com.dealshare.service.cartservice.enums.StaticPropertiesPropertyName;
import com.dealshare.service.cartservice.exceptions.*;
import com.dealshare.service.cartservice.feemodule.entities.FeeConfiguration;
import com.dealshare.service.cartservice.feemodule.enums.*;
import com.dealshare.service.cartservice.feemodule.models.*;
import com.dealshare.service.cartservice.feemodule.models.getfees.FeesData;
import com.dealshare.service.cartservice.feemodule.models.getfees.GetCartFeesResponse;
import com.dealshare.service.cartservice.feemodule.models.getfees.GetFeesRequest;
import com.dealshare.service.cartservice.feemodule.models.getfees.GetFeesResponse;
import com.dealshare.service.cartservice.feemodule.models.updatefees.UpdateCartFeesDetails;
import com.dealshare.service.cartservice.feemodule.models.updatefees.UpdateCartFeesRequest;
import com.dealshare.service.cartservice.feemodule.models.updatefees.UpdateFeesModel;
import com.dealshare.service.cartservice.feemodule.repositories.FeeConfigRepository;
import com.dealshare.service.cartservice.feemodule.services.FeesService;
import com.dealshare.service.cartservice.feignclients.*;
import com.dealshare.service.cartservice.models.*;
import com.dealshare.service.cartservice.models.CreateOrder.AddShipmentDetailsRequestModel;
import com.dealshare.service.cartservice.models.CustomerPoints.DebitedIncentiveRequestModel;
import com.dealshare.service.cartservice.models.Discount.DealDetail;
import com.dealshare.service.cartservice.models.Discount.OrderPromotionData;
import com.dealshare.service.cartservice.models.RevertDiscount.*;
import com.dealshare.service.cartservice.models.Wallet.PlanOrderPointsDto;
import com.dealshare.service.cartservice.models.Wallet.RevertWalletRequest;
import com.dealshare.service.cartservice.models.Wallet.RevertWalletResponse;
import com.dealshare.service.cartservice.models.Wallet.WalletRefundCreditModel;
import com.dealshare.service.cartservice.models.chatbot.ActiveCartIdsRequestModel;
import com.dealshare.service.cartservice.models.growthbook.OrderCancellationConfig;
import com.dealshare.service.cartservice.models.kafka.CancelOrderSellerSyncModel;
import com.dealshare.service.cartservice.models.kafka.KafkaCancellationRequestModel;
import com.dealshare.service.cartservice.models.minimart.*;
import com.dealshare.service.cartservice.models.ordercancellation.ApologySmsDto;
import com.dealshare.service.cartservice.repositories.*;
import com.dealshare.service.cartservice.services.*;
import com.dealshare.service.cartservice.services.util.AppUtil;
import com.dealshare.service.cartservice.services.util.EmailSenderService;
import com.dealshare.service.cartservice.utils.CartConfigUtils;
import com.dealshare.service.cartservice.utils.CommonUtils;
import com.dealshare.service.cartservice.utils.MyOrderPinEncryption;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.time.DateUtils;
import org.jetbrains.annotations.NotNull;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.MessageSource;
import org.springframework.context.annotation.Lazy;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;
import org.springframework.util.ObjectUtils;

import java.io.IOException;
import java.math.BigDecimal;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Function;
import java.util.stream.Collectors;

import static com.dealshare.service.cartservice.constants.AppConstant.*;
import static com.dealshare.service.cartservice.constants.CreateOrderConstants.PAYMENT_SUCCESSFUL;
import static com.dealshare.service.cartservice.constants.SmsTemplate.PRODUCT_NAME;
import static com.dealshare.service.cartservice.constants.SmsTemplate.CREDIT_AMOUNT;
import static com.dealshare.service.cartservice.constants.UserOrderStatus.CANCELLED;
import static com.dealshare.service.cartservice.constants.UserOrderStatus.CUSTOMER_FAULT_CANCELLED_STATUS;
import static com.dealshare.service.cartservice.feemodule.enums.CartConfigNames.DELIVERY_FEES;

@Service
@Slf4j
public class MyOrderServiceImpl implements MyOrderService {

    @Autowired
    private OrderNroRepository orderNroRepository;

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private MessageSource messageSource;

    @Autowired
    private LatLongService latLongService;

    @Autowired
    private InventoryService inventoryService;

    @Autowired
    private PointsService pointsService;

    @Autowired
    private ProductOfferRepository productOfferRepository;

    @Autowired
    private FeeConfigRepository feeConfigRepository;

    @Autowired
    private ProductOfferTranslations productTranslationsRepository;

    @Autowired
    private TransactionServiceHelper transactionServiceHelper;

    @Autowired
    private SchemeServiceClient schemeServiceClient;

    @Autowired
    private PaymentServiceClient paymentServiceClient;

    @Autowired
    private LastMileServiceClient lastMileServiceClient;

    @Autowired
    private UsersAddressRepository usersAddressRepository;

    @Autowired
    private BtocInvoiceDetailsRepository btocInvoiceDetailsRepository;

    @Autowired
    private CartConfigService cartConfigService;

    @Autowired
    @Qualifier("FalseOrderCancellationService")
    private UserOrderStatusConfirmationService orderCancelConfirmationImpl;

    @Autowired
    @Qualifier("FalseOrderDeliveryService")
    private UserOrderStatusConfirmationService orderDeliveryConfirmationImpl;

    @Autowired
    @Qualifier("FalseOrderRescheduleService")
    private UserOrderStatusConfirmationService orderRescheduleConfirmationImpl;

    @Autowired
    private CartConfigRepository cartConfigRepository;

    @Autowired
    private DiscountServiceClient discountServiceClient;

    @Autowired
    private DiscountService discountService;

    @Autowired
    private UserCartServiceImpl userCartService;

    @Autowired
    private DiscountServiceClientWrapper discountServiceClientWrapper;

    @Autowired
    private CartOrderMappingRepository cartOrderMappingRepository;

    @Autowired
    private CartRepository cartRepository;

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private OrderHistoryRepository orderHistoryRepository;

    @Autowired
    private OrderDiscountingHistoryRepository orderDiscountingHistoryRepository;

    @Autowired
    private SqsPublisherService sqsPublisherService;

    @Autowired
    private StaticPropertiesRepository staticPropertiesRepository;

    @Autowired
    private DealServiceClient dealServiceClient;

    @Autowired
    private SmsServiceImpl smsService;

    @Value("${php.invoice.url}")
    private String invoiceUrl;

    @Value("${helpline.phone}")
    private String helplinePhone;

    @Value("${image.base.url}")
    private String imageUrl;

    @Value("${server.username}")
    private String userName;

    @Value("${server.password}")
    private String password;

    @Autowired
    @Qualifier("CacheServiceImpl")
    private CacheService cacheService;

    @Value("${aws.sqs.order-sms-updates.url}")
    private String orderSmsUpdatesQueue;

    @Lazy
    @Autowired
    private CartService cartService;

    @Autowired
    private OrderDao orderDao;

    @Autowired
    private OrderDetailMapper orderDetailMapper;

    @Autowired
    private ReviewServiceClient reviewServiceClient;

    @Autowired
    private SMSQueueEntityRepository smsQueueEntityRepository;

    @Autowired
    private OrderServiceClient orderServiceClient;

    @Autowired
    private EmailSenderService emailSenderService;

    @Autowired
    private CustomerPointsRepository customerPointsRepository;

    @Autowired
    private DoorStepCancellationsOnlineUpdateRepository doorStepCancellationsOnlineUpdateRepository;

    @Autowired
    private StaticDataClient staticDataClient;

    @Autowired
    private QueueProducer queueProducer;

    @Autowired
    private EtaService etaService;

    @Autowired
    private StaticPropertyService staticPropertyService;

    @Autowired
    private UserService userService;

    @Autowired
    UserAddressService userAddressService;

    @Autowired
    private ProductServiceImpl productService;

    @Autowired
    private CartConfigUtils cartConfigUtils;

    @Autowired
    private PackageRepository packageRepository;

    @Autowired
    private PackageOrderRepository packageOrderRepository;

    @Autowired
    private GrowthbookService growthbookService;

    @Autowired
    UserAddressesRepository userAddressesRepository;

    @Value("${aws.sqs.name.post-order-update}")
    String postOrderUpdateQueueName;

    @Autowired
    DealIndexServiceClientWrapper dealIndexServiceClientWrapper;

    @Autowired
    private PaymentRepo paymentRepo;

    @Autowired
    private OrderServiceClientWrapper orderServiceClientWrapper;

    @Autowired
    UserOrderService userOrderService;

    @Autowired
    CommonUtils commonUtils;

    @Autowired
    private CartLevelDeliveryFeeServiceImpl cartLevelDeliveryFeeService;

    @Autowired
    private OrderProductDetailsRepository orderProductDetailsRepository;

    private static final String ORD = "ord";
    private static final String ACTIVE_ORD_COUNT_IN_CART = "activeOrdCountInCart";
    private static final String ORD_CART_SUM = "ordCartSum";
    private static final String CONFIGURED_ORD_MOV = "configuredMov";
    @Autowired
    private UserServiceClient userServiceClient;



    @Autowired
    private POSOrderMappingRepository posOrderMappingRepository;

    @Autowired
    private FeesService feesService;

    @Autowired
    private ChatServiceClient chatServiceClient;

    @Autowired
    private ProductAggregatorService productAggregatorService;

    @Autowired
    private LocationServiceV2Client locationServiceV2Client;

    @Autowired
    private ClusterWarehousesRepository clusterWarehousesRepository;

    @Autowired
    private UserRepository userRepository;
    @Autowired
    private WarehouseEtaConfigRepository warehouseEtaConfigRepository;
    @Autowired
    private WarehouseRepository warehouseRepository;

    @Override
    public MyOrderResponseModel getOrdersBasedOnPhone(Integer pageNo, Integer pageSize, String phone, String lang, String pinCode, String source) {
        Pageable pageable = PageRequest.of(pageNo, pageSize);
        MyOrderResponseModel myOrderResponseModel = new MyOrderResponseModel();
        JsonNode shareData = null;
        if (pageNo == 0) {
            try {
                shareData = schemeServiceClient.getShareData(userName, password, lang, pinCode, "B2C", phone, "ORDER");
            } catch (Exception e) {
                log.error(e.getMessage());
            }
        }
        myOrderResponseModel.setShareData(shareData);
        final List<String> sources = new ArrayList<>(
                AppSource.B2C.getValues().contains(source)
                        ? AppSource.B2C.getValues()
                        : AppSource.B2B.getValues()
        );
        List<Order> orderList = orderRepository.findByPhoneAndSourceInOrderByOrderDateDesc(phone, sources, pageable);
        List<OrderModel> resultList = new ArrayList<>();
        orderList.forEach(orderEntity -> {
            OrderModel orderModel = new OrderModel();
            Optional<ProductOffer> productOffer = productOfferRepository.findByOfferId(orderEntity.getOfferId());
            if (productOffer.isPresent()) {
                List<ProductOfferTranslation> productTranslations = productTranslationsRepository.findAllByOfferId(productOffer.get().getDealId());
                if (!CollectionUtils.isEmpty(productTranslations)) {
                    Map<String, String> productTitles = new HashMap<>();
                    productTranslations.forEach(productTranslation -> productTitles.put(productTranslation.getLang(), productTranslation.getName()));
                    orderModel.setProductTitle(productTitles);
                }
                orderModel.setProductImage(this.fetchDealImage(productOffer.get().getDealId()));
                orderModel.setProductId(productOffer.get().getProductId());
            }
            Optional<List<BtocInvoiceDetails>> invoiceDetails = btocInvoiceDetailsRepository.findByOrderId(orderEntity.getId());
            if (invoiceDetails.isPresent() && invoiceDetails.get().size() != 0) {
                orderModel.setInvoiceUrl(invoiceUrl + orderEntity.getId());
            }
            orderModel.setIsCancelAllowed(MyOrderPinEncryption.getCancelAllowed(orderEntity.getOrderStatus()));
            if(orderEntity.getOrderStatus().equalsIgnoreCase("pending") && !orderEntity.getPaymentType().equalsIgnoreCase(PAYMENT_TYPE_PAYTM)){
                orderModel.setIsCancelAllowed(Boolean.TRUE);
            }
            if (orderEntity.getAmount() != 0.00) {
                orderModel.setShareMessageAmount(orderEntity.getAmount().longValue());
            } else {
                if(orderEntity.getBilledAmount() == null) {
                    log.error("MyOrderServiceImpl getOrdersBasedOnPhone-> orderEntity :{}", orderEntity);
                    orderEntity.setBilledAmount(0.0);
                }
                orderModel.setShareMessageAmount(orderEntity.getBilledAmount().longValue());
            }
            if (orderEntity.getOrderStatus().equalsIgnoreCase(DELIVERED)
                    || orderEntity.getOrderStatus().equalsIgnoreCase(ORDER_REPLACED)) {
                orderModel.setDriverContactNo(helplinePhone);
            }
            if (!ObjectUtils.isEmpty(orderEntity.getDeliveryInfo()) && orderEntity.getOrderStatus().equalsIgnoreCase("outfordelivery")) {
                String[] result = orderEntity.getDeliveryInfo().split("/");
                if (result.length != 0) {
                    orderModel.setDriverName(result[0]);
                    if (result.length == 2) {
                        orderModel.setDriverContactNo(result[1]);
                    } else {
                        orderModel.setDriverContactNo(helplinePhone);
                    }
                }
            }

            String orderStatusText = staticPropertyService.getStaticPropertyCache(
                StaticPropertiesKeyName.SP_ORDER_STATUS.getValue(),
                orderEntity.getOrderStatus(),
                lang
            );

            if (!ObjectUtils.isEmpty(orderStatusText)) {
                orderModel.setOrderStatusDes(orderStatusText);
            } else {
                orderModel.setOrderStatusDes(orderEntity.getOrderStatus());
            }

            if (!orderEntity.getPaymentType().equalsIgnoreCase(OrderPaymentMode.COD.name())) {
                if (orderEntity.getPaymentStatus().equalsIgnoreCase(PaymentStatus.INITIATE_REFUND.name())) {
                    String refundMessageText = staticPropertyService.getStaticPropertyCache (
                        StaticPropertiesKeyName.SP_REFUND_MESSAGE.getValue(),
                        orderEntity.getPaymentStatus(),
                        lang
                    );

                    if (!ObjectUtils.isEmpty(refundMessageText)) {
                        orderModel.setOrderStatusDes(refundMessageText);
                    } else {
                        orderModel.setOrderStatusDes(orderEntity.getPaymentStatus());
                    }

                    String orderStatusTextCOD = staticPropertyService.getStaticPropertyCache (
                        StaticPropertiesKeyName.SP_ORDER_STATUS.getValue(),
                        orderEntity.getPaymentStatus(),
                        lang
                    );

                    if (!ObjectUtils.isEmpty(orderStatusTextCOD)) {
                        orderModel.setRefundMessage(orderStatusTextCOD);
                    } else {
                        orderModel.setRefundMessage(orderEntity.getPaymentStatus());
                    }
                }

                if (orderEntity.getPaymentStatus().equalsIgnoreCase(PaymentStatus.REFUND_DONE.name())) {
                    String refundMessageText = staticPropertyService.getStaticPropertyCache (
                        StaticPropertiesKeyName.SP_ORDER_STATUS.getValue(),
                        orderEntity.getPaymentStatus(),
                        lang
                    );

                    if (!ObjectUtils.isEmpty(refundMessageText)) {
                        orderModel.setOrderStatusDes(refundMessageText);
                    } else {
                        orderModel.setOrderStatusDes(orderEntity.getPaymentStatus());
                    }
                }
            }

            String orderPaymentStatus = staticPropertyService.getStaticPropertyCache (
                StaticPropertiesKeyName.SP_PAYMENT_TYPE_TEXT.getValue(),
                orderEntity.getPaymentType(),
                lang
            );

            if (!ObjectUtils.isEmpty(orderPaymentStatus)) {
                orderModel.setPaymentType(orderPaymentStatus);
            } else {
                orderModel.setPaymentType(orderEntity.getPaymentType());
            }

            orderModel.setPaymentStatus(orderEntity.getPaymentStatus());
            orderModel.setOrderStatus(orderEntity.getOrderStatus());
            orderModel.setSource(orderEntity.getSource());
            orderModel.setId(orderEntity.getId());
            orderModel.setDeliveryDate(orderEntity.getDeliveryDate());
            orderModel.setOfferId(orderEntity.getOfferId());
            orderModel.setOfferType(orderEntity.getOrderType());

            orderModel.setOrderDate(orderEntity.getOrderDate());
            orderModel.setQuantity(orderEntity.getQuantity());
            orderModel.setUserId(orderEntity.getUserId());
            orderModel.setOrderId(orderEntity.getOrderId());
            orderModel.setDeliveryFee(new BigDecimal(0));
            orderModel.setPin(MyOrderPinEncryption.getEncryption(orderEntity.getPhone(), orderEntity.getOrderId()));
            resultList.add(orderModel);
        });

        myOrderResponseModel.setOrders(resultList);
        if(resultList.stream().anyMatch(orderModel -> orderModel.getOrderStatus().equalsIgnoreCase("pending"))){
            myOrderResponseModel.setPendingOrders(true);
        }else{
            myOrderResponseModel.setPendingOrders(false);
        }

        if (myOrderResponseModel.getPendingOrders()) {
            String rtgsPaymentStatusText = staticPropertyService.getStaticPropertyCache (
                StaticPropertiesKeyName.SP_RTGS_ADVANCE_PAYMENT_PENDING.getValue(),
                StaticPropertiesPropertyName.SP_SUCCESS_MESSAGE.getValue(),
                lang
            );

            if (!ObjectUtils.isEmpty(rtgsPaymentStatusText)) {
                myOrderResponseModel.setPendingPaymentMessage(rtgsPaymentStatusText);
            }
        }

        return this.setDeliveryFeeInfoInOrders(myOrderResponseModel);
    }

    public MyOrderResponseModel setDeliveryFeeInfoInOrders(MyOrderResponseModel myOrderResponseModel) {
        AtomicReference<Long> cartId = new AtomicReference<>(0l);
        MyOrderResponseModel myOrderResponseWithDelivery = new MyOrderResponseModel();
        myOrderResponseWithDelivery.setShareData(myOrderResponseModel.getShareData());
        myOrderResponseWithDelivery
            .setOrders(myOrderResponseModel.getOrders().stream().map(orderModel -> {
                if (CommonUtils.cancelOrderStatus.getOrDefault(orderModel.getOrderStatus(), Boolean.TRUE)) {
                    Optional<CartOrderMapping> cartOrderMapping = cartOrderMappingRepository.findFirstByOrderId(orderModel.getId());
                    if (cartOrderMapping.isPresent()) {
                        if (!cartId.get().equals(new AtomicReference<>(cartOrderMapping.get().getCartId()).get())) {
                            Optional<Cart> cartInfo = cartRepository.findById(cartOrderMapping.get().getCartId());
                            cartInfo.ifPresent(cart -> orderModel.setDeliveryFee(new BigDecimal(cart.getDeliveryFee())));
                            orderModel.setCartId(cartOrderMapping.get().getCartId());
                            cartId.set(cartOrderMapping.get().getCartId());
                        } else {
                            orderModel.setDeliveryFee(new BigDecimal(0));
                            orderModel.setCartId(cartOrderMapping.get().getCartId());
                        }
                    }
                } else {
                    orderModel.setDeliveryFee(new BigDecimal(0));
                    orderModel.setCartId(0l);
                }
                return orderModel;
            }).collect(Collectors.toList()));
        return myOrderResponseModel;
    }

    @Override
    public String fetchDealImage(Long offerId) {
        Optional<ProductOfferImage> productOfferImage = productService.getProductOfferImageByOfferIdCache(offerId);
        if (!productOfferImage.isPresent() || StringUtils.isEmpty(productOfferImage.get().getSquareImage())) {
            return "";
        }
        if (productOfferImage.get().getSquareImage().startsWith(AppConstant.IMAGE_URL_CHECK)) {
            return productOfferImage.get().getSquareImage();
        }
        return imageUrl + productOfferImage.get().getSquareImage();
    }

    @Override
    public OrderMovModel checkMinimumMovPerDay(String phone, String source, String pinCode) throws IOException {
        OrderMovModel orderMovModel = new OrderMovModel();
        orderMovModel.setIsShow(Boolean.FALSE);
        return orderMovModel;
    }

    @Override
    public AcceptOrderStatusResponseModel acceptOrderStatusConfirmation(AcceptOrderStatusRequestModel requestModel){
        AcceptOrderStatusResponseModel response = new AcceptOrderStatusResponseModel();
        switch(requestModel.getType()){
            case "cancel":
                response = orderCancelConfirmationImpl.acceptOrderStatusConfirmation(requestModel);
                break;
            case "reschedule":
                response = orderRescheduleConfirmationImpl.acceptOrderStatusConfirmation(requestModel);
                break;
            case "delivered":
                response = orderDeliveryConfirmationImpl.acceptOrderStatusConfirmation(requestModel);
                break;
            default:
                // do nothing
                break;
        }
        return response;
    }

    @Override
    public RejectOrderStatusResponseModel rejectOrderStatusConfirmation(RejectOrderStatusRequestModel requestModel){
        RejectOrderStatusResponseModel response = new RejectOrderStatusResponseModel();
        switch(requestModel.getType()){
            case "cancel":
                response = orderCancelConfirmationImpl.rejectOrderStatusConfirmation(requestModel);
                break;
            case "reschedule":
                response = orderRescheduleConfirmationImpl.rejectOrderStatusConfirmation(requestModel);
                break;
            case "delivered":
                response = orderDeliveryConfirmationImpl.rejectOrderStatusConfirmation(requestModel);
                break;
            default:
                // do nothing
                break;
        }
        return response;
    }

    public OrderMovModel checkMov(long orderAmount, CartConfig cartConfig, OrderMovModel orderMovModel, String source) throws IOException {
        Map<String, String> cartMetaInfo = objectMapper.readValue(cartConfig.getConfigMeta(), Map.class);
        if (cartConfig.getAmount() > orderAmount) {
            orderMovModel = this.addMovMessage(cartConfig, orderMovModel, orderAmount);
        } else {
            Optional<CartConfig> cartConfigComp = cartConfigRepository.findByConfigNameAndLocationTypeAndLocationIdAndIsActiveAndConsumerType(AppConstant.MINIMUM_BAG_VALUE_COMP,
                    AppConstant.CLUSTER, 0, 1, source);
            orderMovModel = this.addMessages(cartConfigComp.get(), orderMovModel);
        }
        return orderMovModel;
    }

    public OrderMovModel addMessages(CartConfig cartConfig, OrderMovModel orderMovModel) throws IOException {
        Map<String, String> messageTitle = objectMapper.readValue(cartConfig.getTitle(), Map.class);
        Map<String, String> messageDesc = objectMapper.readValue(cartConfig.getMessage(), Map.class);
        orderMovModel.setMovTitle(messageTitle);
        orderMovModel.setMovDesc(messageDesc);
        return orderMovModel;
    }

    public OrderMovModel addMovMessage(CartConfig cartConfig, OrderMovModel orderMovModel, Long orderValue) throws IOException {
        Map<String, String> messageTitle = objectMapper.readValue(cartConfig.getTitle(), Map.class);
        Map<String, String> messageDesc = objectMapper.readValue(cartConfig.getMessage(), Map.class);
        Map<String, String> cartConfigMeta = objectMapper.readValue(cartConfig.getConfigMeta(), Map.class);
        for (String key : messageTitle.keySet()) {
            messageTitle.put(key, messageTitle.get(key).replace("${DELIVERY_FEE}", cartConfigMeta.get(AppConstant.DELIVERY_FEE)));
            messageDesc.put(key, messageDesc.get(key).split("/n")[0].replace("${ORDER_VALUE}", (cartConfig.getAmount() - orderValue) + "").replace("${DELIVERY_FEE}", cartConfigMeta.get(AppConstant.DELIVERY_FEE)));
        }
        orderMovModel.setMovTitle(messageTitle);
        orderMovModel.setMovDesc(messageDesc);
        return orderMovModel;
    }


    @Override
    @Transactional
    public Object cancelOrder(OrderCancelModel orderCancelModel, Long userId, Integer palId, Boolean isInternalServiceCall) {

        log.error("Cancel Order request {} and userId : {}, internalServiceCall : {}", orderCancelModel, userId,isInternalServiceCall);

        allowCancellation(orderCancelModel.getOrderId());
        Optional<User> user = userService.getUserFromId(userId,orderCancelModel.getSource());
        if ( ! user.isPresent()) {
            throw new ValidationException("Auth key not exists");
        }

        Optional<Order> order = orderRepository.findByIdAndUserId(orderCancelModel.getOrderId(), user.get().getId());
        if (!order.isPresent()) {
            throw new ValidationException("Order and user id not matching");
        }

        if (this.setCartOrderCancellationKey(orderCancelModel.getOrderId()) == Boolean.FALSE) {
            log.error("Order cancellation is failed due to unable to acquire lock {}, user Id {}", orderCancelModel.getOrderId(), userId);
            throw new ValidationException("Something went wrong, Please try again.");
        }

        ValidationExceptionV2 message = new ValidationExceptionV2();
        List<OrderMovBreach> movBreaches = new ArrayList<>();
        MovBreachMessage movBreachMessage = new MovBreachMessage();
        if (order.isPresent()) {
            if (UserOrderStatus.NONCANCEBLESTATUS.getValues().stream().anyMatch(s -> s.equalsIgnoreCase(order.get().getOrderStatus()))) {
                message.setMessage(messageSource.getMessage("non.cancellable.status", null, LocaleContextHolder.getLocale()));
                return message;
            }
            if (!orderCancelModel.getDiscard()) {
                if ((order.get().getPaymentType().equalsIgnoreCase(OrderPaymentMode.PAYTM.name()) && order.get().getOrderStatus().equalsIgnoreCase("pending"))) {
                    message.setMessage(messageSource.getMessage("cancel.message", null, LocaleContextHolder.getLocale()));
                    return message;
                }
            }
            if(CANCELLED.getValues().stream().anyMatch(s -> s.equalsIgnoreCase(order.get().getOrderStatus()))) {
                message.setMessage(messageSource.getMessage("already.cancelled", null, LocaleContextHolder.getLocale()));
                return message;
            }

            ValidationExceptionV2 validationExceptionV2;
            try{
                Order orderData = order.get();
                Long cartId = null;
                List<CartOrderMapping> cartOrderMappingList = cartOrderMappingRepository.findCartOrderMappings(orderData.getId());
                if (cartOrderMappingList != null && !cartOrderMappingList.isEmpty()) cartId = cartOrderMappingList.get(0).getCartId();

                Optional<UserAddress> userAddress = userAddressesRepository.findById(orderData.getUserAddressId());
                if(!userAddress.isPresent()) throw new ValidationException("User Address not found for this order");

//                LocationV3Model locationV3Model = locationService.getLocationDataFromPinCodeV3(userAddress.get().getPinCode(),
//                                                null, orderCancelModel.getSource(), null);

                Boolean canCancelCentralizedOrder = this.cancelCentralizedOrder(orderData,cartId,cartOrderMappingList);
                Boolean cartLevelDeliveryFee = false;
                if (checkIfCancellationDisabledSingleOrder(user.get().getId(), orderData, isInternalServiceCall,canCancelCentralizedOrder)) {
                    log.error("Cancellation is disabled for this order : {}", orderData.getId());
                    throw new ValidationException(messageSource.getMessage(CANCELLATION_DISABLED_MESSAGE,null, LocaleContextHolder.getLocale()));
                }

                Map<String, Object> cartItemsInfo = this.checkIfCartContainsOrdOrder(orderData, user.get(),
                        orderCancelModel.getOrdSchemeKey(), cartId,orderCancelModel.getDiscard());
                if (cartId == null) {
                    throw new ValidationException("Valid user cart id is missing");
                }
                Boolean cancelOrderBool = (Boolean) cartItemsInfo.get(CART_CONTAINS_ORD);
                /**
                 * First order condition not to put check delivery fee. not handled pop up cancel
                 * from order success screen
                 */
                //scratch card cancellation msg.
                if(!orderCancelModel.getScratchCardKey()) {
                    Map<String, Object> scratchCardRedeemedCheck =
                        this.checkIfScratchCardRedeemed(orderData, cartId);
                    if (scratchCardRedeemedCheck.containsKey(POPUP_MESSAGE_OBJECT)) {
                        return scratchCardRedeemedCheck.get(POPUP_MESSAGE_OBJECT);
                    }
                }
                boolean revertAB = true;
                if(!orderCancelModel.getOrdSchemeKey() && !orderCancelModel.getDeliveryFeeKey()
                    && revertAB) {
                    // Cart Discount Mov breach check
                    OrderMovBreach discountMovBreach =
                        this.getCartDiscountMovBreach(orderData, cartId, orderCancelModel.getLang());
                    log.error("Cancel Order request Cart Discount MovBreach Response  : {}, userId : {},cartId : {}", discountMovBreach,userId,cartId);
                    if (Objects.nonNull(discountMovBreach)) {
                        movBreaches.add(discountMovBreach);
                    }
                }
                Map<String, Object> checkDeliveryFeeInfo = this.checkDeliveryFee(orderData, user.get(), orderCancelModel, cartId);

                log.error("Cancel Order request CheckDeliveryFee Response  : {}, userId : {},cartId : {}", checkDeliveryFeeInfo,userId,cartId);

                cartLevelDeliveryFee = (Boolean) checkDeliveryFeeInfo.get("CART_LEVEL_DELIVERY_FEE") && checkDeliveryFeeInfo.get("CART_LEVEL_DELIVERY_FEE") != null;
                Boolean deliveryFeeCentralisationFlow = (Boolean) checkDeliveryFeeInfo.get("DELIVERY_FEE_CENTRALISATION_FLOW") && checkDeliveryFeeInfo.get("DELIVERY_FEE_CENTRALISATION_FLOW") != null;
                cancelOrderBool = (Boolean) checkDeliveryFeeInfo.get(DELIVERY_FEES_APPLICABLE_CHECK);
                Boolean lastOrder = checkDeliveryFeeInfo.get("LAST_ORDER") != null && (Boolean) checkDeliveryFeeInfo.get("LAST_ORDER");
                if (!orderCancelModel.getOrdSchemeKey() && !orderCancelModel.getDeliveryFeeKey()
                    && checkDeliveryFeeInfo.containsKey(POPUP_MESSAGE_OBJECT)) {
                    List<StaticPropertiesEntity> staticProperties =
                        staticPropertiesRepository.findAllByPropertyKey(DELIVERY_PROP_KEY);
                    if (Objects.isNull(movBreachMessage.getMessage())) {
                        validationExceptionV2 = objectMapper.convertValue(
                            checkDeliveryFeeInfo.get(POPUP_MESSAGE_OBJECT),
                            ValidationExceptionV2.class);
                        addToMovBreachMessage(movBreachMessage, validationExceptionV2);
                    }
                    movBreaches.add(OrderMovBreach.builder()
                        .icon(
                            !CollectionUtils.isEmpty(staticProperties) ? staticProperties.get(0)
                                .getPropertyValue() : null)
                        .message(messageSource.getMessage(DELIVERY_MSG_KEY,
                            new Object[] {checkDeliveryFeeInfo.get("delivery_fee")},
                            LocaleContextHolder.getLocale()))
                        .type("delivery")
                        .build());
                }

                if(!CollectionUtils.isEmpty(movBreaches)) {
                    Collections.reverse(movBreaches);
                    movBreachMessage.setOrderMovBreach(movBreaches);
                    if (Objects.isNull(movBreachMessage.getMessage())) {
                        OrderMovBreach movBreach = movBreaches.get(0);
                        movBreachMessage.setMessageFooter(messageSource
                            .getMessage(MOV_CHECKBOX_MSG, null, LocaleContextHolder.getLocale()));
                        movBreachMessage.setTitle(messageSource
                            .getMessage(MOV_TITLE_MSG, null, LocaleContextHolder.getLocale()));
                        movBreachMessage.setMessage(movBreach.getMessage().replaceAll("<[/]?font>", ""));
                        movBreachMessage.setInternalId(String.valueOf(orderData.getId()));
                        movBreachMessage.setOrdSchemeKey(true);
                    }
                    return movBreachMessage;
                }

                KafkaCancellationRequestModel kafkaPayload = new KafkaCancellationRequestModel();
                kafkaPayload.setCancelOrderBool(cancelOrderBool);
                kafkaPayload.setCartId(cartId);
                kafkaPayload.setCartConfig((CartConfig) cartItemsInfo.get("cartConfig"));
                kafkaPayload.setOrderData(orderData);
                kafkaPayload.setOrderCancelModel(orderCancelModel);
                kafkaPayload.setCancelOrdOrderBool(orderCancelModel.getOrdSchemeKey());
                kafkaPayload.setUserRank(user.get().getUserRank());
                kafkaPayload.setSource(orderCancelModel.getSource());
                kafkaPayload.setPinCode(user.get().getPincode().toString());
                if(!cancelOrderBool) {
                    if(KafkaConstants.KAFKA_ALLOWED) {
                        queueProducer.produceOrderCancellationSyncEvent(kafkaPayload);
                    } else {
                        log.error("Cancel Order request, payload :{}, cartLevelDeliveryFee : {}, internalCall : {}, userId : {}",
                            kafkaPayload, cartLevelDeliveryFee,isInternalServiceCall, userId);
                        orderCancellation(kafkaPayload, cartLevelDeliveryFee, isInternalServiceCall);

                    }
                }

                if (deliveryFeeCentralisationFlow && (Boolean.TRUE.equals(orderCancelModel.getDeliveryFeeKey()) || lastOrder)){

                        List<UpdateFeesModel> updateModels = new ArrayList<>();
                        UpdateFeesModel updateFeesModel = new UpdateFeesModel();
                        updateFeesModel.setFeeType(FeesType.DELIVERY_FEES.name());

                        if(lastOrder){
                            updateFeesModel.setAppliedFees(0.0);
                            updateFeesModel.setFinalFees(0.0);

                            List<FeeConfiguration> feeConfigurations = feeConfigRepository.findAll();
                            if(!feeConfigurations.isEmpty()) {
                                for(FeeConfiguration feeConfiguration : feeConfigurations){
                                    UpdateFeesModel updateGenericFeeModel = new UpdateFeesModel();
                                    updateGenericFeeModel.setFeeType(feeConfiguration.getCode());
                                    updateGenericFeeModel.setAppliedFees(0.0);
                                    updateGenericFeeModel.setFinalFees(0.0);
                                    updateModels.add(updateGenericFeeModel);
                                }
                            }
                        } else {
                            long deliveryFees = checkDeliveryFeeInfo.get("delivery_fee") != null
                                    ? (Long) checkDeliveryFeeInfo.get("delivery_fee")
                                    : 0L;
                            updateFeesModel.setAppliedFees((double) deliveryFees);
                            updateFeesModel.setFinalFees((double) deliveryFees);
                        }
                        updateModels.add(updateFeesModel);


                        UpdateCartFeesDetails updateCartFeesDetails = new UpdateCartFeesDetails();
                        updateCartFeesDetails.setCartId(cartId);
                        updateCartFeesDetails.setUserId(userId);
                        updateCartFeesDetails.setAllOrderCancelled(lastOrder);
                        updateCartFeesDetails.setCartUpdateData(updateModels);

                        UpdateCartFeesRequest updateCartFeesRequest = new UpdateCartFeesRequest();
                        updateCartFeesRequest.setFlow(FlowType.CANCEL_ORDER);
                        updateCartFeesRequest.setUpdateData(Collections.singletonList(updateCartFeesDetails));

                        try {
                            feesService.updateCartFees(updateCartFeesRequest);
                        } catch (Exception ex){
                            log.error("error in updating cart fees during cancel order,updateCartFeesRequest:{}", updateCartFeesRequest);
                        }

                        if (lastOrder) {
                            try {
                                log.error("Request received for creditCartConfigBenefits cartId {} and userId {} orderId {}", cartId, userId, orderCancelModel.getOrderId());
                                feesService.creditCartConfigBenefits(cartId, userId);
                            } catch (Exception ex){
                                log.error("error in cancel-discarded-orders-creditCartConfigBenefits during cancel order cartId : {}", cartId);
                            }
                        }
                }

                try {
                    schemeServiceClient.updateHomePageDiscountUsed(order.get().getUserId());
                } catch (Exception e) {
                    log.error("Something went wrong while updating home page strip discount amount");
                }
                try {
                    int quantity = order.get().getQuantity() == null ? 1 : order.get().getQuantity().intValue();
                    DealInfo dealInfo = DealInfo.builder().offerId(order.get().getOfferId())
                            .quantity(quantity)
                            .build();
                    FrdSoldUpdateModel frdSoldUpdateModel = FrdSoldUpdateModel
                            .builder().dealDetails(Arrays.asList(dealInfo))
                            .userType(user.get().getUserRank())
                            .pincode(userAddress.get().getPalPincode())
                            .palId(userAddress.get().getPalId())
                            .cancelRequest(true).build();
                    dealServiceClient.updateFrdSoldQuantity(frdSoldUpdateModel, userName, password);
                } catch (Exception e) {
                    log.error("Something went wrong while update frd sold quantity for order cancel {}", e.getMessage());
                }
            } catch (Exception e) {
                log.error("cancelOrder Method Exception: {} , userId : {}", e.getMessage(),userId,e);
                throw new ValidationException("Something went wrong , please try again!!");
            }
        }
        //updating the cache when order is cancelled.
        etaService.updateOrderStatusWidgetCacheAsync(etaService.updateCacheForCancelledOrders(order.get()));
        return true;
    }

    private ComputeCartFeesResponse getComputeCartFeesRequest(Order cancelledOrder, OrderCancelModel orderCancelModel, Long cartId){

        List<Order> orderList = orderRepository.findAllOrdersByCartId(cartId);
        List<ComputeFeesOrderDetails> computeFeesOrderDetailsList = new ArrayList<>();
        orderList.forEach(order -> {
            ComputeFeesOrderDetails computeFeesOrderDetails = new ComputeFeesOrderDetails();
            computeFeesOrderDetails.setOrderId(order.getId());
            computeFeesOrderDetails.setQuantity(order.getQuantity());
            computeFeesOrderDetails.setDealPrice(order.getAmount());
            computeFeesOrderDetails.setStatus(order.getOrderStatus());
            computeFeesOrderDetailsList.add(computeFeesOrderDetails);
        });

        List<Long> orderIds = orderList.stream().map(Order::getId).collect(Collectors.toList());

        List<OrderDiscountingHistory> orderDiscountingHistoryList = orderDiscountingHistoryRepository.findAllByOrderIdIn(orderIds);
        List<OrderDiscountingDataModel> orderDiscountingDataModelList = new ArrayList<>();
        orderDiscountingHistoryList.forEach(orderDiscountingHistory -> {
            OrderDiscountingDataModel orderDiscountingDataModel = new OrderDiscountingDataModel();
            orderDiscountingDataModel.setOrderId(orderDiscountingHistory.getOrderId());
            orderDiscountingDataModel.setDiscountAmount(orderDiscountingHistory.getDiscountAmount());
            orderDiscountingDataModel.setDiscountPlanId(orderDiscountingHistory.getDiscountPlanId());
            orderDiscountingDataModel.setDiscountType(orderDiscountingHistory.getDiscountType());
            orderDiscountingDataModelList.add(orderDiscountingDataModel);
        });

        ComputeFeesCancelOrderDetails computeFeesCancelOrderDetails = new ComputeFeesCancelOrderDetails();
        computeFeesCancelOrderDetails.setOrderId(cancelledOrder.getId());
        computeFeesCancelOrderDetails.setQuantity(cancelledOrder.getQuantity().intValue());
        computeFeesCancelOrderDetails.setApplyDeliveryFeeFlag(orderCancelModel.getDeliveryFeeKey());

        ComputeFeesCartDetails computeFeesCartDetails = new ComputeFeesCartDetails();
        computeFeesCartDetails.setCartAmount(orderList.stream().mapToDouble(Order::getAmount).sum());
        computeFeesCartDetails.setOrderDetails(computeFeesOrderDetailsList);
        computeFeesCartDetails.setOrderDiscountDetails(orderDiscountingDataModelList);

        ComputeFeesDetails computeFeesDetails = new ComputeFeesDetails();
        computeFeesDetails.setCartId(cartId);
        computeFeesDetails.setCartDetails(computeFeesCartDetails);
        computeFeesDetails.setCancelOrderDetails(Collections.singletonList(computeFeesCancelOrderDetails));

        ComputeCartFeesRequest computeCartFeesRequest = new ComputeCartFeesRequest();
        computeCartFeesRequest.setFlow(FlowType.CANCEL_ORDER);
        computeCartFeesRequest.setCartData(Collections.singletonList(computeFeesDetails));

        return feesService.computeCartFees(computeCartFeesRequest);

    }

    private Map<String,Object> getDeliveryFeeInfo(ComputeCartFeesResponse computeCartFeesResponse,OrderCancelModel orderCancelModel){
        Map<String, Object> response = new HashMap<>();
        response.put(DELIVERY_FEES_APPLICABLE_CHECK, false);
        response.put("CART_LEVEL_DELIVERY_FEE",Boolean.TRUE);

        DeliveryFeeDataModel deliveryFeeDataModel = objectMapper.convertValue(
                computeCartFeesResponse.getCartFees().get(0).getApplicableFees().get(FeesType.DELIVERY_FEES.name()),
                DeliveryFeeDataModel.class);

        response.put("delivery_fee",deliveryFeeDataModel.getDeliveryFee());
        if(!ObjectUtils.isEmpty(deliveryFeeDataModel.getLastOrderOfCart()) && deliveryFeeDataModel.getLastOrderOfCart()){
            response.put("LAST_ORDER", true);
        }
        if(!ObjectUtils.isEmpty(deliveryFeeDataModel.getDeliveryFeeMessages())){
            ValidationExceptionV2 message = new ValidationExceptionV2();
            message.setMessage(deliveryFeeDataModel.getDeliveryFeeMessages().getCancelCartMessage());
            message.setTitle(deliveryFeeDataModel.getDeliveryFeeMessages().getCancelCartTitle());
            message.setMessageFooter(deliveryFeeDataModel.getDeliveryFeeMessages().getCancelCartFooter());
            message.setInternalId(String.valueOf(orderCancelModel.getOrderId()));
            message.setDeliveryFeeKey(orderCancelModel.getDeliveryFeeKey());
            message.setScratchCardKey(orderCancelModel.getScratchCardKey());
            response.put(POPUP_MESSAGE_OBJECT, message);
        }

        return response;

    }


    @Override
    @Transactional
    public Object cancelAllOrder(List<OrderCancelModel> orderCancelModelList, Long userId, Integer palId) throws Exception {
        // todo : cart id not same
        // todo : all orders present check
        if (orderCancelModelList == null || orderCancelModelList.isEmpty()) {
            throw new ValidationException("Order cancel list is empty");
        }

        String source = null;
        List<KafkaCancellationRequestModel> kafkaCancellationRequestModelList = new ArrayList<>();

        for (OrderCancelModel orderCancelModel : orderCancelModelList) {
            if (orderCancelModel.getSource() != null) {
                source = orderCancelModel.getSource();
                break;
            }
        }
        if (source == null) {
            throw new ValidationException("Source is null");
        }

        Optional<User> userOptional = userService.getUserFromId(userId, source);
        if (!userOptional.isPresent()) {
            throw new ValidationException("Auth key does not exist");
        }

        User user = userOptional.get();
        List<Long> orderIds = getOrderIds(orderCancelModelList);

        List<Order> orderList = orderRepository.findAllByUserIdAndIdIn(user.getId(), orderIds);
        if (orderList.isEmpty()) {
            throw new ValidationException("No matching orders for this user");
        }

        Map<Long, Order> orderMap = orderList.stream().collect(Collectors.toMap(Order::getId, Function.identity()));

        Map<Long,CartOrderMapping> cartOrderMappingMap = getCartIdsFromOrder(orderList);
        List<Long> cartIds = getCartIds(cartOrderMappingMap);
        if(cartIds.size() > 1){
            log.error("More than 1 cart id present : {}", cartOrderMappingMap);
            throw new ValidationException("More than 1 cart id present");
        }

        Boolean allOrdersPresent  = allOrdersPresent(cartIds.get(0),orderIds);
        if(!allOrdersPresent){
            log.error("Not all orders present for cart id : {} , orderIds : {}", cartIds.get(0),orderIds);
            throw new ValidationException("Not all orders present cart id");
        }

        ValidationExceptionV2 message = new ValidationExceptionV2();
        List<OrderMovBreach> movBreaches = new ArrayList<>();

        for (OrderCancelModel orderCancelModel : orderCancelModelList) {
            ValidationExceptionV2 messageResponse = OrderStatusCheck(orderMap.get(orderCancelModel.getOrderId()), orderCancelModel, message);
            if (messageResponse != null) {
                return messageResponse;
            }
        }

        try {
            for (OrderCancelModel orderCancelModel : orderCancelModelList) {
                Order orderData = orderMap.get(orderCancelModel.getOrderId());
                Long cartId = getCartIdForOrder(orderData);
                if (checkIfCancellationDisabled(user.getId(), orderData, true)) {
                    log.error("Cancellation is disabled for order: {}", orderData.getId());
                    throw new ValidationException(messageSource.getMessage(CANCELLATION_DISABLED_MESSAGE, null, LocaleContextHolder.getLocale()));
                }
                Map<String, Object> cartItemsInfo = checkIfCartContainsOrdOrder(orderData, user, orderCancelModel.getOrdSchemeKey(), cartId,false);

                // todo : can remove
                if (!orderCancelModel.getScratchCardKey()) {
                    Map<String, Object> scratchCardRedeemedCheck = checkIfScratchCardRedeemed(orderData, cartId);
                    if (scratchCardRedeemedCheck.containsKey(POPUP_MESSAGE_OBJECT)) {
                        return scratchCardRedeemedCheck.get(POPUP_MESSAGE_OBJECT);
                    }
                }

                if (!orderCancelModel.getOrdSchemeKey() && !orderCancelModel.getDeliveryFeeKey()) {
                    OrderMovBreach discountMovBreach = getCartDiscountMovBreach(orderData, cartId, orderCancelModel.getLang());
                    if (discountMovBreach != null) {
                        movBreaches.add(discountMovBreach);
                    }
                }
                KafkaCancellationRequestModel kafkaPayload = createKafkaCancellationPayload(orderData, orderCancelModel, cartId, user, cartItemsInfo);
                kafkaCancellationRequestModelList.add(kafkaPayload);
            }
        } catch (Exception e) {
            log.error("Exception in cancelOrder: {}", e.getMessage());
            throw new ValidationException("Something went wrong, please try again!");
        }

        try {
            // Process bulk order cancellations via Kafka
            orderCancellationBulk(kafkaCancellationRequestModelList, false); // todo : check cart level delivery fee flag
            kafkaCancellationRequestModelList.forEach(order -> {
                try {
                    processPostCancellationActions(order.getOrderData(), user);
                } catch (Exception e) {
                    log.error("Error during post-cancellation actions for order {}: {}", order.getOrderData().getId(), e.getMessage());
                }
            });
        } catch (Exception e) {
            log.error("Error in cancelOrder method: {}", e.getMessage());
            throw new ValidationException("Something went wrong, please try again!");
        }

        return true;
    }

    private Boolean allOrdersPresent(Long cartId, List<Long> orderIds) {
        List<CartOrderMapping> cartOrderMappingsList = cartOrderMappingRepository.findAllByCartId(cartId);
        if(cartOrderMappingsList.size() > 0){
            for(CartOrderMapping cartOrderMapping : cartOrderMappingsList){
                if(!orderIds.contains(cartOrderMapping.getOrderId())){
                    return false;
                }
            }
        }else{
            return false;
        }
        return true;
    }

    private List<Long> getCartIds(Map<Long, CartOrderMapping> cartOrderMappingMap) {
        List<Long> cartIds = new ArrayList<>();
        for(Long order : cartOrderMappingMap.keySet()){
            if(!cartIds.contains(cartOrderMappingMap.get(order).getCartId())){
                cartIds.add(cartOrderMappingMap.get(order).getCartId());
            }
        }
        return cartIds;
    }

    private Map<Long,CartOrderMapping> getCartIdsFromOrder(List<Order> orderList) {
        List<Long> orderIds = orderList.stream()
                .map(Order::getId)
                .collect(Collectors.toList());
        List<CartOrderMapping> cartOrderMappingList = cartOrderMappingRepository.findAllCartsByOrderIdsIn(orderIds);
        Map<Long,CartOrderMapping> cartOrderMappingMap = new HashMap<>();
        for(CartOrderMapping cartOrderMapping : cartOrderMappingList){
            cartOrderMappingMap.putIfAbsent(cartOrderMapping.getOrderId(),cartOrderMapping);
        }
        return cartOrderMappingMap;
    }

    @Override
    public Map<Long, List<Long>> prepareCartOrdersMap(List<Long> orderIs) {
        Map<Long, List<Long>> cartOrderMappingMap = new HashMap<>();
        List<CartOrderMapping> cartOrderMappingList = cartOrderMappingRepository.findAllCartsByOrderIdsIn(orderIs);
        if (cartOrderMappingList.isEmpty()) {
            return cartOrderMappingMap;
        }

        for (CartOrderMapping cartOrderMapping : cartOrderMappingList) {
            cartOrderMappingMap.putIfAbsent(cartOrderMapping.getCartId(), new ArrayList<>());
            cartOrderMappingMap.get(cartOrderMapping.getCartId()).add(cartOrderMapping.getOrderId());
        }

        return cartOrderMappingMap;
    }

    @Override
    public List<Order> completeCartCancelledWithoutCustomerFault(List<Long> cartOrderIds, List<String> status, List<String> subStatus) {
        List<Order> ordersList = orderRepository.findByIdInAndOrderStatusInAndOrderSubStatusNotIn(cartOrderIds, status, subStatus);
        if (ordersList.isEmpty()) {
            return new ArrayList<>();
        }

        if (ordersList.size() < cartOrderIds.size()) {
            return new ArrayList<>();
        }

        return ordersList;
    }

    @Override
    public List<Long> getOrderIds(List<OrderCancelModel> orderCancelModelList) {
        return orderCancelModelList.stream()
                .map(OrderCancelModel::getOrderId)
                .collect(Collectors.toList());
    }

    @Override
    public ResponseEntity<?> triggerEvent(OrdersStatusUpdateEvent ordersStatusUpdateEvent) {

        log.error("event raise request from cs pannel : ordersStatusUpdateEvent : {}",ordersStatusUpdateEvent);
        try {
            if(ordersStatusUpdateEvent.getEvent().equals("ORDER_CANCEL_BULK") || (ordersStatusUpdateEvent.getEvent().equals("ORDER_PLACED"))){
                triggerOrderStatusUpdateEvent(ordersStatusUpdateEvent.getOrderIds(), ordersStatusUpdateEvent.getEvent());
            }

            if(ordersStatusUpdateEvent.getEvent().equalsIgnoreCase("ORDER_DISCARD_BULK") || ordersStatusUpdateEvent.getEvent().equalsIgnoreCase("ORDER_CANCEL_BULK")) {
                log.error("event raise request from cs pannel : ordersStatusUpdateEvent : {}",ordersStatusUpdateEvent);

                List<Long> uniqueOrderIds = ordersStatusUpdateEvent.getOrderIds().stream().distinct().collect(Collectors.toList());
                Optional<List<CartOrderMapping>> cartOrderMappingList = cartOrderMappingRepository.findAllByOrderIdIn(uniqueOrderIds);
                Map<Long, List<Long>> cartOrderMappingMap = new HashMap<>();
                cartOrderMappingList.ifPresent(cartOrderMappings -> cartOrderMappings.forEach(cartOrderMapping -> {
                    cartOrderMappingMap.putIfAbsent(cartOrderMapping.getCartId(), new ArrayList<>());
                    cartOrderMappingMap.get(cartOrderMapping.getCartId()).add(cartOrderMapping.getOrderId());
                }));
                for (Long cartId : cartOrderMappingMap.keySet()) {
                    ThirdPartyDataPushEventModel data = new ThirdPartyDataPushEventModel();
                    data.setEventTime(ZonedDateTime.now(ZoneId.of("Asia/Kolkata")).toString());
                    if (ordersStatusUpdateEvent.getEvent().equalsIgnoreCase("ORDER_DISCARD_BULK")) {
                        data.setEventType(AppsFlyerEventType.CART_DISCARD);
                    } else {
                        data.setEventType(AppsFlyerEventType.CART_CANCEL);
                    }
                    data.setThirdPartyName(ThirdPartyName.APPSFLYER);
                    ThirdPartyEventsParams params = new ThirdPartyEventsParams();
                    params.setCartId(cartId.toString());
                    List<OrderThirdPartyData> orderThirdPartyDataList = new ArrayList<>();
                    for (Long orderId : cartOrderMappingMap.get(cartId)) {
                        OrderThirdPartyData orderThirdPartyData = new OrderThirdPartyData();
                        orderThirdPartyData.setOrderId(orderId);
                        orderThirdPartyDataList.add(orderThirdPartyData);
                    }
                    params.setOrderIds(orderThirdPartyDataList);
                    data.setThirdPartyEventsParams(params);
                    data.setGetCartDetails(true);
                    data.setGetThirdPartyIds(true);
                    data.setEventTime(ZonedDateTime.now(ZoneId.of("Asia/Kolkata")).toString());
                    queueProducer.produceThirdPartySyncEvent(data);
                    data.setGetThirdPartyIds(false);
                    data.setThirdPartyName(ThirdPartyName.CLEVERTAP);
                    queueProducer.produceThirdPartySyncEvent(data);
                }
            }

            return new ResponseEntity<>("SUCCESS",HttpStatus.OK);
        }catch (Exception e){
            log.error("Exception while triggering event for shipsy for ordersStatusUpdateEvent : {} , with error message : {}",ordersStatusUpdateEvent,e.getMessage());
        }
        return new ResponseEntity<>("FAILED",HttpStatus.BAD_REQUEST);
    }

// Helper methods

    private Long getCartIdForOrder(Order orderData) {
        Optional<CartOrderMapping> cartOrderMapping = cartOrderMappingRepository.findFirstByOrderId(orderData.getId());
        return cartOrderMapping.map(CartOrderMapping::getCartId).orElse(null);
    }

    private KafkaCancellationRequestModel createKafkaCancellationPayload(Order orderData, OrderCancelModel orderCancelModel, Long cartId, User user, Map<String, Object> cartItemsInfo) {
        KafkaCancellationRequestModel kafkaPayload = new KafkaCancellationRequestModel();
        kafkaPayload.setCancelOrderBool(false);
        kafkaPayload.setCartId(cartId);
        kafkaPayload.setCartConfig((CartConfig) cartItemsInfo.get("cartConfig"));
        kafkaPayload.setOrderData(orderData);
        kafkaPayload.setOrderCancelModel(orderCancelModel);
        kafkaPayload.setCancelOrdOrderBool(orderCancelModel.getOrdSchemeKey());
        kafkaPayload.setUserRank(user.getUserRank());
        kafkaPayload.setSource(orderCancelModel.getSource());
        kafkaPayload.setPinCode(user.getPincode().toString());
        return kafkaPayload;
    }

    private void processPostCancellationActions(Order orderData, User user) throws Exception {
        try {
            schemeServiceClient.updateHomePageDiscountUsed(orderData.getUserId());
        } catch (Exception e) {
            log.error("Error updating homepage discount for user {}", orderData.getUserId());
        }

        Optional<UserAddress> userAddress = userAddressesRepository.findById(orderData.getUserAddressId());
        if(!userAddress.isPresent()) throw new ValidationException("User Address not found for this order");
        try {
            int quantity = orderData.getQuantity() == null ? 1 : orderData.getQuantity().intValue();
            DealInfo dealInfo = DealInfo.builder()
                    .offerId(orderData.getOfferId())
                    .quantity(quantity)
                    .build();

            FrdSoldUpdateModel frdSoldUpdateModel = FrdSoldUpdateModel.builder()
                    .dealDetails(Collections.singletonList(dealInfo))
                    .pincode(userAddress.get().getPalPincode())
                    .palId(userAddress.get().getPalId())
                    .userType(user.getUserRank())
                    .cancelRequest(true)
                    .build();

            dealServiceClient.updateFrdSoldQuantity(frdSoldUpdateModel, userName, password);
        } catch (Exception e) {
            log.error("Error updating sold quantity for canceled order {}", orderData.getId());
        }
    }


    private ValidationExceptionV2 OrderStatusCheck(Order order,OrderCancelModel orderCancelModel,ValidationExceptionV2 message) {
        if (UserOrderStatus.NONCANCEBLESTATUS.getValues().stream().anyMatch(s -> s.equalsIgnoreCase(order.getOrderStatus()))) {
            message.setMessage(messageSource.getMessage("non.cancellable.status", null, LocaleContextHolder.getLocale()));
            return message;
        }
        if (!orderCancelModel.getDiscard()) {
            if ((order.getPaymentType().equalsIgnoreCase(OrderPaymentMode.PAYTM.name()) && order.getOrderStatus().equalsIgnoreCase("pending"))) {
                message.setMessage(messageSource.getMessage("cancel.message", null, LocaleContextHolder.getLocale()));
                return message;
            }
        }
        if(CANCELLED.getValues().stream().anyMatch(s -> s.equalsIgnoreCase(order.getOrderStatus()))) {
            message.setMessage(messageSource.getMessage("already.cancelled", null, LocaleContextHolder.getLocale()));
            return message;
        }
        return null;
    }

    private void addToMovBreachMessage(MovBreachMessage movBreachMessage, ValidationExceptionV2 validationExceptionV2)
    {
        movBreachMessage.setMessageFooter(validationExceptionV2.getMessageFooter());
        movBreachMessage.setTitle(validationExceptionV2.getTitle());
        movBreachMessage.setMessage(validationExceptionV2.getMessage());
        movBreachMessage.setInternalId(validationExceptionV2.getInternalId());
        movBreachMessage.setOrdSchemeKey(validationExceptionV2.getOrdSchemeKey());
        movBreachMessage.setDeliveryFeeKey(true);
        movBreachMessage.setScratchCardKey(validationExceptionV2.getScratchCardKey());
    }

    @Transactional
    public void orderCancellation(KafkaCancellationRequestModel kafkaPayload, Boolean cartLevelDeliveryFee,Boolean isInternalServiceCall) {
        Order orderData = kafkaPayload.getOrderData();
        Long cartId=kafkaPayload.getCartId();
        Boolean cancelOrdOrderBool=kafkaPayload.getCancelOrdOrderBool();
        CartConfig cartConfig = kafkaPayload.getCartConfig();
        String source = !ObjectUtils.isEmpty(kafkaPayload.getSource()) ?
            CANCEL_SOURCE_PREFIX + kafkaPayload.getSource() : CANCEL_SOURCE_PREFIX + "app";
        OrderCancelModel orderCancelModel = kafkaPayload.getOrderCancelModel();
        if (CANCELLED.getValues().stream().anyMatch(s -> s.equalsIgnoreCase(orderData.getOrderStatus()))) {
            return;
        }
        try{
            Map<String,Object> response = cancelOrdOrder(orderData,cancelOrdOrderBool,orderCancelModel.getLang(), source,cartConfig, kafkaPayload.getPinCode(), cartId,isInternalServiceCall);
            boolean orderCancelled = response.containsKey(ORDER_ALREADY_CANCELLED) ? Boolean.valueOf(String.valueOf(response.get(ORDER_ALREADY_CANCELLED))) : false;
            if ( ! orderCancelled) {
                processCancelOrder(orderData, source, orderCancelModel, cartId, kafkaPayload.getPinCode(), cartLevelDeliveryFee,isInternalServiceCall);
                pushToSellersPanel(orderData);
            }
        } catch (Exception e) {
            log.error("orderCancellation Method Exception: {} for common function request : {}, cartDelFee : {}", e.getMessage(),kafkaPayload,cartLevelDeliveryFee,e);
            throw new ValidationException("Something went wrong , please try again!!");
        }
    }

    @Transactional
    public void orderCancellationBulk(List<KafkaCancellationRequestModel> kafkaPayloadList, Boolean cartLevelDeliveryFee) {
        if(kafkaPayloadList.size() > 0) {
            KafkaCancellationRequestModel kafkaPayload = kafkaPayloadList.get(0);
            Order orderData = kafkaPayload.getOrderData();
            Long cartId = kafkaPayload.getCartId();
            String source = !ObjectUtils.isEmpty(kafkaPayload.getSource()) ?
                    CANCEL_SOURCE_PREFIX + kafkaPayload.getSource() : CANCEL_SOURCE_PREFIX + "app";
            String pincode = kafkaPayload.getPinCode();
            if (CANCELLED.getValues().stream().anyMatch(s -> s.equalsIgnoreCase(orderData.getOrderStatus()))) {
                return;
            }
            try {
                processCancelOrderBulk(kafkaPayloadList, source, cartId, pincode, cartLevelDeliveryFee);
                pushToSellersPanel(orderData);
            } catch (Exception e) {
                log.error("orderCancellation Method Exception: {}", e.getMessage());
                throw new ValidationException("Something went wrong , please try again!!");
            }
        }
    }


    public void pushToSellersPanel(Order order){
        if(!MARKET_PLACE.equalsIgnoreCase(order.getOrderType()))
            return;


        CancelOrderSellerSyncModel cancelOrderSellerSyncModel= new CancelOrderSellerSyncModel();
        cancelOrderSellerSyncModel.setOrderId(order.getId());
        queueProducer.pushOrderCancelToSellerSync(cancelOrderSellerSyncModel);
    }

    private void processCancelOrder(Order orderData, String source, OrderCancelModel orderCancelModel, Long cartId,
                                    String pinCode, Boolean cartLevelDeliveryFee,Boolean isInternalServiceCall){
        OrderHistory orderHistory = new OrderHistory(orderData, source, orderData.getUserId());
        String orderStatus = CANCEL_STATUS;
        String orderSubStatus = CANCEL_BY_SYSTEM;
        orderData.setOrderStatus(orderStatus);
        orderData.setOrderSubStatus(orderSubStatus);
        if (Optional.ofNullable(orderCancelModel.getCancellationReason()).isPresent()) {
            if(orderCancelModel.getCancellationReason().startsWith(AVP_CANCELLATION_PREFIX)){
                orderData.setOrderSubStatus(orderCancelModel.getCancellationReason());
            }else if(Optional.ofNullable(orderCancelModel.getComments()).isPresent()){
                orderData.setOrderSubStatus(orderCancelModel.getCancellationReason());
                orderData.setComments(orderCancelModel.getComments());
            }
            else {
                String subStatus = fetchReasonForCancellationFromKey(orderCancelModel.getCancellationReasonTag());
                orderData.setOrderSubStatus(subStatus);
                if (subStatus.equals("app_others") && orderCancelModel.getCancellationReason() != null) {
                    orderData.setComments(orderCancelModel.getCancellationReason());
                }
            }
        }
        this.cancelOrderData(orderData, orderCancelModel.getLang(), true,orderHistory, cartId, pinCode, cartLevelDeliveryFee, false, isInternalServiceCall);
    }

    private void processCancelOrderBulk(List<KafkaCancellationRequestModel> kafkaPayloadList, String source, Long cartId,
                                    String pinCode, Boolean cartLevelDeliveryFee){
        List<CancelOrderDataRequestModel> cancelOrderDataRequestModelList = new ArrayList<>();
        for(KafkaCancellationRequestModel kafkaCancellationRequestModel : kafkaPayloadList) {
            Order orderData = kafkaCancellationRequestModel.getOrderData();
            OrderCancelModel orderCancelModel = kafkaCancellationRequestModel.getOrderCancelModel();
            OrderHistory orderHistory = new OrderHistory(orderData, source, orderData.getUserId());
            orderData.setOrderStatus(CANCEL_STATUS);
            orderData.setOrderSubStatus(CANCEL_BY_SYSTEM);
            if (Optional.ofNullable(orderCancelModel.getCancellationReason()).isPresent()) {
                if (orderCancelModel.getCancellationReason().startsWith(AVP_CANCELLATION_PREFIX)) {
                    orderData.setOrderSubStatus(orderCancelModel.getCancellationReason());
                } else {
                    String subStatus = fetchReasonForCancellationFromKey(orderCancelModel.getCancellationReasonTag());
                    orderData.setOrderSubStatus(subStatus);
                    if (subStatus.equals("app_others") && orderCancelModel.getCancellationReason() != null) {
                        orderData.setComments(orderCancelModel.getCancellationReason());
                    }
                }
            }
            cancelOrderDataRequestModelList.add(CancelOrderDataRequestModel.builder()
                            .cartId(cartId)
                            .orderHistory(orderHistory)
                            .orderData(orderData)
                            .lang(orderCancelModel.getLang())
                            .source(kafkaCancellationRequestModel.getSource())
                            .updateMov(true)
                    .build());
        }
        this.cancelOrderDataBulk(cancelOrderDataRequestModelList, cartLevelDeliveryFee);
    }

    private Map<String,Object> cancelOrdOrder( Order order, Boolean forceCancel, String lang, String source, CartConfig cartConfigPayload, String pinCode, Long cartId, Boolean isInternalServiceCall) {
        Map<String, Object> response = new HashMap<>();
        response.put(CART_CONTAINS_ORD, false);
        response.put(ORDER_ALREADY_CANCELLED, false);
        List<String> nonCancellable = UserOrderStatus.NONCANCEBLEFULLSTATUS.getValues();
        response.put(CART_ID, cartId);
        if(order.getOrderType().equalsIgnoreCase(ORD)) return response;
        Long cancelOrderAmount = order.getAmount().longValue();
        List<Order> orders = orderRepository.getOrdersByCartId(cartId);
        if(!Optional.ofNullable(orders).isPresent() || orders.size() == 0) return response;
        Map<String, String> ordCartStatus = sumIfOrdPresent(orders);
        BigDecimal totalAmount = new BigDecimal(ordCartStatus.get(ORD_CART_SUM));
        Integer ordCount = Integer.parseInt(ordCartStatus.get(ACTIVE_ORD_COUNT_IN_CART));
        if(totalAmount.signum() > 0){
            Optional<CartConfig> cartConfig = Optional.of(cartConfigPayload);
            Long mov = fetchMovForOrdCartCancellation(cartConfig.get(), ordCount);
            BigDecimal totalMpAmount = new BigDecimal("0");
            BigDecimal totalOrderAmount = new BigDecimal("0");
            BigDecimal totalExclusionAmount = new BigDecimal("0");
            Map<String, List<Long>> hashMap = new HashMap<>();
            List<String> offerIdList = new LinkedList<>();
            try{
                hashMap = objectMapper.readValue(cartConfig.get().getConfigMeta(), new TypeReference<LinkedHashMap<String, List<Long>>>(){});
                if (!ObjectUtils.isEmpty(hashMap)) {
                  List<Long> l2CategoryIdList = hashMap.get("L2_CATEGORY_IDS");
                  List<Long> dealIdList = hashMap.get("DEAL_IDS");
                  offerIdList =
                      dealIndexServiceClientWrapper
                          .getOfferInfoByOfferIds(
                              CommonUtils.convertListOfStringToString(
                                  orders.stream().map(Order::getOfferId).collect(Collectors.toList())))
                          .stream()
                          .filter(
                              offer ->
                                  l2CategoryIdList.contains(offer.getCategoryId())
                                      || dealIdList.contains(offer.getId()))
                          .map(OfferResponseModel::getOfferId)
                          .collect(Collectors.toList());
                        }
            }catch (Exception e){
                log.error("Exception in  cancelOrdOrder - {}", e.getMessage());
            }

            for(Order orderDetails: orders) {
                if(CANCELLED.getValues().contains(orderDetails.getOrderStatus())) continue;
                if(orderDetails.getOrderType().equalsIgnoreCase(MARKET_PLACE)) {
                    totalMpAmount = totalMpAmount.add(new BigDecimal(orderDetails.getAmount()));
                }
                totalOrderAmount = totalOrderAmount.add(new BigDecimal(orderDetails.getAmount()));
                if(offerIdList.contains(orderDetails.getOfferId())){
                    totalExclusionAmount = totalExclusionAmount.add(BigDecimal.valueOf(orderDetails.getAmount()));
                }
            }
            totalOrderAmount = totalOrderAmount.subtract(totalExclusionAmount);
            if(offerIdList.contains(order.getOfferId())){
                return response;
            }
            BigDecimal subtraction = totalOrderAmount.subtract(totalMpAmount);
            if(!order.getOrderType().equalsIgnoreCase(MARKET_PLACE)) {
                subtraction = subtraction.subtract(new BigDecimal(String.valueOf(cancelOrderAmount)));
            }

            // Stopped using this feature as of now
            //this.refreshLatLongCache(order);

            if(forceCancel && cartConfig.isPresent() && !ObjectUtils.isEmpty(mov)
                    && subtraction.compareTo(new BigDecimal(mov)) < 0){
                List<Order> ordersList = orderRepository.getActiveOrdersByCartId(cartId,nonCancellable);
                ordersList.forEach(o -> {
                    if(o.getOrderType().equalsIgnoreCase(ORD)){
                        OrderHistory orderHistory = new OrderHistory(o, source, o.getUserId());
                        o.setOrderStatus(CANCEL_STATUS);
                        o.setOrderSubStatus(CANCEL_BY_SYSTEM);
                        this.cancelOrderData(o, lang, true, orderHistory, cartId, pinCode, false, false, isInternalServiceCall);
                    }
                });
                response.put(CART_CONTAINS_ORD, true);
                return response;
            }else if(forceCancel && !cartConfig.isPresent()){
                List<Order> ordersList = orderRepository.getActiveOrdersByCartId(cartId,nonCancellable);
                // cancel ord if no config found
                ordersList.forEach(o -> {
                    if(o.getOrderType().equalsIgnoreCase(ORD)){
                        OrderHistory orderHistory = new OrderHistory(o, source, o.getUserId());
                        o.setOrderStatus(CANCEL_STATUS);
                        o.setOrderSubStatus(CANCEL_BY_SYSTEM);
                        this.cancelOrderData(o, lang, true,orderHistory, cartId, pinCode, false, false,isInternalServiceCall);
                    }
                });
                return response;
            }
        }
        return response;
    }

    private void refreshLatLongCache(Order order){
        List<Long> addressIdList = new ArrayList<>();
        addressIdList.add(order.getUserAddressId());
        try {
            latLongService.removeAddressIdCacheFromLaLongCache(order.getUserId(), addressIdList);
        } catch (Exception e){
            log.error("Exception occurred while deleting latLong cache with exception = {}",e.toString());
        }
    }

    private Boolean shouldNotShowDeliveryFeePopup(Order order){
//        if(!ObjectUtils.isEmpty(order.getDiscountType()) && (order.getDiscountType().equalsIgnoreCase(FIRST_ORDER_DISCOUNT) ||
//                order.getDiscountType().equalsIgnoreCase(PRICE_CHOP_DISCOUNT))) return true;
        return false;
    }

    @Transactional(rollbackFor = Exception.class)
    public void discardOrder(Order order, Long cartId, boolean cloneCart) {
        OrderHistory orderHistory = new OrderHistory(order, "cart-clone-initiated", order.getUserId());
        orderHistoryRepository.save(orderHistory);
        orderHistory = new OrderHistory(order, "discard-cart-clone", order.getUserId());
        order.setOrderStatus("cancel");
        Optional<UserAddress> userAddress = userAddressesRepository.findById(order.getUserAddressId());
        if (userAddress.isPresent()) {
            try {
                cancelOrderData(order, "en", true, orderHistory, cartId, userAddress.get().getPinCode(), false, cloneCart, false);
            } catch (Exception ex) {
                log.error("Exception occurred while discarding order {} with ex {}", order, ex.getMessage());
            }
        } else{
            throw new ValidationException("pinCode not found in the user address entity "+ order.getUserAddressId().toString());
        }

        order.setOrderStatus("discarded");
        order.setPaymentStatus("PAYMENT_FAILED");
        orderRepository.save(order);

    }

    @Transactional
    public void cancelOrderData(Order orderData, String lang, Boolean updateMOV, OrderHistory orderLog, Long cartId,
                                String pinCode, Boolean cartLevelDeliveryFee, boolean cloneCart, Boolean isInternalServiceCall) {
        Optional<ProductOffer> productOffer = productOfferRepository.findFirstByOfferIdOrderByDealIdDesc(orderData.getOfferId());
        Optional<UsersAddressEntity> userAddressEntity = usersAddressRepository.findById(orderData.getUserAddressId());
        List<Order> ordCancelledDeals = new ArrayList<>();
        try {
            List<StaticPropertiesModel> schemeProperties = staticDataClient.getStaticPropertiesModels(SCRATCH_CARD);
            Map<String, StaticPropertiesModel> scratchCardPropertiesMap = schemeProperties.stream().collect(Collectors.toMap(StaticPropertiesModel::getPropertyName, Function.identity()));
            String type = "credited";
            long scratchCardPlanId = Long.parseLong(scratchCardPropertiesMap.get(PLAN_ID).getPropertyValue());
            Optional<CustomerPoints> getRedeemData = customerPointsRepository.findFirstByUserIdAndIncentivePlanIdAndTypeAndCartIdAndStatus(orderData.getUserId(), scratchCardPlanId, type, cartId,1L);

            Integer palId = null;
            if(userAddressEntity.isPresent()){
                palId=userAddressEntity.get().getPalId();
            }
            etaService.cancelEtaUpdate(cartId, orderData.getId(),orderData.getOrderStatus(), orderData.getUserAddressId(),palId);

            // function to call revert discount to discount-service
            try {
                revertWallet(orderData, cartId);
            } catch (Exception e) {
                pointsService.creditWallet(orderData.getUserId(), null, orderData.getId(), new ArrayList<>(), new HashMap<>());
                log.error("Failure in revert wallet order {} cart {} message {}",
                        orderData, cartId, e.getMessage(), e);
            }
            ordCancelledDeals = revertDiscount(orderData, cartId, cloneCart);
            orderRepository.save(orderData);
            orderHistoryRepository.save(orderLog);
            inventoryService.removeInventory(orderData.getId(), orderData.getQuantity(), productOffer.get().getDealId(), orderData.getOfferId(), orderData.getUserId());

        } catch (Exception e) {
            log.error("cancelOrderData - exception {} orderId {}", e.getMessage(), orderData.getId());
            throw new ValidationException("Something went wrong , please try again!!");
        }

        if (updateMOV) {
            if(userAddressEntity.isPresent()) {
                pinCode = userAddressEntity.get().getPincode();
            }
            List<PostOrderInfoModel> postOrderInfoModelList = new ArrayList<>();
            if(orderData.getBilledAmount() == null){
                log.error("MyOrderServiceImpl cancelOrderData -> orderData : {}", orderData);
                orderData.setBilledAmount(0.0);
            }
            postOrderInfoModelList.add(PostOrderInfoModel.builder().amount(orderData.getAmount().longValue())
                    .billedAmount(orderData.getBilledAmount().longValue())
                    .offerId(orderData.getOfferId())
                    .dealType(AppConstant.DEAL_TYPE_NORMAL)
                    .isFeaturedDeal(false)
                    .orderId(orderData.getId())
                    .sold(orderData.getQuantity().intValue())
                    .dealPromotionBifurcationList(new ArrayList<>())
                    .offerPkId(productOffer.get().getDealId()).build());

            try {
                PostOrderUpdateModel postOrderUpdateModel = PostOrderUpdateModel.builder()
                        .userId(orderData.getUserId())
                        .userType(null)
                        .pinCode(pinCode)
                        .dealRequestModels(postOrderInfoModelList)
                        .isCancelRequest(true)
                        .userAddressId(orderData.getUserAddressId())
                        .phoneNumber(orderData.getPhone())
                        .isUserAddressVerified(userAddressEntity.get().getVerifiedAddress())
                        .cartId(cartId)
                        .orderDate(orderData.getOrderDate())
                        .cartLevelDeliveryFee(cartLevelDeliveryFee)
                        .build();
                orderServiceClient.postOrderUpdate(postOrderUpdateModel);
            } catch (Exception e) {
                log.error("Post order api update response for userId: {}, orderId: {} and exception: {} ",
                        orderData.getUserId(), orderData.getId(), e.getMessage());
            }
        }
        ordCancelledDeals.add(orderData);
        triggerOrderCancelEvent(ordCancelledDeals,cartId,isInternalServiceCall,cloneCart);
    }

    @Transactional
    public void cancelOrderDataBulk(List<CancelOrderDataRequestModel> cancelOrderDataRequestModelList, Boolean cartLevelDeliveryFee){
        Optional<UsersAddressEntity> userAddressEntity = usersAddressRepository.findById(cancelOrderDataRequestModelList.get(0).getOrderData().getUserAddressId());
        Map<Long,ProductOffer> productOfferMap = new HashMap<>();
        List<Order> orderList = new ArrayList<>();
        List<OrderHistory> orderHistoryList = new ArrayList<>();
        Long cartId = null;
        Long userId = null;
        for(CancelOrderDataRequestModel cancelOrderDataRequestModel : cancelOrderDataRequestModelList) {
            try {
                Order orderData = cancelOrderDataRequestModel.getOrderData();
                cartId = cancelOrderDataRequestModel.getCartId();
                userId = orderData.getUserId();
                Optional<ProductOffer> productOffer = productOfferRepository.findFirstByOfferIdOrderByDealIdDesc(cancelOrderDataRequestModel.getOrderData().getOfferId());
                productOffer.ifPresent(offer -> productOfferMap.put(orderData.getId(), offer));
                Integer palId = userAddressEntity.map(UsersAddressEntity::getPalId).orElse(null);
                etaService.cancelEtaUpdate(cartId, orderData.getId(),orderData.getOrderStatus(), orderData.getUserAddressId(),palId);
                processScratchCard(orderData, cartId);
                orderList.add(orderData);
                orderHistoryList.add(cancelOrderDataRequestModel.getOrderHistory());
            }catch (Exception e){
                log.error(e.getMessage());
                throw new ValidationException("Something went wrong , please try again!!");
            }
        };

        try {
            revertDiscountBulk(orderList,cartId, userId);
            orderRepository.saveAll(orderList);
            orderHistoryRepository.saveAll(orderHistoryList);
            orderList.forEach(order -> {
                inventoryService.removeInventory(order.getId(), order.getQuantity(), productOfferMap.get(order.getId()).getDealId(), order.getOfferId(), order.getUserId());
            });
        }catch (Exception e){
            log.error(e.getMessage());
            throw new ValidationException("Something went wrong , please try again!!");
        }
        cancelOrderDataRequestModelList.forEach(cancelOrderDataRequestModel -> {
                    if (cancelOrderDataRequestModel.getUpdateMov()) {
                        Order orderData = cancelOrderDataRequestModel.getOrderData();
                        ProductOffer productOffer = productOfferMap.get(orderData.getId());
                        String pinCode = userAddressEntity.map(UsersAddressEntity::getPincode).orElse(null);
                        List<PostOrderInfoModel> postOrderInfoModelList = getPostOrderInfoModel(orderData, productOffer);
                        try {
                            PostOrderUpdateModel postOrderUpdateModel = PostOrderUpdateModel.builder()
                                    .userId(orderData.getUserId())
                                    .userType(null)
                                    .pinCode(pinCode)
                                    .dealRequestModels(postOrderInfoModelList)
                                    .isCancelRequest(true)
                                    .userAddressId(orderData.getUserAddressId())
                                    .phoneNumber(orderData.getPhone())
                                    .isUserAddressVerified(userAddressEntity.get().getVerifiedAddress())
                                    .cartId(cancelOrderDataRequestModel.getCartId())
                                    .orderDate(orderData.getOrderDate())
                                    .cartLevelDeliveryFee(cartLevelDeliveryFee)
                                    .build();
                            orderServiceClient.postOrderUpdate(postOrderUpdateModel);
                        } catch (Exception e) {
                            log.error("Post order api update response for userId: {}, orderId: {} and exception: {} ",
                                    orderData.getUserId(), orderData.getId(), e.getMessage());
                        }
                    }
        });
        List<Order> orderDataList = cancelOrderDataRequestModelList.stream().map(CancelOrderDataRequestModel::getOrderData).collect(Collectors.toList());
        triggerOrderCancelEventBulk(orderDataList);
    }

    private void triggerOrderCancelEventBulk(List<Order> orderDataList) {
        List<Long> orderIds = orderDataList.stream().map(Order::getId).collect(Collectors.toList());
        OrdersStatusUpdateEvent ordersStatusUpdateEvent = new OrdersStatusUpdateEvent();
        ordersStatusUpdateEvent.setOrderIds(orderIds);
        if(!orderIds.isEmpty()) {
            String event = orderDataList.get(0).getPaymentType().equalsIgnoreCase(PAYMENT_TYPE_PAYTM) ?
                    APP_CANCEL_ONLINE : APP_CANCEL_COD;
            ordersStatusUpdateEvent.setEvent(event);
            queueProducer.sendOrdersStatusUpdateTopic(ordersStatusUpdateEvent);
        }
    }

    @NotNull
    private static List<PostOrderInfoModel> getPostOrderInfoModel(Order orderData, ProductOffer productOffer) {
        List<PostOrderInfoModel> postOrderInfoModelList = new ArrayList<>();
        if (orderData.getBilledAmount() == null) {
            log.error("MyOrderServiceImpl cancelOrderData -> orderData : {}", orderData);
            orderData.setBilledAmount(0.0);
        }
        postOrderInfoModelList.add(PostOrderInfoModel.builder().amount(orderData.getAmount().longValue())
                .billedAmount(orderData.getBilledAmount().longValue())
                .offerId(orderData.getOfferId())
                .dealType(AppConstant.DEAL_TYPE_NORMAL)
                .isFeaturedDeal(false)
                .orderId(orderData.getId())
                .sold(orderData.getQuantity().intValue())
                .dealPromotionBifurcationList(new ArrayList<>())
                .offerPkId(productOffer.getDealId()).build());
        return postOrderInfoModelList;
    }

    private void processScratchCard(Order orderData, Long cartId) {
        List<StaticPropertiesModel> schemeProperties = staticDataClient.getStaticPropertiesModels(SCRATCH_CARD);
        Map<String, StaticPropertiesModel> scratchCardPropertiesMap = schemeProperties.stream().collect(Collectors.toMap(StaticPropertiesModel::getPropertyName, Function.identity()));
        String type = "credited";
        long scratchCardPlanId = Long.parseLong(scratchCardPropertiesMap.get(PLAN_ID).getPropertyValue());
        Optional<CustomerPoints> getRedeemData = customerPointsRepository.findFirstByUserIdAndIncentivePlanIdAndTypeAndCartIdAndStatus(orderData.getUserId(), scratchCardPlanId, type, cartId,1L);
        try {
            if (getRedeemData.isPresent()){
                CustomerPoints scratchCardAwardedData = getRedeemData.get();
                if(scratchCardAwardedData.getPointUse()!=0f){
                    scratchCardModifications(orderData, getRedeemData.get(), scratchCardPropertiesMap);
                }
                cancelScratchCard(scratchCardAwardedData,SCRATCH_CARD_CANCELLED);
            }
            else{
                Optional<CustomerPoints> usedCustomerPoints = customerPointsRepository.findFirstByUserIdAndIncentivePlanIdAndTypeAndOrderId(orderData.getUserId(), scratchCardPlanId, "debited", orderData.getId());
                if(usedCustomerPoints.isPresent()){
                    Optional<CustomerPoints> originalScratchCardCredited = customerPointsRepository.findById(Long.valueOf(usedCustomerPoints.get().getRemarks()));
                    originalScratchCardCredited.ifPresent(points -> cancelScratchCard(points, SCRATCH_CARD_USED));
                }
            }
            List<Long> excludedIncentivePlanIds = new ArrayList<>();
            excludedIncentivePlanIds.add(scratchCardPlanId);
            pointsService.creditWallet(orderData.getUserId(), null, orderData.getId(), excludedIncentivePlanIds, new HashMap<>());
        }catch(Exception e){
            log.error("Scratch card and points not credited back");
        }
    }

    private void triggerOrderCancelEvent(List<Order> order,Long cartId, Boolean isInternalServiceCall, Boolean cloneCart) {
        if(Objects.isNull(order) || order.isEmpty()) return;

        // no need to raise events for internal service calls and clone cart
        if(!cloneCart && !isInternalServiceCall){
            raiseThirdPartEvents(order, cartId);
        }
    }


    private void raiseThirdPartEvents(List<Order> order, Long cartId){
        if(order.isEmpty()){
            return;
        }
        ThirdPartyDataPushEventModel data = new ThirdPartyDataPushEventModel();
        data.setEventTime(ZonedDateTime.now(ZoneId.of("Asia/Kolkata")).toString());
        data.setEventType(AppsFlyerEventType.CART_CANCEL);
        data.setThirdPartyName(ThirdPartyName.APPSFLYER);
        ThirdPartyEventsParams params = new ThirdPartyEventsParams();
        params.setCartId(cartId.toString());

        List<OrderThirdPartyData> orderThirdPartyDataList = new ArrayList<>();
        for(Long orderId : order.stream().map(Order::getId).collect(Collectors.toList())){
            OrderThirdPartyData orderThirdPartyData = new OrderThirdPartyData();
            orderThirdPartyData.setOrderId(orderId);
            orderThirdPartyDataList.add(orderThirdPartyData);
        }
        params.setOrderIds(orderThirdPartyDataList);
        data.setThirdPartyEventsParams(params);
        data.setGetCartDetails(true);
        data.setGetThirdPartyIds(true);
        queueProducer.produceThirdPartySyncEvent(data);
        data.setThirdPartyName(ThirdPartyName.CLEVERTAP);
        data.setGetThirdPartyIds(false);
        queueProducer.produceThirdPartySyncEvent(data);
    }

    private void revertWalletOrderEntries( Order orderData, Integer planId,
                                          List<Order> orderList,
                                          List<OrderDiscountingHistory> orderDiscountingHistories) {

        Map<Long, Order> orderMap = orderList.stream()
                .collect(Collectors.toMap(Order::getId, order -> order,
                        (o1, o2) -> o1));
        for (OrderDiscountingHistory orderDiscountingHistory : orderDiscountingHistories) {
            if (orderDiscountingHistory.getDiscountPlanId().equals(planId)
                    && orderDiscountingHistory.getDiscountType().equals(WALLET_DISCOUNT_TYPE)
                    && !orderDiscountingHistory.getOrderId().equals(orderData.getId())) {
                if (orderMap.containsKey(orderDiscountingHistory.getOrderId())) {
                    Order order = orderMap.get(orderDiscountingHistory.getOrderId());
                    order.setAmount(order.getAmount() + orderDiscountingHistory.getDiscountAmount());
                    order.setDiscountAmount(order.getDiscountAmount() - orderDiscountingHistory.getDiscountAmount());
                }
                orderDiscountingHistory.setDiscountAmount(0);
                pointsService.creditWallet(orderData.getUserId(), planId.longValue(), orderDiscountingHistory.getOrderId(), new ArrayList<>(), new HashMap<>());
            }
        }
        orderDiscountingHistoryRepository.saveAll(orderDiscountingHistories);
        orderRepository.saveAll(orderList);
        orderRepository.flush();
        orderDiscountingHistoryRepository.flush();
    }

    private RevertWalletRequest createWalletRevertRequest(Order order, List<Order> orders,
                                           Map<Long, DealDetail> orderToDealMap) {
        UserInfo userInfo = new  UserInfo();
        LocationInfo locationInfo = new LocationInfo();
        userInfo.setUserId(order.getUserId());
        Optional<UsersAddressEntity> userAddressEntity = usersAddressRepository.findById(order.getUserAddressId());
        Optional<User> userOpt = userRepository.findById(order.getUserId());
        userOpt.ifPresent(user -> userInfo.setUserRank(user.getUserRank()));
        if (userAddressEntity.isPresent()) {
            ResponseEntity<?> palEntityModel = locationServiceV2Client.getPalById(userAddressEntity
                    .get().getPalId().longValue());
            if (palEntityModel.getStatusCode().is2xxSuccessful()) {
                Map<WarehouseType, List<Integer>> warehouseTypeListMap = new HashMap<>();
                PalEntityModel palEntity = objectMapper.convertValue(palEntityModel.getBody(),
                        PalEntityModel.class);
                List<ClusterWarehouses> clusterWarehouses = clusterWarehousesRepository
                        .findByWarehouseEntityId(palEntity.getWarehouseId());
                Optional<WarehouseEntity> warehouse = warehouseRepository.findById(palEntity.getWarehouseId());
                warehouseTypeListMap.put(WarehouseType.DEALSHARE,
                        Collections.singletonList(palEntity.getWarehouseId().intValue()));
                locationInfo.setCityId(palEntity.getCityId());
                warehouse.ifPresent(warehouseEntity ->
                        locationInfo.setStateId(Long.valueOf(warehouseEntity.getStateId())));
                locationInfo.setClusters(clusterWarehouses.stream()
                        .map(x -> x.getClusterId().intValue())
                        .collect(Collectors.toList()));
                locationInfo.setWarehouseTypeListMap(warehouseTypeListMap);
            }
        }
        RevertWalletRequest revertWalletRequest = new RevertWalletRequest();
        revertWalletRequest.setUserInfo(userInfo);
        revertWalletRequest.setLocationInfo(locationInfo);
        List<OrderInfo> orderInfos = new ArrayList<>();
        for (Order o: orders) {
            if (!o.getId().equals(order.getId()) && CANCELLED.getValues().contains(o.getOrderStatus())) {
                continue;
            }
            OrderInfo orderInfo = this.mapToOrderInfo(o, orderToDealMap.get(o.getId()));
            orderInfos.add(orderInfo);
        }
        revertWalletRequest.setOrderInfo(orderInfos);
        return revertWalletRequest;
    }

    public void revertWallet(Order orderData, Long cartId) {
        List<Order> orders = orderRepository.getOrdersByCartId(cartId);
        Map<Long, Order> orderMap = orders.stream().collect(Collectors.toMap(Order::getId,
                order -> order, (o1, o2) -> o1));
        List<Long> orderIds = orders.stream().map(Order::getId).collect(Collectors.toList());
        List<OrderDiscountingHistory> orderAllDiscounts = discountService.getAllOrderDiscount(orderIds);
        Map<Integer, Integer> cancelOrderPlanToDiscountMap = orderAllDiscounts.stream()
                .filter(x -> x.getOrderId().equals(orderData.getId()))
                .collect(Collectors.toMap(OrderDiscountingHistory::getDiscountPlanId,
                        OrderDiscountingHistory::getDiscountAmount, Integer::sum));
        List<OrderDiscountingHistory> filteredDiscountHistories = orderAllDiscounts.stream()
                .filter( x -> ((!CANCELLED.getValues()
                        .contains(orderMap.get(x.getOrderId()).getOrderStatus()))
                        ||  (x.getOrderId().equals(orderData.getId())))
                        && x.getDiscountType().equals(WALLET_DISCOUNT_TYPE))
                .collect(Collectors.toList());
        if (ObjectUtils.isEmpty(filteredDiscountHistories)) {
            pointsService.creditWallet(orderData.getUserId(), null, orderData.getId(), new ArrayList<>(), new HashMap<>());
            return;
        }
        Set<Integer> planIds = filteredDiscountHistories.stream()
                .map(OrderDiscountingHistory::getDiscountPlanId).collect(Collectors.toSet());
        Map<Long, DealDetail> orderToDealMap = getDealInformationMap(orders);
        RevertWalletRequest revertWalletRequest = createWalletRevertRequest(orderData,
                orders, orderToDealMap);
        RevertWalletResponse revertWalletResponse = schemeServiceClient.revertWalletCashback(revertWalletRequest);
        Map<Long, Long> orderRefundMap = new HashMap<>();
        Map<Long, Float> pointsUseMap = new HashMap<>();
        for (Integer planId: planIds) {
            if (Objects.nonNull(revertWalletResponse)
                    && revertWalletResponse.getMovBreachPlanIds().contains(planId)) {
                if(PAYMENT_TYPE_PAYTM.equals(orderData.getPaymentType())) {
                    adjustRefundAmountForWallet(orderData, planId, orders,
                            orderRefundMap, filteredDiscountHistories);
                }
                revertWalletOrderEntries(orderData, planId, orders, filteredDiscountHistories);
            } else {
                Map<Long, Integer> orderDifferenceMap = createOrderDifferenceMap(revertWalletResponse, planId);
                if (cancelOrderPlanToDiscountMap.containsKey(planId)
                        && cancelOrderPlanToDiscountMap.get(planId) > 0) {
                    reAdjustOrderAndCustomerPoints(orderDifferenceMap, orderMap, planId);
                    orderRefundMap = orderMap.entrySet().stream()
                            .collect(Collectors.toMap(
                                    Map.Entry::getKey,
                                    entry -> entry.getValue()
                                            .getAmount().longValue()
                            ));
                    if (orderDifferenceMap.containsKey(orderData.getId())) {
                        pointsUseMap.put(planId.longValue(), Math.abs(orderDifferenceMap.getOrDefault(orderData.getId(),
                                0).floatValue()));
                    }
                }
            }
        }
        pointsService.creditWallet(orderData.getUserId(), null, orderData.getId(),
                new ArrayList<>(), pointsUseMap);
        if (PAYMENT_TYPE_PAYTM.equals(orderData.getPaymentType()) && !ObjectUtils.isEmpty(orderRefundMap)) {
            sendBulkRefundUpdate(cartId, orderRefundMap);
        }
    }

    public void reAdjustOrderAndCustomerPoints(Map<Long, Integer> orderDifferenceMap,
                                               Map<Long, Order> orderMap, Integer planId) {

        for (Order order: orderMap.values()) {
            if (orderDifferenceMap.containsKey(order.getId())) {
                if (orderDifferenceMap.get(order.getId()) < 0) {
                    continue;
                }
                order.setAmount(Math.max(order.getAmount() - orderDifferenceMap.get(order.getId()), 0));
                order.setDiscountAmount(order.getDiscountAmount()
                        + orderDifferenceMap.get(order.getId()));
            }
        }
        List<OrderDiscountingHistory> histories = createOrderDiscountHistory(planId,
                orderDifferenceMap);
        List<DebitedIncentiveRequestModel> debitCustomerPoints =
                createDebitIncentiveModels(planId, orderDifferenceMap, orderMap);
        orderRepository.saveAll(orderMap.values());
        orderDiscountingHistoryRepository.saveAll(histories);
        pointsService.bulkDebitWallet(debitCustomerPoints);
    }


    public List<DebitedIncentiveRequestModel> createDebitIncentiveModels(Integer planId,
                                                                         Map<Long, Integer> orderDifferenceMap,
                                                                         Map<Long, Order> orderMap) {
        List<DebitedIncentiveRequestModel> debitedIncentiveModels = new ArrayList<>();
        for (Long orderId: orderDifferenceMap.keySet()) {
            if (orderDifferenceMap.get(orderId) > 0) {
                Order order = orderMap.get(orderId);
                DebitedIncentiveRequestModel requestModel = DebitedIncentiveRequestModel
                        .builder().orderId(orderId).userId(order.getUserId())
                        .incentivePlanId(planId == null ? null : planId.longValue())
                        .confirmIncentive(orderDifferenceMap.get(orderId).floatValue())
                        .build();
                debitedIncentiveModels.add(requestModel);
            }
        }
        return debitedIncentiveModels;
    }

    public List<OrderDiscountingHistory> createOrderDiscountHistory(Integer planId,
                                                                    Map<Long, Integer> orderDifferenceMap) {
        List<OrderDiscountingHistory> histories = new ArrayList<>();
        for (Long orderId: orderDifferenceMap.keySet()) {
            if (orderDifferenceMap.get(orderId) > 0) {
                OrderDiscountingHistory orderDiscountingHistory = new OrderDiscountingHistory();
                orderDiscountingHistory.setOrderId(orderId);
                orderDiscountingHistory.setDiscountType(WALLET_DISCOUNT_TYPE);
                orderDiscountingHistory.setDiscountAmount(orderDifferenceMap.get(orderId));
                orderDiscountingHistory.setDiscountPlanId(planId);
                histories.add(orderDiscountingHistory);
            }
        }
        return histories;
    }

    public Map<Long, Integer> createOrderDifferenceMap(RevertWalletResponse revertWalletResponse, Integer planId) {
        Map<Long, Integer> orderDifferenceMap = new HashMap<>();
        for (PlanOrderPointsDto planOrderPointsDto: revertWalletResponse.getPointsRedistribution()) {
            if (!planOrderPointsDto.getPlanId().equals(planId.longValue())) {
                continue;
            }
            orderDifferenceMap.putIfAbsent(planOrderPointsDto.getNewOrderId(), 0);
            orderDifferenceMap.putIfAbsent(planOrderPointsDto.getOldOrderId(), 0);
            orderDifferenceMap.put(planOrderPointsDto.getNewOrderId(),
                    orderDifferenceMap.get(planOrderPointsDto.getNewOrderId())
                            + planOrderPointsDto.getPoints());
            orderDifferenceMap.put(planOrderPointsDto.getOldOrderId(),
                    orderDifferenceMap.get(planOrderPointsDto.getOldOrderId())
                            - planOrderPointsDto.getPoints());
        }
        return orderDifferenceMap;
    }

    public void adjustRefundAmountForWallet(Order orderData,
                                            Integer planId,
                                            List<Order> orders,
                                            Map<Long, Long> orderRefundMap,
                                            List<OrderDiscountingHistory> orderDiscountingHistories) {


        long breachedCartDiscount = 0;
        Map<Long, Integer> discountHistoryMap = new HashMap<>();
        for (OrderDiscountingHistory orderDiscountingHistory : orderDiscountingHistories) {
            if (orderDiscountingHistory.getDiscountPlanId().equals(planId)
                    && orderDiscountingHistory.getDiscountType().equals(WALLET_DISCOUNT_TYPE)
                    && !orderDiscountingHistory.getOrderId().equals(orderData.getId())) {
                Long orderId = orderDiscountingHistory.getOrderId();
                discountHistoryMap.computeIfAbsent(orderId, x -> 0);
                discountHistoryMap.put(orderId, discountHistoryMap.get(orderId)
                        + orderDiscountingHistory.getDiscountAmount());
                breachedCartDiscount += orderDiscountingHistory.getDiscountAmount();
            }
        }
        long calculatedAmount = (long)(orderData.getAmount() - breachedCartDiscount );
        long refundAmount = Math.max( calculatedAmount ,0);
        orderRefundMap.put(orderData.getId(), refundAmount);

        double discountAmountToAdjust = orderData.getAmount() - refundAmount;
        if(discountAmountToAdjust>0) {
            for(Order order:orders) {
                if(discountAmountToAdjust > ZERO && !CANCELLED.getValues().contains(order.getOrderStatus())
                        && !orderData.getId().equals(order.getId())) {
                    double newRefundAmount = order.getAmount();
                    double discountToAdjustInOrder = Math.min(discountHistoryMap.getOrDefault(order.getId(), 0),
                            discountAmountToAdjust);
                    discountAmountToAdjust -= discountToAdjustInOrder;
                    newRefundAmount += discountToAdjustInOrder;
                    orderRefundMap.put(order.getId(), (long) newRefundAmount);
                }
            }
        }
    }

    private void sendBulkRefundUpdate(Long cartId, Map<Long, Long> orderToNewRefundAmountMap) {
        List<CartRefundUpdateRequest> cartRefundUpdateRequests = new ArrayList<>();
        List<OrderRefundUpdateRequest> orderRefundUpdateRequests = new ArrayList<>();
        for (Long orderId: orderToNewRefundAmountMap.keySet()) {
            orderRefundUpdateRequests.add(new OrderRefundUpdateRequest(orderId,
                    orderToNewRefundAmountMap.get(orderId)));
        }
        cartRefundUpdateRequests.add(new CartRefundUpdateRequest(cartId,orderRefundUpdateRequests));
        BulkRefundUpdateRequest bulkRefundUpdateRequest = new BulkRefundUpdateRequest(cartRefundUpdateRequests);
        try {
            paymentServiceClient.bulkRefundAmountUpdate(bulkRefundUpdateRequest);
        } catch (Exception ex){
            log.error("Error in updating refund amount for wallet {}", ex.getMessage(), ex);
        }
    }


    public List<Order>  revertDiscount(Order orderData, Long cartId, boolean cloneCart) {
        List<Order> orders = orderRepository.getOrdersByCartId(cartId);
        List<Long> orderIds = orders.stream().map(Order::getId).collect(Collectors.toList());
        List<OrderDiscountingHistory> orderAllDiscounts = discountService.getAllOrderDiscount(orderIds);

        Map<Long, DealDetail> orderToDealMap = getDealInformationMap(orders);
        RevertDiscountRequest revertDiscountRequest = new RevertDiscountRequest();
        revertDiscountRequest.setUserId(orderData.getUserId());
        revertDiscountRequest.setCancelledOrderIds(Arrays.asList(orderData.getId()));
        revertDiscountRequest.setOrderInfo(
            orders.stream().map(o -> this.mapToOrderInfo(o, orderToDealMap.get(o.getId())))
                    .collect(Collectors.toList()));
        revertDiscountRequest.setIsRestricted(false);
        revertDiscountRequest.setCartId(cartId);
        RevertDiscountResponse revertDiscountResponse = null;
        try {
            if(!notCheckRevertDiscountOrderIds.contains(orderData.getId())) {
                revertDiscountResponse = discountServiceClient.revertDiscountV2(revertDiscountRequest).getBody();
            }
        } catch (Exception e) {
            log.error("revertDiscount issue, discount request : {} and response: {} orderData: {}, exception : {}", revertDiscountRequest, revertDiscountResponse, orderData,e.getMessage(),e);
            String message = e.getMessage();
            boolean skipValidationError = message != null &&
                    message.contains("Found Credit transactions for the given request");
            if ( ! cloneCart && !skipValidationError ) {
                throw new ValidationException("problem while revert discount in discounting service for userId: " + orderData.getUserId() + " having orderId: " + orderData.getId() + " " + e.getMessage());
            }
        }

        if (Objects.nonNull(revertDiscountResponse) &&
            Objects.nonNull(revertDiscountResponse.getOrderPromotions()) &&
            !revertDiscountResponse.getOrderPromotions().isEmpty()) {

            if(PAYMENT_TYPE_PAYTM.equals(orderData.getPaymentType())) {
                List<CartRefundUpdateRequest> cartRefundUpdateRequests = new ArrayList<>();
                List<OrderRefundUpdateRequest> orderRefundUpdateRequests = new ArrayList<>();

                long breachedCartDiscount = revertDiscountResponse.getOrderPromotions().stream()
                    .flatMap(orderPromotion -> orderPromotion.getPlanDiscounts().stream())
                    .mapToLong(PlanDiscountData::getDiscountAmount)
                    .sum();
                Map<Long,Long> orderWiseDiscountRevert = revertDiscountResponse.getOrderPromotions().stream()
                    .collect(Collectors.toMap(OrderPromotion::getOrderId,
                        op -> op.getPlanDiscounts().stream().mapToLong(PlanDiscountData::getDiscountAmount).sum()
                        , (p1,p2) -> p1));

                long calculatedAmount = (long)(orderData.getAmount() - breachedCartDiscount );
                long refundAmount = Math.max( calculatedAmount ,0);
                orderRefundUpdateRequests.add(new OrderRefundUpdateRequest(orderData.getId(),refundAmount));

                double discountAmountToAdjust = orderData.getAmount() - refundAmount;

                if(discountAmountToAdjust>0) {
                    for(Order order:orders) {
                        if(discountAmountToAdjust > ZERO && !CANCELLED.getValues().contains(order.getOrderStatus())
                        && !orderData.getId().equals(order.getId())) {
                            double newRefundAmount = order.getAmount();
                            double discountToAdjustInOrder = Math.min(orderWiseDiscountRevert.getOrDefault(order.getId(), 0L),
                                discountAmountToAdjust);
                            discountAmountToAdjust -= discountToAdjustInOrder;
                            newRefundAmount += discountToAdjustInOrder;
                            orderRefundUpdateRequests.add(new OrderRefundUpdateRequest(order.getId(),(long)newRefundAmount));
                        }
                    }
                }
                cartRefundUpdateRequests.add(new CartRefundUpdateRequest(cartId,orderRefundUpdateRequests));
                BulkRefundUpdateRequest bulkRefundUpdateRequest = new BulkRefundUpdateRequest(cartRefundUpdateRequests);
                try {
                    paymentServiceClient.bulkRefundAmountUpdate(bulkRefundUpdateRequest);
                } catch (Exception ex){
                    log.error("Error in updating refund amount {}", ex.getMessage());
                }
            }

            return transactionServiceHelper.adjustDiscountAmount(revertDiscountResponse.getOrderPromotions(),
                orderData.getId(),
                orderAllDiscounts);
        }
        return new ArrayList<>();
    }

    public void revertDiscountBulk(List<Order> orderData, Long cartId,Long userId) {
        List<Order> orders = orderRepository.getOrdersByCartId(cartId);
        List<Long> orderDataIds = orderData.stream().map(Order::getId).collect(Collectors.toList());

        Map<Long, DealDetail> orderToDealMap = getDealInformationMap(orders);
        RevertDiscountRequest revertDiscountRequest = new RevertDiscountRequest();
        revertDiscountRequest.setUserId(userId);
        revertDiscountRequest.setCancelledOrderIds(orderDataIds);
        revertDiscountRequest.setOrderInfo(
                orders.stream().map(o -> this.mapToOrderInfo(o, orderToDealMap.get(o.getId())))
                        .collect(Collectors.toList()));
        revertDiscountRequest.setIsRestricted(false);
        revertDiscountRequest.setCartId(cartId);
        RevertDiscountResponse revertDiscountResponse;
        try {
            revertDiscountResponse = discountServiceClient.revertDiscountV2(revertDiscountRequest).getBody();
            try {
                log.error("revertDiscount discount request : {} and response: {} orderData: {}", objectMapper.writeValueAsString(revertDiscountRequest), objectMapper.writeValueAsString(revertDiscountResponse), objectMapper.writeValueAsString(orderData));
            } catch (Exception e) {

            }
        } catch (Exception e) {
            log.error("problem while revert discount in discounting service : {}", e.getMessage());
            throw new ValidationException(
                    "problem while revert discount in discounting service for userId: "
                            + userId + "having orderId: " + userId
                            + e.getMessage());
        }
    }

    private Map<Long, DealDetail> getDealInformationMap(List<Order> orders) {
        Map<String, Long> offerToOrderMap = orders.stream().collect(Collectors
                .toMap(Order::getOfferId, Order::getId, (o1, o2) -> o1));

        List<DownstreamService> downstreamServices = Arrays.asList(DownstreamService.DEAL_INDEX_SERVICE_VIEW,
                DownstreamService.ITEM_SERVICE_VIEW);
        DealDataRequestModel dealDataRequestModel = productAggregatorService
                .prepareDataForProductAggregator(new ArrayList<>(offerToOrderMap.keySet()),downstreamServices);
        DealDataResponseModel responseModel = productAggregatorService
                .getDealDataResponseModel(dealDataRequestModel);
        Map<Long, DealDetail> orderToDealDetailMap = new HashMap<>();
        for (ResponseDealData data: responseModel.getResponseDealDataList()) {
            if (Objects.nonNull(data)) {
                Long orderId = offerToOrderMap.get(data.getOfferId());
                DealDetail dealDetail = new DealDetail();
                dealDetail.setId(data.getId());
                dealDetail.setDealId(data.getOfferId());
                if (Objects.nonNull(data.getParentCategoryId())) {
                    dealDetail.setParentCategoryId(data.getParentCategoryId().intValue());
                }
                if (Objects.nonNull(data.getCategoryId())) {
                    dealDetail.setCategoryId(data.getCategoryId().intValue());
                }
                if (Objects.nonNull(data.getCategoryL3Id())) {
                    dealDetail.setL3CategoryId(data.getCategoryL3Id().intValue());
                }
                dealDetail.setBrand(data.getBrand());
                dealDetail.setSkus(new ArrayList<>());
                orderToDealDetailMap.put(orderId, dealDetail);
            }
        }
        return orderToDealDetailMap;
    }

    private void addToOrderHistoryModels(Order order, List<OrderHistory> orderHistoryList, String msg, Long cancelledOrderId) {
        OrderHistory orderHistory = new OrderHistory(order, String.format(msg, cancelledOrderId), 203L);
        orderHistoryList.add(orderHistory);
    }

    private void addToOrderAndOrderHistoryModels(OrderPromotion orderPromotion, Integer discountAmount,
                                                 List<Order> orderList, List<OrderHistory> orderHistoryList, Long cancelledOrderId) {
        Optional<Order> orderOptional = orderRepository.findById(orderPromotion.getOrderId());
        if (orderOptional.isPresent()) {
            Order order = orderOptional.get();
            addToOrderHistoryModels(order, orderHistoryList, AppConstant.BEFORE_DISCOUNT_REMOVAL,
                cancelledOrderId);
            order.setAmount(order.getAmount() + discountAmount);
            order.setDiscountAmount(order.getDiscountAmount() - discountAmount);
            if(orderPromotion.getCancelOrder()){
                order.setOrderStatus(CANCEL_STATUS);
            }
            orderList.add(order);
            addToOrderHistoryModels(order, orderHistoryList, AppConstant.AFTER_DISCOUNT_REMOVAL,
                cancelledOrderId);
        }
    }

    private void addToOrderDiscountingHistoryModels(OrderDiscountingHistory orderDiscount, List<OrderDiscountingHistory> orderDiscountingHistoryList) {
        orderDiscount.setDiscountAmount(0);
        orderDiscountingHistoryList.add(orderDiscount);
    }

    public void scratchCardModifications(Order orderData, CustomerPoints customerPoints, Map<String, StaticPropertiesModel> scratchCardPropertiesMap){
        long planId = Long.parseLong(scratchCardPropertiesMap.get(PLAN_ID).getPropertyValue());
        Long customerPointsId =  customerPoints.getId();

        List<CustomerPoints> customerPointsRedeemedList = customerPointsRepository
            .findByUserIdAndIncentivePlanIdAndTypeAndRemarks(orderData.getUserId(), planId,
                "debited", customerPointsId.toString());

        if(ObjectUtils.isEmpty(customerPointsRedeemedList)){
            return;
        }

        List<Long> orderIds = customerPointsRedeemedList.stream().map(CustomerPoints::getOrderId).collect(Collectors.toList());
        List<Order> orderList = orderRepository.findByIdIn(orderIds);

        Map<Long, Order> orderIdVsOrderMap = orderList.stream().collect(Collectors.toMap(Order::getId, Function.identity()));

        if (!ObjectUtils.isEmpty(customerPointsRedeemedList)) {
            for(CustomerPoints customerPointsData: customerPointsRedeemedList){
                if(!orderIdVsOrderMap.get(customerPointsData.getOrderId()).getPaymentType().equalsIgnoreCase(PAYMENT_TYPE_PAYTM))
                orderDao.updateOrderAmountAndCreateOrderHistory(orderIdVsOrderMap.get(customerPointsData.getOrderId()), customerPointsData.getPointUse(),SCRATCH_CARD_CANCELLED);
            }
        }
    }

    private CustomerPoints cancelScratchCard(CustomerPoints customerPoints,String reason) {
        ScratchCardCacheModel scratchCardCacheModel = null;
        try {
            //why do we use this caching for? -> to show the timer in home page
            Object cacheResponse=cacheService.get(CLEVERTAP + customerPoints.getUserId().toString(), false);
            if(!ObjectUtils.isEmpty(cacheResponse)){
                scratchCardCacheModel = objectMapper.readValue(cacheResponse.toString(), ScratchCardCacheModel.class);
            }
        } catch (IOException e) {
            log.error("Scratch card cancel failed with exception : {}",e.getMessage());
        }
        if (!ObjectUtils.isEmpty(scratchCardCacheModel)) {
            String scratchCardData = null;
            scratchCardCacheModel.setIsOrderPlaced(true);
            //scratchCardCacheModel.setExpirationTimeInMilli(AppUtil.getExpirationInMilli(String.valueOf(expirationTime)));
            try {
                scratchCardData = objectMapper.writeValueAsString(scratchCardCacheModel);
                cacheService.set(CLEVERTAP + customerPoints.getUserId().toString(), scratchCardData, AppUtil.getSecondsFromTheDates(AppUtil.dayEnd(new Date()).getTime()), false);
            } catch (JsonProcessingException e) {
                log.error("Scratch card cancel failed with exception : {}",e.getMessage());
            }
        }
        customerPoints.setPointUse(customerPoints.getPoints());
        customerPoints.setStatus(0L);
        customerPoints.setExpiryDate(customerPoints.getCreatedDate());
        customerPoints.setRemarks(reason);
        return customerPointsRepository.save(customerPoints);
    }

    private CustomerPoints createCustomerPointEntry(CustomerPoints oldEntry, int expirationTime) throws ParseException {
        CustomerPoints customersPointsEntity = new CustomerPoints();
        customersPointsEntity.setUserId(oldEntry.getUserId());
        customersPointsEntity.setPoints(oldEntry.getPoints());
        Date now = null;
        try {
            now = DateUtils.addMinutes(CommonUtils.getCurrentDateV2(), expirationTime);
            customersPointsEntity.setCreatedDate(CommonUtils.getCurrentDateV2());
        } catch (ParseException e) {
            throw e;
        }
        customersPointsEntity.setExpiryDate(now);
        customersPointsEntity.setOrderId(oldEntry.getOrderId());
        customersPointsEntity.setPointUse(0 - oldEntry.getPoints());
        customersPointsEntity.setStatus(CUSTOMER_POINTS_ACTIVE);
        customersPointsEntity.setPriority(oldEntry.getPriority());
        customersPointsEntity.setIncentivePlanId(oldEntry.getIncentivePlanId());
        customersPointsEntity.setRemarks("cancellation");
        String type = "debited";
        customersPointsEntity.setType(type);
        return customersPointsEntity;
    }

    private Map<String,Object> checkIfCartContainsOrdOrder(Order order, User user, Boolean forceCancel, Long cartId, Boolean isDiscard) throws JsonProcessingException, IOException {
        Map<String, Object> response = new HashMap<>();
        response.put(CART_CONTAINS_ORD, false);
        response.put(CART_CONTAINS_MRKTP_ORDER, false);
        ValidationExceptionV2 message = new ValidationExceptionV2();
//        Optional<CartOrderMapping> cartOrderMapping = cartOrderMappingRepository.findFirstByOrderId(order.getId());
//        if (!cartOrderMapping.isPresent()) return response;
        if(Objects.isNull(cartId)) return response;
        response.put(CART_ID, cartId);
        if (order.getOrderType().equalsIgnoreCase("ord")) return response;
        String userRank = user.getUserRank();
        Long cancelOrderAmount = order.getAmount().longValue();
        List<Order> orders = orderRepository.getOrdersByCartId(cartId);
        if (ObjectUtils.isEmpty(orders) || orders.size() == 0) return response;
        boolean cartHasMarketplaceOrder = orders.stream().anyMatch(x -> x.getOrderType().equalsIgnoreCase(MARKET_PLACE));
        response.put(CART_CONTAINS_MRKTP_ORDER, cartHasMarketplaceOrder);
        Map<String, String> ordCartStatus = sumIfOrdPresent(orders);
        Integer activeOrdCount = Integer.parseInt(ordCartStatus.get(ACTIVE_ORD_COUNT_IN_CART));
        BigDecimal totalAmount = new BigDecimal(ordCartStatus.get(ORD_CART_SUM));
        BigDecimal totalMpAmount = new BigDecimal("0");
        BigDecimal totalOrderAmount = new BigDecimal("0");
        BigDecimal totalExclusionAmount = new BigDecimal("0");
        List<OfferResponseModel> offerResponseModels = new ArrayList<>();

        if (totalAmount.signum() > 0) {
            Optional<Cart> cart = cartRepository.findById(cartId);
            Optional<CartConfig> cartConfig = null;
            if (cart.isPresent() && cart.get().getConfig()!=null) {
                Map<String, Long> configMap = objectMapper.readValue(cart.get().getConfig(), new TypeReference<Map<String, Long>>() {});
                Long configId = configMap.get(ONE_RUPEE_DEAL_VALUE) ;
                if(configId!=null){
                    cartConfig = cartConfigRepository.findById(configId);
                }
            }
            int ordCartDeliveryFee = 0;
            if(cart.isPresent()) {
                ordCartDeliveryFee = checkDeliveryFeeIfOrd(cart.get().getCartConfigId(), forceCancel, user, order);
            }
            if (cartConfig == null || !cartConfig.isPresent()) {
                cartConfig = Optional.ofNullable(cartConfigUtils.getCartConfigFromRedis("CART_CONFIG:" + userRank + ":CLUSTER:0:ONE_RUPEE_DEAL_VALUE:" + "B2C"));
            }
//            if (isDiscard && !cartConfig.isPresent()) {
//                cartConfig = Optional.ofNullable(cartConfigUtils.getCartConfigFromRedis("CART_CONFIG:" + "normal" + ":CLUSTER:0:ONE_RUPEE_DEAL_VALUE:" + "B2C"));
//            }
            response.put("cartConfig", cartConfig.get());
            Map<String, List<Long>> hashMap = objectMapper.readValue(cartConfig.get().getConfigMeta(), new TypeReference<LinkedHashMap<String, List<Long>>>(){});
            List<String> offerIdList = new LinkedList<>();
          if (!ObjectUtils.isEmpty(hashMap)) {
            List<Long> l2CategoryIdList = hashMap.get("L2_CATEGORY_IDS");
            List<Long> dealIdList = hashMap.get("DEAL_IDS");
            offerResponseModels.addAll(dealIndexServiceClientWrapper
                    .getOfferInfoByOfferIds(
                            CommonUtils.convertListOfStringToString(
                                    orders.stream().map(Order::getOfferId).collect(Collectors.toList()))));
            offerIdList =
                offerResponseModels
                    .stream()
                    .filter(
                        offer ->
                            l2CategoryIdList.contains(offer.getCategoryId())
                                || dealIdList.contains(offer.getId()))
                    .map(OfferResponseModel::getOfferId)
                    .collect(Collectors.toList());
                    }
            for (Order orderDetails : orders) {
                if (CANCELLED.getValues().contains(orderDetails.getOrderStatus())) continue;
                if (orderDetails.getOrderType().equalsIgnoreCase(MARKET_PLACE)) {
                    totalMpAmount = totalMpAmount.add(new BigDecimal(orderDetails.getAmount()));
                }
                totalOrderAmount = totalOrderAmount.add(new BigDecimal(orderDetails.getAmount()));
                if(offerIdList.contains(orderDetails.getOfferId())){
                    totalExclusionAmount = totalExclusionAmount.add(BigDecimal.valueOf(orderDetails.getAmount()));
                }
            }
            totalOrderAmount = totalOrderAmount.subtract(totalExclusionAmount);
            if(offerIdList.contains(order.getOfferId())){
                return response;
            }
            BigDecimal subtraction = totalOrderAmount.subtract(totalMpAmount);
            if (!order.getOrderType().equalsIgnoreCase(MARKET_PLACE)) {
                subtraction = subtraction.subtract(new BigDecimal(String.valueOf(cancelOrderAmount)));
            }
            if (!forceCancel && !order.getOrderType().equalsIgnoreCase(MARKET_PLACE)) {
                try {
                    Long mov = fetchMovForOrdCartCancellation(cartConfig.get(), activeOrdCount);
                    if (subtraction.compareTo(new BigDecimal(mov)) < 0) {
                        message.setMessage(messageSource.getMessage("less.than.mov.cancel.ord", null, LocaleContextHolder.getLocale()));
                        if(ordCartDeliveryFee > 0) {
                            message.setMessage(messageSource.getMessage("less.than.mov.cancel.ord.delivery.fee.applied", new Object[] {ordCartDeliveryFee}, LocaleContextHolder.getLocale()));
                        }
                        message.setInternalId(String.valueOf(order.getId()));
                        message.setOrdSchemeKey(true);
                        response.put(POPUP_MESSAGE_OBJECT, message);
                        response.put(OFFER_RESPONSE_MODEL, this.getOrdProductDetail(offerResponseModels.stream().filter(offerResponseModel ->
                                offerResponseModel.getOfferId().equalsIgnoreCase(ordCartStatus.get(ORD_OFFER_ID))).findAny()));
                        return response;
                    }
                } catch (Exception e) {
                    log.error("Order cancellation process ORD present --> config not found --> userId - " + order.getUserId());
                    message.setMessage(messageSource.getMessage("config.not.found.cancel.ord", null, LocaleContextHolder.getLocale()));
                    message.setInternalId(String.valueOf(order.getId()));
                    message.setOrdSchemeKey(true);
                    response.put(POPUP_MESSAGE_OBJECT, message);
                    return response;
                }
            }
        }
        return response;
    }

    private Object getOrdProductDetail(Optional<OfferResponseModel> offerResponseModelOpt) {
        if (offerResponseModelOpt.isPresent()) {
            OfferResponseModel offerResponseModel = offerResponseModelOpt.get();
            return OrdDetail.builder()
                    .title(offerResponseModel.getTitle())
                    .mrp(offerResponseModel.getMrp().intValue())
                    .image(offerResponseModel.getImage())
                    .price(1)
                    .build();
        }
        return null;
    }

    private int checkDeliveryFeeIfOrd(Long cartConfigId, Boolean updateDeliveryFee, User user, Order order) throws IOException {
        Long orderId = order.getId();
        Long userAddressId = order.getUserAddressId();
        CartConfig cartConfig = cartConfigUtils.getCartConfigFromRedis("CART_CONFIG_ID:"+cartConfigId);
        if(ObjectUtils.isEmpty(cartConfig))
            cartConfig = cartConfigUtils.getCartConfigFromRedis("CART_CONFIG:" + "ALL" + ":CLUSTER:1:MINIMUM_BAG_VALUE:" + "B2C");
        if (Optional.ofNullable(cartConfig).isPresent()) {
            Map<String, String> cartMetaInfo = objectMapper.readValue(cartConfig.getConfigMeta(), Map.class);
            int deliveryFee = 0;
            int minimumOrderValueForDeliveryFee = 0;
            if (!ObjectUtils.isEmpty(cartMetaInfo)) {
                deliveryFee = Integer.parseInt(cartMetaInfo.get("delivery_fee"));
                minimumOrderValueForDeliveryFee = cartConfig.getAmount().intValue();
            }
            if (minimumOrderValueForDeliveryFee > 0 && deliveryFee > 0) {
                List<Long> cancelRequestOrders = new ArrayList<>();
                cancelRequestOrders.add(orderId);
                GetMovV2RequestBody getMovV2RequestBody = new GetMovV2RequestBody();
                getMovV2RequestBody.setUserAddressId(userAddressId);
                Optional<Map<String, Object>> resultData = getCartForDeliveryFee(user, order.getOrderDate(), cancelRequestOrders, minimumOrderValueForDeliveryFee,getMovV2RequestBody);
                if (resultData.isPresent() && !ObjectUtils.isEmpty(resultData.get())) {
                    if (updateDeliveryFee && resultData.isPresent() && resultData.get() != null) {
                        Object maxCartIdObj = resultData.get().get("maxCartId");
                        if (maxCartIdObj != null) {
                            Long cartId = Long.valueOf(maxCartIdObj.toString());
                            cartService.updateDeliveryFeeByCartId(cartId, deliveryFee);
                        }
                    }
                    return deliveryFee;
                }
            }
        }
        return 0;
    }

    private Long fetchMovForOrdCartCancellation(CartConfig cartConfig, Integer activeOrdCount) {
        Long mov = null;
        try {
            Map<String, String> movResponse = cartConfigService.fetchOrdCartMov(activeOrdCount, cartConfig);
            mov = Long.parseLong(movResponse.get(CONFIGURED_ORD_MOV));
        } catch (Exception e) {
            log.error("Error computing ord config, choose the fallback : {}", e.getMessage());
        }
        if (ObjectUtils.isEmpty(mov) && !ObjectUtils.isEmpty(cartConfig))  mov = cartConfig.getAmount();
        return mov;
    }

    public Map<String, Object> checkDeliveryFee(Order order, User user, OrderCancelModel orderCancelModel, Long orderCartId) throws IOException {
        Map<String, Object> response = new HashMap<>();
        response.put(DELIVERY_FEES_APPLICABLE_CHECK, false);
        ValidationExceptionV2 message = new ValidationExceptionV2();

        Optional<Cart> cartDetails = cartRepository.findById(orderCartId);
        Long cartConfigId = null;

        if (cartDetails.isPresent()) {
            cartConfigId = cartDetails.get().getCartConfigId();
        } else {
            log.error("Cart not found. orderCartId={}, orderId={}, userId={}", orderCartId, order.getId(), user != null ? user.getId() : "null");
        }

        CartConfig cartConfig = cartConfigUtils.getCartConfigFromRedis("CART_CONFIG_ID:" + cartConfigId);
        if (ObjectUtils.isEmpty(cartConfig)) {
            log.error("CartConfig missing for key=CART_CONFIG_ID:{}, fallback used. orderId={}, userId={}, cartId={}", cartConfigId, order.getId(), user != null ? user.getId() : "null", orderCartId);
            cartConfig = cartConfigUtils.getCartConfigFromRedis("CART_CONFIG:ALL:CLUSTER:0:MINIMUM_BAG_VALUE:B2C");
            if (ObjectUtils.isEmpty(cartConfig)) {
                log.error("Fallback CartConfig also missing. orderId={}, userId={}, cartId={}", order.getId(), user != null ? user.getId() : "null", orderCartId);
            }
        }

        Boolean cartLevelDeliveryFee = cartLevelDeliveryFeeService.checkIfConfigIsCartLevel(cartConfig);
        Boolean deliveryFeeCentralisationFlow = cartLevelDeliveryFeeService.checkIfConfigIsCentralisedDeliveryFee(cartConfig);

        log.error("Cart delivery fee check: orderId={}, userId={}, cartId={}, cartLevelDeliveryFee={}, deliveryFeeCentralisationFlow={}",
                order.getId(), user != null ? user.getId() : "null", orderCartId, cartLevelDeliveryFee, deliveryFeeCentralisationFlow);

        response.put("CART_LEVEL_DELIVERY_FEE", cartLevelDeliveryFee);
        response.put("DELIVERY_FEE_CENTRALISATION_FLOW", deliveryFeeCentralisationFlow);

        // Centralised fee flow
        if (deliveryFeeCentralisationFlow) {
            log.error("Centralised delivery fee flow triggered. orderId={}, cartId={}", order.getId(), orderCartId);
            ComputeCartFeesResponse computeCartFeesResponse = getComputeCartFeesRequest(order, orderCancelModel, orderCartId);
            response.putAll(getDeliveryFeeInfo(computeCartFeesResponse, orderCancelModel));
            return response;
        }

        // Cart level flow
        if (cartLevelDeliveryFee) {
            if (cartDetails.isPresent() && cartDetails.get().getDeliveryFee() != 0) {
                log.error("Cart already has delivery fee applied. Skipping. orderId={}, userId={}, cartId={}, existingFee={}", order.getId(), user != null ? user.getId() : "null", cartDetails.get().getId(), cartDetails.get().getDeliveryFee());
                return response;
            }
        }

        Map<String, String> cartMetaInfo = new HashMap<>();
        try {
            cartMetaInfo = objectMapper.readValue(cartConfig.getConfigMeta(), new TypeReference<Map<String, String>>() {});
        } catch (Exception e) {
            log.error("Failed to parse cart meta. cartConfigId={}, configMeta={}, orderId={}, userId={}, cartId={}, exception={}",
                    cartConfigId, cartConfig.getConfigMeta(), order.getId(), user != null ? user.getId() : "null", orderCartId, e.toString());
        }

        int deliveryFee = 0;
        int minimumOrderValueForDeliveryFee = 0;

        if (!ObjectUtils.isEmpty(cartMetaInfo)) {
            deliveryFee = Integer.parseInt(cartMetaInfo.getOrDefault("delivery_fee", "0"));
            response.put("delivery_fee", deliveryFee);
            minimumOrderValueForDeliveryFee = cartConfig.getAmount().intValue();
            log.error("Parsed delivery fee and MOV: orderId={}, userId={}, cartId={}, deliveryFee={}, minOrderValue={}",
                    order.getId(), user != null ? user.getId() : "null", orderCartId, deliveryFee, minimumOrderValueForDeliveryFee);
        }

        if (minimumOrderValueForDeliveryFee > 0 && deliveryFee > 0) {
            if (cartLevelDeliveryFee) {
                List<Order> orders = orderRepository.findAllOrdersByCartId(cartDetails.get().getId());
                boolean feeApplicable = cartLevelDeliveryFeeService.checkRemainingMov(orders, order.getId(), cartConfig.getAmount().doubleValue());
                log.error("Cart level delivery fee MOV check: orderId={}, userId={}, cartId={}, feeApplicable={}, deliveryFeeKey={}",
                        order.getId(), user != null ? user.getId() : "null", cartDetails.get().getId(), feeApplicable, orderCancelModel.getDeliveryFeeKey());

                if (feeApplicable) {
                    if (orderCancelModel.getDeliveryFeeKey()) {
                        cartService.updateDeliveryFeeByCartId(cartDetails.get().getId(), deliveryFee);
                        log.error("Delivery fee updated. orderId={}, userId={}, cartId={}, fee={}", order.getId(), user != null ? user.getId() : "null", cartDetails.get().getId(), deliveryFee);
                    } else {
                        log.error("Showing fee popup. orderId={}, userId={}, cartId={}, fee={}", order.getId(), user != null ? user.getId() : "null", cartDetails.get().getId(), deliveryFee);
                        message.setMessage(messageSource.getMessage("delivery.fee.may.apply", new Object[]{deliveryFee}, LocaleContextHolder.getLocale()));
                        message.setTitle(messageSource.getMessage("delivery.fee.may.apply.title", null, LocaleContextHolder.getLocale()));
                        message.setMessageFooter(messageSource.getMessage("delivery.fee.may.apply.footer", null, LocaleContextHolder.getLocale()));
                        message.setInternalId(String.valueOf(order.getId()));
                        message.setDeliveryFeeKey(true);
                        message.setScratchCardKey(orderCancelModel.getScratchCardKey());
                        response.put(POPUP_MESSAGE_OBJECT, message);
                        return response;
                    }
                }
                return response;
            }

            // Fallback (non-cart-level) flow
            List<Long> cancelRequestOrders = Collections.singletonList(order.getId());
            Long addressId = order.getUserAddressId();
            GetMovV2RequestBody getMovV2RequestBody = new GetMovV2RequestBody();
            getMovV2RequestBody.setUserAddressId(addressId);
            Optional<Map<String, Object>> resultData = getCartForDeliveryFee(user, order.getOrderDate(), cancelRequestOrders, minimumOrderValueForDeliveryFee,getMovV2RequestBody);

            if (resultData.isPresent() && !ObjectUtils.isEmpty(resultData.get())) {
                if (orderCancelModel.getDeliveryFeeKey()) {
                    Object maxCartIdObj = resultData.get().get("maxCartId");
                    Long cartId = null;
                    if (maxCartIdObj != null) {
                        cartId = Long.valueOf(maxCartIdObj.toString());
                        cartService.updateDeliveryFeeByCartId(cartId, deliveryFee);
                    } else {
                        log.error("Max cart ID not found in result data. orderId={}, userId={}, cartId={}, deliveryFee={}",
                                order.getId(), user != null ? user.getId() : "null", orderCartId, deliveryFee);
                    }
                    log.error("Non-cart-level: Delivery fee updated. orderId={}, userId={}, cartId={}, fee={}", order.getId(), user.getId(), cartId, deliveryFee);
                } else {
                    log.error("Non-cart-level: Showing fee popup. orderId={}, userId={}, fee={}", order.getId(), user.getId(), deliveryFee);
                    message.setMessage(messageSource.getMessage("delivery.fee.may.apply", new Object[]{deliveryFee}, LocaleContextHolder.getLocale()));
                    message.setTitle(messageSource.getMessage("delivery.fee.may.apply.title", null, LocaleContextHolder.getLocale()));
                    message.setMessageFooter(messageSource.getMessage("delivery.fee.may.apply.footer", null, LocaleContextHolder.getLocale()));
                    message.setInternalId(String.valueOf(order.getId()));
                    message.setDeliveryFeeKey(true);
                    message.setScratchCardKey(orderCancelModel.getScratchCardKey());
                    response.put(POPUP_MESSAGE_OBJECT, message);
                    return response;
                }
            } else {
                log.error("No cart found for fee application. orderId={}, userId={}, minOrderValue={}, deliveryFee={}",
                        order.getId(), user.getId(), minimumOrderValueForDeliveryFee, deliveryFee);
            }
        }

        return response;
    }



    public Map<String, Object> checkIfScratchCardRedeemed(Order order, Long cartId){
        Map<String, Object> response = new HashMap<>();
        response.put(ORDER_CONTAINS_REDEEMED_SCRATCH_CARD, false);
        ValidationExceptionV2 message = new ValidationExceptionV2();
        List<StaticPropertiesModel> schemeProperties =
            staticDataClient.getStaticPropertiesModels(SCRATCH_CARD);
        Map<String, StaticPropertiesModel> scratchCardPropertiesMap = schemeProperties.stream()
            .collect(
                Collectors.toMap(StaticPropertiesModel::getPropertyName, Function.identity()));
        long scratchCardPlanId =
            Long.parseLong(scratchCardPropertiesMap.get(PLAN_ID).getPropertyValue());
        if (ObjectUtils.isEmpty(scratchCardPlanId)) {
            return response;
        }
//        Optional<CartOrderMapping> com = cartOrderMappingRepository.findFirstByOrderId(orderCancelModel.getOrderId());
//        if(!com.isPresent()){
//            return response;
//        }
//        Long cartId = com.get().getCartId();
        String type = "credited";
        Optional<CustomerPoints> getRedeemData =
            customerPointsRepository.findFirstByUserIdAndIncentivePlanIdAndTypeAndCartIdAndStatus(order.getUserId(),
                scratchCardPlanId, type, cartId,1L);
        if (getRedeemData.isPresent()) {
            CustomerPoints scratchCardAwardedData = getRedeemData.get();
            List<CustomerPoints> customerPointsRedeemedList = customerPointsRepository
                .findByUserIdAndIncentivePlanIdAndTypeAndRemarks(order.getUserId(), scratchCardPlanId,
                    "debited", scratchCardAwardedData.getId().toString());
            int pointsUsed = 0;
            for(CustomerPoints customerPoints: customerPointsRedeemedList){
                pointsUsed = (int) (pointsUsed +   customerPoints.getPointUse());
            }
            if(scratchCardAwardedData.getPointUse()<=0){
                return response;
            }
            int scratchCardAmountUsed =
                 (scratchCardAwardedData.getPointUse().intValue());
            message.setMessage(messageSource
                .getMessage("scratch.card.revert", new Object[] {scratchCardAmountUsed},
                    LocaleContextHolder.getLocale()));
            message.setTitle(messageSource
                .getMessage("scratch.card.revert.title", null,
                    LocaleContextHolder.getLocale()));
            message.setMessageFooter(messageSource
                .getMessage("delivery.fee.may.apply.footer", null,
                    LocaleContextHolder.getLocale()));
            message.setInternalId(String.valueOf(order.getId()));
            message.setScratchCardKey(true);
            response.put(POPUP_MESSAGE_OBJECT, message);
            response.put(ORDER_CONTAINS_REDEEMED_SCRATCH_CARD, true);
            return response;
        }

    return response;
}

    private Map<String, String> sumIfOrdPresent(List<Order> orders) {
        Boolean ordPresent = false;
        BigDecimal sum = new BigDecimal("0");
        Map<String, String> response = new HashMap<>();
        Long count = 0L;
        for (Order order : orders) {
            if (CANCELLED.getValues().contains(order.getOrderStatus())) continue;
            if (order.getOrderType().equalsIgnoreCase(ORD)) {
                ordPresent = true;
                response.put(ORD_OFFER_ID, order.getOfferId());
                count += order.getQuantity();
            }
            sum = sum.add(new BigDecimal(order.getAmount()));
        }
        response.put(ACTIVE_ORD_COUNT_IN_CART, String.valueOf(count));
        response.put(ORD_CART_SUM, ordPresent ? String.valueOf(sum) : "0");
        return response;
    }

    public OrderDetailModel getOrderDetail(Long Id, String lang) throws Exception {
        Optional<Order> order = orderRepository.findById(Id);
        Order orderData = order.get();
        OrderDetailModel orderDetailModel = orderDetailMapper.mapEntityToModel(orderData);
        orderDetailModel.setPin(MyOrderPinEncryption.getEncryption(orderData.getPhone(), orderData.getOrderId()));
        orderDetailModel.setIsCancelAllowed(MyOrderPinEncryption.getCancelAllowed(orderData.getOrderStatus()));
        if (orderData.getAmount() > 0.00) {
            orderDetailModel.setShareMessageAmount(orderData.getAmount().longValue());
        } else {
            orderDetailModel.setShareMessageAmount(orderData.getAmount().longValue());
        }
        orderDetailModel.setDriverContactNo(helplinePhone);
        if (orderData.getOrderStatus().equalsIgnoreCase("outfordelivery")) {
            String[] result = orderData.getDeliveryInfo().split("/");
            if (result.length != 0) {
                orderDetailModel.setDriverName(result[0]);
                if (result.length == 2) {
//                    orderDetailModel.setDriverContactNo(result[1]); // temp change for few days, once SCM will confirm.. we will revert this
                    orderDetailModel.setDriverContactNo(helplinePhone);
                } else {
                    orderDetailModel.setDriverContactNo(helplinePhone);
                }
            }
        }

        Optional<UsersAddressEntity> usersAddress = usersAddressRepository.findByIdWithCity(orderData.getUserAddressId());
        orderDetailModel.setAddress(usersAddress.get().getAddress());
        orderDetailModel.setPincode(usersAddress.get().getPincode());
        orderDetailModel.setCity(usersAddress.get().getCity());
        orderDetailModel.setState(usersAddress.get().getState());
        orderDetailModel.setStateName(usersAddress.get().getStateName());
        orderDetailModel.setCityName(usersAddress.get().getCityName());

        Optional<ProductOfferTranslation> productTranslations = productTranslationsRepository.findByOfferIdAndLangName(orderData.getOfferId(),lang);
        orderDetailModel.setProductTitle(productTranslations.get().getName());
        orderDetailModel.setProductImage(this.fetchDealImage(productTranslations.get().getOfferId()));

        String orderStatusText = staticPropertyService.getStaticPropertyCache(
            StaticPropertiesKeyName.SP_ORDER_STATUS.getValue(),
            orderData.getOrderStatus(),
            lang
        );

        if (!ObjectUtils.isEmpty(orderStatusText)) {
            orderDetailModel.setShowOrderStatus(orderStatusText);
        } else {
            orderDetailModel.setShowOrderStatus(orderData.getOrderStatus());
        }

        JsonNode shareData = null;
        try {
            shareData = schemeServiceClient.getShareData(userName, password, lang, usersAddress.get().getPincode(), "B2C", orderData.getPhone(), "ORDER");
            orderDetailModel.setShareData(shareData);
        } catch (Exception e){
            log.error(e.getMessage());
        }

        return orderDetailModel;
    }

    private String  fetchReasonForCancellationFromKey(Integer tagId) {
        String reason = "";
        if (tagId != null && tagId > 0 ) {
            List<FeedbackTag> feedbackTags = reviewServiceClient.feedbackTagList("order-cancel", "status");
            Optional<FeedbackTag> ft = feedbackTags.stream().filter(feedbackTag -> feedbackTag.getId().equals(tagId)).findAny();
            if (ft.isPresent()) {
                reason = ft.get().getTag();
            }
        }

        return reason;
    }

    private List<String> decideTheSmsType(String type){
        List<String> listType = new ArrayList<>();
        listType.add("RIDER_ORDER_CANCEL");
        if(StringUtils.isEmpty(type)){
            listType.add("RIDER_ORDER_RESCHEDULE");
            listType.add("RIDER_ORDER_DELIVERED");
        }else if(type.equalsIgnoreCase("reschedule")){
            listType.remove(listType.size()-1);
            listType.add("RIDER_ORDER_RESCHEDULE");
        }else if(type.equalsIgnoreCase("delivered")){
            listType.remove(listType.size()-1);
            listType.add("RIDER_ORDER_DELIVERED");
        }
        return listType;
    }

    @Override
    @Transactional
    public NroOrderResponseModel registerNroOrders(NroOrderRequestModel requestModel){
//        List<Order> orders = orderRepository.findAllById(requestModel.getOrderIds());
        List<OrderNro> nroOrders = new ArrayList<>();
        requestModel.getOrderIds().forEach(x -> {
            OrderNro orderNro = new OrderNro();
            orderNro.setOrderId(x);
            orderNro.setCsStatus("Created");
            nroOrders.add(orderNro);
        });
        orderNroRepository.saveAll(nroOrders);
        NroOrderResponseModel nroOrderResponseModel = new NroOrderResponseModel();
        String message = messageSource.getMessage("order.delivery.confirmation", null, LocaleContextHolder.getLocale());
        nroOrderResponseModel.setResponseMessage(message);
        return nroOrderResponseModel;
    }

    @Override
    public UserConfirmationFormModel fetchUserReviewForm(UserReviewFormRequestModel requestModel){
        UserConfirmationFormModel response = new UserConfirmationFormModel();
        if (requestModel.getUserId() < 1L) {
            return response;
        }

        List<String> typeList = this.decideTheSmsType(requestModel.getType());
        Optional<SMSQueueEntity> optSmsQueueEntity = smsQueueEntityRepository.findLatestByUserId(requestModel.getUserId(), typeList);
        if (!optSmsQueueEntity.isPresent()) return response;
        requestModel.setSmsQueueEntity(optSmsQueueEntity.get());
        switch(optSmsQueueEntity.get().getSMS_type()){
            case "RIDER_ORDER_RESCHEDULE":
                requestModel.setType("reschedule");
                response = orderRescheduleConfirmationImpl.fetchUserConfirmationForm(requestModel);
                break;
            case "RIDER_ORDER_CANCEL":
                requestModel.setType("cancel");
                response = orderCancelConfirmationImpl.fetchUserConfirmationForm(requestModel);
                break;
            case "RIDER_ORDER_DELIVERED":
                requestModel.setType("delivered");
                response = orderDeliveryConfirmationImpl.fetchUserConfirmationForm(requestModel);
                break;
            default:
                break;
        }
        return response;
    }

    public String cancellationKey(Long orderId){
        return ORDER_CANCEL+orderId;
    }

    public Boolean allowCancellation(Long orderId){
        if(!cacheService.setnx(cancellationKey(orderId),System.currentTimeMillis(),300L,true)){
            throw new TooManyRequestsException("order cancellation underway");
        }
        return true;
    }

    public void clearRedisKey(Long orderId){
        cacheService.evict(cancellationKey(orderId));
    }

    public void clearAllRedisKey(List<Long> orderIds){
        for(Long orderId : orderIds) {
            cacheService.evict(cancellationKey(orderId));
        }
    }

    public Boolean setCartOrderCancellationKey(Long orderId) {
        Optional<CartOrderMapping> cartOrderMapping = cartOrderMappingRepository.findFirstByOrderId(orderId);
        if (cartOrderMapping.isPresent()) {
            return cacheService.setnx(CART_ORDER_CANCEL + cartOrderMapping.get().getCartId(), System.currentTimeMillis(),10L,true);
        }

        return Boolean.FALSE;
    }

    public Boolean setFileNameCancellationKey(String fileName){
        return cacheService.setnx(FILENAME_ORDER_CANCEL + fileName, System.currentTimeMillis(),Long.parseLong(PANEL_ORDER_CANCELLATION_FILE_REUPLOAD_LIMIT),true);
    }
    public void clearFileNameCancellationKey(String fileName){
        cacheService.evict(FILENAME_ORDER_CANCEL + fileName );
    }

    public void clearCartOrderCancellationKey(Long orderId) {
        Optional<CartOrderMapping> cartOrderMapping = cartOrderMappingRepository.findFirstByOrderId(orderId);
        cartOrderMapping.ifPresent(orderMapping -> cacheService.evict(CART_ORDER_CANCEL + orderMapping.getCartId()));
    }

    @Override
    public List<Long> bulkCancelWalletUpdate(BulkCancelWalletCreditModel bulkCancelWalletCreditModel) {
        List<Order> ordersData =
            orderRepository.findByIdIn(bulkCancelWalletCreditModel.getOrderIds());
        sendMessageToPostOrderUpdateQueue(ordersData);
        Optional<List<CartOrderMapping>> cartOrderMappingList = cartOrderMappingRepository.findAllByOrderIdIn(bulkCancelWalletCreditModel.getOrderIds());
        if(ObjectUtils.isEmpty(cartOrderMappingList)){
            return null;
        }
        List<StaticPropertiesModel> schemeProperties =
            staticDataClient.getStaticPropertiesModels(SCRATCH_CARD);
        Map<String, StaticPropertiesModel> scratchCardPropertiesMap = schemeProperties.stream()
            .collect(Collectors.toMap(StaticPropertiesModel::getPropertyName, Function.identity()));
        long scratchCardPlanId =
            Long.parseLong(scratchCardPropertiesMap.get(PLAN_ID).getPropertyValue());
        List<Long> excludedIncentivePlanIds = new ArrayList<>();
        excludedIncentivePlanIds.add(scratchCardPlanId);
        Set<Long> cartIds = cartOrderMappingList.get().stream().map(CartOrderMapping::getCartId).collect(Collectors.toSet());
        Optional<List<CustomerPoints>> getRedeemData =
            customerPointsRepository.findByIncentivePlanIdAndCartIdInAndTypeAndStatusOrderByCreatedDateDesc(
                scratchCardPlanId, cartIds,"credited",1L);
        if(getRedeemData.isPresent()) {
            Map<Long, List<Order>> userGetRedeemDataMap =
                ordersData.stream().collect(Collectors.groupingBy(Order::getUserId));
            for(CustomerPoints customerPoints: getRedeemData.get()){
                List<Order> scratchCardToBeRevoked = userGetRedeemDataMap.get(customerPoints.getUserId());
                if(ObjectUtils.isEmpty(scratchCardToBeRevoked)){
                    continue;
                }
                try {
                    scratchCardModifications(scratchCardToBeRevoked.get(0), customerPoints, scratchCardPropertiesMap);
                    cancelScratchCard(customerPoints,SCRATCH_CARD_CANCELLED);
                } catch (Exception e) {
                    log.error(
                        "Scratch card not credited back for orderData :{} due to exception :{}",
                        customerPoints.getOrderId(), e.toString());
                }
            }
        }
        return pointsService.bulkCreditWallet(ordersData, excludedIncentivePlanIds);
    }

    @Override
    public BulkOrderReturnWalletUpdate bulkReturnWalletUpdate(BulkCancelWalletCreditModel bulkCancelWalletCreditModel) {
        BulkOrderReturnWalletUpdate bulkOrderReturnWalletUpdate = new BulkOrderReturnWalletUpdate();

        List<Order> ordersData = orderRepository.findByIdIn(bulkCancelWalletCreditModel.getOrderIds());
        if (ordersData.isEmpty()) {
            log.error("bulkReturnWalletUpdate ordersData not found : {}", bulkCancelWalletCreditModel);
            return bulkOrderReturnWalletUpdate;
        }

        bulkOrderReturnWalletUpdate.setBulkCancelWalletUpdate(this.bulkCancelWalletUpdate(bulkCancelWalletCreditModel));

        List<Order> codOrdersData = orderRepository.findByIdInAndPaymentType(bulkCancelWalletCreditModel.getOrderIds(), COD_TYPE);
        if (codOrdersData.isEmpty()) {
            log.error("bulkReturnWalletUpdate codOrdersData ordersData not found : {}", bulkCancelWalletCreditModel);
            return bulkOrderReturnWalletUpdate;
        }

        bulkOrderReturnWalletUpdate.setCreditReturnOrderCustomerPoints(pointsService.creditReturnOrderCustomerPoints(codOrdersData));
        return bulkOrderReturnWalletUpdate;
    }

    @Override
    public BulkOrderReturnWalletUpdate refundOrderWalletCredits(WalletRefundCreditModel walletRefundCreditModel) {
        BulkOrderReturnWalletUpdate bulkOrderReturnWalletUpdate = new BulkOrderReturnWalletUpdate();

        List<Order> ordersData = orderRepository.findByIdIn(Collections.singletonList(walletRefundCreditModel.getOrderId()));
        if (ordersData.isEmpty()) {
            log.error("bulkReturnWalletUpdate ordersData not found : {}", walletRefundCreditModel);
            return bulkOrderReturnWalletUpdate;
        }

        if ( ! walletRefundCreditModel.isRefundDiscountAmount()) {
            List<Order> codOrdersData = orderRepository.findByIdInAndPaymentType(Collections.singletonList(walletRefundCreditModel.getOrderId()), COD_TYPE);
            if (codOrdersData.isEmpty()) {
                log.error("bulkReturnWalletUpdate codOrdersData ordersData not found : {}", walletRefundCreditModel);
                return bulkOrderReturnWalletUpdate;
            }
        }

        bulkOrderReturnWalletUpdate.setCreditReturnOrderCustomerPoints(
                pointsService.creditOrderCustomerPoints(ordersData.get(0), walletRefundCreditModel));
        return bulkOrderReturnWalletUpdate;
    }

    @Override
    public void triggerOrderStatusNotification(OrderStatusChangeCommModel orderStatusChangeCommModel) {
        if (ObjectUtils.isEmpty(orderStatusChangeCommModel.getOrderId())) {
            return;
        }

        List<Order> ordersData = orderRepository.findByIdIn(Collections.singletonList(orderStatusChangeCommModel.getOrderId()));
        if (ordersData.isEmpty()) {
            log.error("triggerOrderStatusNotification ordersData not found : {}", orderStatusChangeCommModel);
            return;
        }

        try {
            OrderDetailsSummaryDto orderDetailsSummaryDto = userOrderService.getOrderDetailsSummary(orderStatusChangeCommModel.getOrderId());
            Map<String, String> smsData = new HashMap<>();
            smsData.put(PRODUCT_NAME, orderDetailsSummaryDto.getProductName());
            smsData.put(CREDIT_AMOUNT, ! ObjectUtils.isEmpty(orderStatusChangeCommModel.getRefundAmount()) ? String.valueOf(orderStatusChangeCommModel.getRefundAmount()) : null);

            OrderSmsUpdatesDto orderSmsUpdatesDto = new OrderSmsUpdatesDto();
            orderSmsUpdatesDto.setTemplateName(orderStatusChangeCommModel.getTemplateName());
            orderSmsUpdatesDto.setSmsData(smsData);
            orderSmsUpdatesDto.setPhoneNumber(orderDetailsSummaryDto.getPhoneNumber());
            sqsPublisherService.publishMessage(orderSmsUpdatesQueue, orderSmsUpdatesDto);
        } catch (Exception ex) {
            log.error("Issues triggerOrderStatusNotification API {}", orderStatusChangeCommModel);
        }
    }

    @Override
    public void triggerOrderStatusNotificationBulk(BulkOrderStatusChangeCommModel bulkOrderStatusChangeCommModel) {
        if (bulkOrderStatusChangeCommModel.getOrderIds().isEmpty()) {
            return;
        }

        List<Order> ordersData = orderRepository.findByIdIn(bulkOrderStatusChangeCommModel.getOrderIds());
        if (ordersData.isEmpty()) {
            log.error("triggerOrderStatusNotificationBulk ordersData not found : {}", bulkOrderStatusChangeCommModel);
            return;
        }

        for (Long orderId : bulkOrderStatusChangeCommModel.getOrderIds()) {
            try {
                OrderDetailsSummaryDto orderDetailsSummaryDto = userOrderService.getOrderDetailsSummary(orderId);
                Map<String, String> smsData = new HashMap<>();
                smsData.put(PRODUCT_NAME, orderDetailsSummaryDto.getProductName());

                OrderSmsUpdatesDto orderSmsUpdatesDto = new OrderSmsUpdatesDto();
                orderSmsUpdatesDto.setTemplateName(bulkOrderStatusChangeCommModel.getTemplateName());
                orderSmsUpdatesDto.setSmsData(smsData);
                orderSmsUpdatesDto.setPhoneNumber(orderDetailsSummaryDto.getPhoneNumber());
                sqsPublisherService.publishMessage(orderSmsUpdatesQueue, orderSmsUpdatesDto);
            } catch (Exception ex) {
                log.error("Issues triggerOrderStatusNotificationBulk API {}", bulkOrderStatusChangeCommModel);
            }
        }
    }

    private void sendMessageToPostOrderUpdateQueue(List<Order> orderList){
        Set<Long> userAddressIdSet = orderList.stream().map(Order::getUserAddressId).collect(Collectors.toSet());
        List<PostOrderUpdateModel> postOrderUpdateModelList = userAddressIdSet.stream().map(userAddressId -> PostOrderUpdateModel
                .builder()
                .isCancelRequest(true)
                .userAddressId(userAddressId)
                .build()).collect(Collectors.toList());
        postOrderUpdateModelList.stream().forEach(postOrderUpdateModel -> {
                sqsPublisherService.publishMessage(postOrderUpdateQueueName, PostOrderUpdateSqsModel.builder()
                        .eventType(AppConstant.POST_ORDER_EVENT)
                        .object(postOrderUpdateModel)
                        .build());
        });
    }

    @Override
    @Transactional
    public ResponseEntity<?> updateOrderStatus(UserAddressOrderModel userAddressOrderModel) {
        List<Order> orders = orderRepository.findAllByUserAddressIdAndOrderStatus(userAddressOrderModel.getUserAddressId(), userAddressOrderModel.getStatus());
        Date verifiedDate = new Date();
        String btsStatus = "";
        if (!ObjectUtils.isEmpty(orders) && Objects.nonNull(userAddressOrderModel.getBtsCheck()) &&  userAddressOrderModel.getBtsCheck()){
            Long orderId = orders.get(0).getId();
            ResponseEntity<?> response = lastMileServiceClient.getBtsStatus(orderId);
            HashMap<String, Object> map = (HashMap<String, Object>) response.getBody();
            if(map.get("status").equals(false)){
                throw new FeignClientException("lastmile exception while fetching BTS status: " + map.get("message"));
            }
            btsStatus = Objects.isNull(map.get("data")) ? "" : map.get("data").toString();
        }
        String finalBtsStatus = btsStatus;
        List<Order> orderList = new ArrayList<>();
        if (orders.size() > 0) {
            orderList = orders.stream().map(order -> {
                if (ObjectUtils.isEmpty(finalBtsStatus) || Objects.equals(finalBtsStatus, BTS_STATUS)){
                    order.setOrderStatus(VERIFIED);
                }
                else {
                    order.setOrderStatus(DRAFT_VERIFIED);
                }
                order.setOrderSubStatus(UPDATED_FROM_AVP);
                order.setVerifiedDate(verifiedDate);
                log.error("order update verified date check, order id : {}, user address id : {} , order status : {} , verified date : {} ",order.getId(),order.getUserAddressId(), order.getOrderStatus(), order.getVerifiedDate());
                return order;
            }).collect(Collectors.toList());
            orderRepository.saveAll(orderList);
        }
        List<OrderHistory> orderHistoryList = orders.stream().map(order -> {
            OrderHistory orderHistory = new OrderHistory(order, AppConstant.AVP_ORDER_HISTORY_STATUS, order.getUserId());
            orderHistory.setVerifiedDate(verifiedDate);
            return orderHistory;
        }).collect(Collectors.toList());
        orderHistoryRepository.saveAll(orderHistoryList);
        List<Long> orderIds = orderList.stream().map(Order::getId).collect(Collectors.toList());
        try {
            triggerOrderStatusUpdateEvent(orderIds, AppConstant.ORDER_VERIFIED);
        }catch (Exception e){
            log.error("Error while sending order status event {}",e.getMessage());
        }
        return new ResponseEntity<>(HttpStatus.OK);
    }

    private void triggerOrderStatusUpdateEvent(List<Long> orderIds, String event) throws Exception {
        try {
            OrdersStatusUpdateEvent ordersStatusUpdateEvent = OrdersStatusUpdateEvent.builder()
                    .orderIds(orderIds)
                    .event(event)
                    .build();
            queueProducer.sendOrdersStatusUpdateTopic(ordersStatusUpdateEvent);
        }catch (Exception e){
            log.error("Error while sending order verified event for shipsy : {}",e.getMessage());
            throw new Exception("Error while sending order verified event for shipsy with error mesasage : " + e.getMessage());
        }

    }

    @Override
    public DoorStepDeliveryFeeUpdateResponseModel updateDoorStepDeliveryFee(DoorStepDeliveryFeeUpdate doorStepDeliveryFeeUpdate)
        throws JsonProcessingException {

        DoorStepDeliveryFeeUpdateResponseModel doorStepDeliveryFeeUpdateResponseModel = new DoorStepDeliveryFeeUpdateResponseModel();

        if(doorStepDeliveryFeeUpdate==null){
            log.error("Received empty body from ops for door step delivery Fee Update");
            return doorStepDeliveryFeeUpdateResponseModel;
        }
        if(ObjectUtils.isEmpty(doorStepDeliveryFeeUpdate.getDeliveryFee())||
            ObjectUtils.isEmpty(doorStepDeliveryFeeUpdate.getOrderIds())||
            ObjectUtils.isEmpty(doorStepDeliveryFeeUpdate.getShipmentId())){
            log.error("Received bad request from ops for door step delivery Fee Update");
            return doorStepDeliveryFeeUpdateResponseModel;
        }

        Optional<DoorStepCancellationsOnlineUpdate> alreadyUpdated =
            doorStepCancellationsOnlineUpdateRepository.findFirstByShipmentId(doorStepDeliveryFeeUpdate.getShipmentId());
        if(!ObjectUtils.isEmpty(alreadyUpdated)){
            return doorStepDeliveryFeeUpdateResponseModel;
        }

        List<Order> orderList = orderRepository.findByIdIn(doorStepDeliveryFeeUpdate.getOrderIds());
        Order orderToProcess = null;
        for(Order order: orderList){
            if(order.getAmount()>doorStepDeliveryFeeUpdate.getDeliveryFee()){
                orderToProcess = order;
                break;
            }
        }
        if(ObjectUtils.isEmpty(orderToProcess)){
            log.error("No order found with order value greater than delivery fee for request = {}",doorStepDeliveryFeeUpdate.toString());
            return doorStepDeliveryFeeUpdateResponseModel;
        }

        Optional<CartOrderMapping> cartOrderMapping = cartOrderMappingRepository.findFirstByOrderId(orderToProcess.getId());
        if(!cartOrderMapping.isPresent()){
            log.error("No cart order mapping found for this order id = {}",orderToProcess.toString());
            return doorStepDeliveryFeeUpdateResponseModel;
        }

        Optional<Cart> cart = cartRepository.findById(cartOrderMapping.get().getCartId());
        if(!cart.isPresent()){
            log.error("No cart found for this order id = {}",orderToProcess.toString());
            return doorStepDeliveryFeeUpdateResponseModel;
        }

        RefundAmountPaymentsUpdateModel refundAmountPaymentsUpdateModel = new RefundAmountPaymentsUpdateModel();
        refundAmountPaymentsUpdateModel.setDeliveryFee(doorStepDeliveryFeeUpdate.getDeliveryFee());
        refundAmountPaymentsUpdateModel.setOrderId(orderToProcess.getId());
        ResponseEntity<?> response = null;

        try {
            response = paymentServiceClient
                .updateRefundAmount(refundAmountPaymentsUpdateModel, userName, password);
        }
        catch (Exception e){
            log.error("exception is {}",e.toString());
            return doorStepDeliveryFeeUpdateResponseModel;
        }

        cart.get().setDeliveryFee(doorStepDeliveryFeeUpdate.getDeliveryFee());
        cart.get().setCartConfigId(doorStepDeliveryFeeUpdate.getConfigId());
        cartRepository.save(cart.get());

        DoorStepCancellationsOnlineUpdate doorStepCancellationsOnlineUpdate = new DoorStepCancellationsOnlineUpdate();
        doorStepCancellationsOnlineUpdate.setDeliveryFee(doorStepDeliveryFeeUpdate.getDeliveryFee());
        doorStepCancellationsOnlineUpdate.setCancelledOrderIds(objectMapper.writeValueAsString(doorStepDeliveryFeeUpdate.getOrderIds()));
        doorStepCancellationsOnlineUpdate.setOrderId(orderToProcess.getId());
        doorStepCancellationsOnlineUpdate.setConfigId(doorStepDeliveryFeeUpdate.getConfigId());
        doorStepCancellationsOnlineUpdate.setShipmentId(doorStepDeliveryFeeUpdate.getShipmentId());

        doorStepCancellationsOnlineUpdateRepository.save(doorStepCancellationsOnlineUpdate);

        doorStepDeliveryFeeUpdateResponseModel.setStatus(Boolean.TRUE);
        return doorStepDeliveryFeeUpdateResponseModel;
    }

    @Override
    @Transactional
    public ResponseEntity<?> cancelAllOrders(List<OrderCancelModel> orderCancelModelList) {
        for(OrderCancelModel orderCancelModel : orderCancelModelList){
            Object response = cancelOrder(orderCancelModel,orderCancelModel.getUserId(), 0, Boolean.FALSE);
            if(!(response instanceof Boolean)){
                throw new RuntimeException("Error while cancelling order");
            }
            triggerOrderCancelEventSyncCall(orderCancelModel.getUserId(),orderCancelModel);
        }
        return new ResponseEntity<>(HttpStatus.OK);
    }

    public long getOnlineRefundAmount(long orderId){
        List<CartOrderMapping> cartOrderMappings = cartOrderMappingRepository.findCartOrderMappings(orderId);
        if(CollectionUtils.isEmpty(cartOrderMappings)){
            log.error("CartOrdersMapping not found for orderId: {}", orderId);
            throw new NotFoundException("Cart Mapping Not found for orderId: "+ orderId);
        }
        long cartId = cartOrderMappings.get(0).getCartId();
        List<Long> orderIds = cartOrderMappings.stream()
            .map(CartOrderMapping::getOrderId).collect(Collectors.toList());

        List<Order> orders = orderRepository.findByIdIn(orderIds);
        List<Order> nonCancelledOrders = orders.stream()
            .filter(order -> !AppConstant.CANCEL_STATUS.equalsIgnoreCase(order.getOrderStatus()))
            .collect(Collectors.toList());

        Order order = orders.stream()
            .filter(cartOrder -> cartOrder.getId() == orderId).findFirst().get();
        if(!AppConstant.PAYMENT_TYPE_PAYTM.equalsIgnoreCase(order.getPaymentType()))
            return 0;

        long amount = order.getAmount().longValue();
        if(nonCancelledOrders.size() == 1 && nonCancelledOrders.get(0).getId() == orderId){
            List<PaymentEntity> paymentEntities = paymentRepo.findByCartId(cartId);
            if(CollectionUtils.isEmpty(paymentEntities))
                return 0;

            PaymentEntity paymentEntity = paymentEntities.get(0);
            if(paymentEntity.getDeliveryFee() != null)
                amount += paymentEntity.getDeliveryFee().longValue();
        }

        return amount;
    }

    public void addShipmentDetails(Long userAddressId, Long userId, Long orderId) {
        AddShipmentDetailsRequestModel addShipmentDetailsRequestModel = new AddShipmentDetailsRequestModel();
        addShipmentDetailsRequestModel.setOrderId(orderId);
        addShipmentDetailsRequestModel.setUserAddressId(userAddressId);
        addShipmentDetailsRequestModel.setUserId(userId);
        try {
            Optional<Package> existingActivePackage = packageRepository.findFirstByUserAddressIdAndStatus(
                    addShipmentDetailsRequestModel.getUserAddressId(),
                    true
            );

            Package activePackage = new Package();
            if ( ! existingActivePackage.isPresent()) {
                activePackage.setUserAddressId(addShipmentDetailsRequestModel.getUserAddressId());
                activePackage.setUserId(addShipmentDetailsRequestModel.getUserId());
                activePackage.setStatus(true);
                activePackage = packageRepository.save(activePackage);
            } else {
                activePackage = existingActivePackage.get();
            }

            packageOrderRepository.save(PackageOrder.builder()
                    .packageId(activePackage.getId())
                    .orderId(addShipmentDetailsRequestModel.getOrderId())
                    .build());
//            ResponseEntity<?> response = orderServiceClient.addShipmentDetails(addShipmentDetailsRequestModel);
        } catch (Exception e){
            log.error("Error in adding Shipment details : {}", e.getMessage());
        }
    }

    private OrderInfo mapToOrderInfo(Order order, DealDetail dealDetail) {
        OrderInfo orderInfo = new OrderInfo();
        orderInfo.setId(order.getId());
        orderInfo.setAmount(order.getBilledAmount().longValue());
        orderInfo.setStatus(order.getOrderStatus());
        orderInfo.setIsCustomerFault(Boolean.TRUE);
        orderInfo.setDealDetailRequest(dealDetail);
        return orderInfo;
    }

    private OrderMovBreach getCartDiscountMovBreach(Order orderData, Long cartId, String lang) {
        List<Order> orders = orderRepository.getOrdersByCartId(cartId);
        RevertDiscountBreachRequest revertBreachRequest =
            new RevertDiscountBreachRequest();
        revertBreachRequest.setUserId(orderData.getUserId());
        RevertDiscountCartDetail revertDiscountCartDetail =
            new RevertDiscountCartDetail();
        Map<Long, DealDetail> orderToDealMap = getDealInformationMap(orders);
        revertDiscountCartDetail.setOrderInfo(orders.stream()
                .map(o -> this.mapToOrderInfo(o, orderToDealMap.get(o.getId())))
                .collect(Collectors.toList()));
        revertDiscountCartDetail.setCancelledOrderIds(Arrays.asList(orderData.getId()));
        revertDiscountCartDetail.setCartId(cartId);
        revertDiscountCartDetail.setIsRestricted(false);
        revertBreachRequest.setRevertDiscountCartDetails(Arrays.asList(revertDiscountCartDetail));
        try {

            RevertDiscountBreachResponse response =
                discountServiceClientWrapper.getDiscountRevertBreach(lang, revertBreachRequest);
            if (Objects.nonNull(response) && !CollectionUtils.isEmpty(
                response.getCartBreachDetails())) {
                RevertDiscountBreachCartDetail breachCartDetail =
                    response.getCartBreachDetails().get(0);

                return OrderMovBreach.builder().type(CART_DISCOUNT)
                    .message(breachCartDetail.getBreachMessage())
                    .icon(response.getBreachIcon()).build();
            }
            return null;
        } catch (Exception e) {
            log.error("problem while revert discount breach in discounting service : {}",
                e.getMessage());
            throw new ValidationException(
                "problem while revert discount breach in discounting service for userId: "
                    + orderData.getUserId() + "having orderId: " + orderData.getId()
                    + e.getMessage());
        }
    }
    @Override
    public ResponseEntity<?> getCartDetails(CartDetailsRequestModel cartDetailsRequestModel) throws Exception {
        try {
            List<Order> orderList = new ArrayList<>();
            if (cartDetailsRequestModel.getConsiderTime().equals(false)) {
                orderList = orderRepository.findAllByUserIdAndOrderStatusNotIn(cartDetailsRequestModel.getUserId(), AppConstant.ORDER_CANCEL_DISCARDED_STATUS);
            } else {
                SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss", Locale.ENGLISH);
                orderList = orderRepository.findAllByUserIdAndOrderStatusNotInAndOrderDateGreaterThan(cartDetailsRequestModel.getUserId(), AppConstant.ORDER_CANCEL_DISCARDED_STATUS, formatter.parse(cartDetailsRequestModel.getTime()));
            }
            List<Long> orderIds = orderList.stream().map(Order::getId).collect(Collectors.toList());
            Optional<List<CartOrderMapping>> optionalCartIds = cartOrderMappingRepository.findAllByOrderIdIn(orderIds);
            Set<Long> cartIds = new HashSet<>();
            if (optionalCartIds.isPresent()) {
                cartIds = optionalCartIds.get().stream().map(CartOrderMapping::getCartId).collect(Collectors.toSet());
            }
            return new ResponseEntity<>(new ArrayList<>(cartIds), HttpStatus.OK);
        }catch (Exception e){
            log.error("Error while fetching order data for cartDetailsRequestModel {}", cartDetailsRequestModel);
            throw new Exception("Error while fetching order data for cartDetailsRequestModel " + cartDetailsRequestModel);
        }
    }

    @Override
    public void triggerOrderCancelEventSyncCall(Long userId, OrderCancelModel orderCancelModel) {

        if (Objects.isNull(orderCancelModel)  || orderCancelModel.getOrderId() == null) {
            return;
        }

        Optional<Order> optionalOrder = orderRepository.findById(orderCancelModel.getOrderId());
        if(!optionalOrder.isPresent()){
            return;
        }
        Order order = optionalOrder.get();

        OrdersStatusUpdateEvent ordersStatusUpdateEvent = new OrdersStatusUpdateEvent();
        ordersStatusUpdateEvent.setOrderIds(Collections.singletonList(order.getId()));
        String event = order.getPaymentType().equalsIgnoreCase(PAYMENT_TYPE_PAYTM) ?
                APP_CANCEL_ONLINE : APP_CANCEL_COD;
        ordersStatusUpdateEvent.setEvent(event);
        queueProducer.sendOrdersStatusUpdateTopic(ordersStatusUpdateEvent);

        log.error("raised event for order cancellation for dto : {} and event : {} and orderId : {}", ordersStatusUpdateEvent,event,order.getId());

        String flagValue = staticPropertyService.getStaticPropertyCache(SP_USER_RANK_TRANSITION_LIVE,
                SP_USER_RANK_TRANSITION_CANCEL_FLOW, Language.ENG.getValue());
        if (!ObjectUtils.isEmpty(flagValue) && flagValue.equals("true")) {
            UserRankTransitionRequestModel userRankTransitionRequestModel = UserRankTransitionRequestModel.builder()
                    .userId(userId)
                    .event(ORDER_CANCEL_EVENT)
                    .isForceUpdate(false)
                    .build();

            try {
                userServiceClient.updateUserRank(userRankTransitionRequestModel);
            } catch (Exception ex) {
                log.error("TriggerOrderCancelEventSyncCall: Error happened during user rank update userId: {}, exception: {}", userRankTransitionRequestModel.getUserId(), ex.getMessage());
            }
        }
    }


    private Optional<Map<String,Object>> getCartForDeliveryFee(User user, Date date, List<Long> cancelRequestOrders, int minimumOrderValueForDeliveryFee,GetMovV2RequestBody requestBody) {
        ResponseEntity<MovResponseModel> movResponseEntity = orderServiceClientWrapper.getMovV2(user.getId(), user.getPincode().toString(), date, cancelRequestOrders,requestBody);
        log.error("Cancel Order request, getCartForDeliveryFee response: {}, user : {}, date : {}, cancelRequestOrders : {}", movResponseEntity,user,date,cancelRequestOrders);
        if (movResponseEntity.getStatusCode() == HttpStatus.OK) {
            MovResponseModel movResponseModel = movResponseEntity.getBody();
            assert movResponseModel != null;
            int amount = movResponseModel.getAmount().intValue();
            if (!ObjectUtils.isEmpty(movResponseModel.getCartId()) && amount < minimumOrderValueForDeliveryFee) {
                Map<String, Object> resultData = new HashMap<>();
                resultData.put("maxCartId", movResponseModel.getCartId().toString());
                return Optional.of(resultData);
            }
        }
        return Optional.empty();
    }
    public Boolean checkIfCancellationDisabled(Long userId, Order orderData, Boolean isInternalServiceCall) {
        if (Boolean.TRUE.equals(isInternalServiceCall)) {
            return false;
        }

        Optional<List<OrderProductDetails>> orderProductDetails = orderProductDetailsRepository.findByOrderId(orderData.getId());
        if(orderProductDetails.isPresent() && !ObjectUtils.isEmpty(orderProductDetails)) {
            OrderCancellationConfig orderCancellationConfig = growthbookService.getOrderCancellationConfigV2(Long.valueOf(orderProductDetails.get().get(0).getWarehouseId()), userId);
            if (orderCancellationConfig.isEnable() && !ObjectUtils.isEmpty(orderCancellationConfig.getMinutes())) {
                long diff = new Date().getTime() - orderData.getOrderDate().getTime();
                long minutes = TimeUnit.MILLISECONDS.toMinutes(diff);
                return minutes > orderCancellationConfig.getMinutes();
            }
        }
        return false;
    }

    public Boolean checkIfCancellationDisabledSingleOrder(Long userId, Order orderData, Boolean isInternalServiceCall, Boolean canCancelCentralizedOrder) {

        if (Boolean.TRUE.equals(isInternalServiceCall)) {
            return false;
        }

        if( ! Boolean.TRUE.equals(canCancelCentralizedOrder)){
            log.error("Cancellation is disabled for User ID: {} and Order: {}", userId, orderData);
            return true;
        }

        Optional<List<OrderProductDetails>> orderProductDetails = orderProductDetailsRepository.findByOrderId(orderData.getId());
        if(orderProductDetails.isPresent() && !ObjectUtils.isEmpty(orderProductDetails)) {
            OrderCancellationConfig orderCancellationConfig = growthbookService.getOrderCancellationConfigV2(Long.valueOf(orderProductDetails.get().get(0).getWarehouseId()), userId);
            if (commonUtils.checkProdEnvironment() && orderCancellationConfig.isEnable() && !ObjectUtils.isEmpty(orderCancellationConfig.getMinutes())) {
                long diff = new Date().getTime() - orderData.getOrderDate().getTime();
                long minutes = TimeUnit.MILLISECONDS.toMinutes(diff);
                return minutes > orderCancellationConfig.getMinutes();
            }
        }

        return false;
    }

    public Boolean cancelCentralizedOrder(Order orderData, Long cartId,List<CartOrderMapping> cartOrderMappingList){
        Long orderId = orderData.getId();
        double orderAmount = orderData.getAmount();
        Map<GetFeesFilterType, Map<GetFeesFilterValue, Object>> filter = new HashMap<>();
        Map<GetFeesFilterValue, Object> getFeesFilterValueObjectMap = new HashMap<>();
        getFeesFilterValueObjectMap.put(GetFeesFilterValue.CART_ID, cartId);
        filter.put(GetFeesFilterType.EQUAL_TO, getFeesFilterValueObjectMap);
        GetFeesRequest getFeesRequest = new GetFeesRequest();
        getFeesRequest.setFeesType(GetFeesType.CART_FEES);
        getFeesRequest.setFilter(filter);
        GetFeesResponse getFeesResponse = feesService.getFees(getFeesRequest);
        if(getFeesResponse ==null || getFeesResponse.getCartFeesData() == null || getFeesResponse.getCartFeesData().isEmpty()){
            return true;
        }
        if(getFeesResponse.getCartFeesData().get(0).getCartType().equalsIgnoreCase("cod")){
            return true;
        }
        List<Long> orderIds = new ArrayList<>();
        List<Order> orders = new ArrayList<>();
        if (cartOrderMappingList != null && !cartOrderMappingList.isEmpty()) {
            for (CartOrderMapping mapping : cartOrderMappingList) {
                orderIds.add(mapping.getOrderId().longValue());
            }
            orders = orderRepository.findAllById(orderIds);
        }
        double remainingCartAmount = 0.0;
        for(Order order : orders){
            if(order.getId().longValue()!= orderId && UserOrderStatus.ONGOING.getValues().contains(order.getOrderStatus().toLowerCase())){
                remainingCartAmount += order.getAmount();
            }
        }
        GetCartFeesResponse cartFeesResponse = getFeesResponse.getCartFeesData().get(0);
        ConfigSnapshot configSnapshot = null;

        if (cartFeesResponse.getConfigSnapshot() != null) {
            configSnapshot = cartFeesResponse.getConfigSnapshot().stream()
                    .filter(snapshot -> DELIVERY_FEES.name().equalsIgnoreCase(snapshot.getFeesType()))
                    .findFirst()
                    .orElse(null);
        }
        if(remainingCartAmount < configSnapshot.getMov()){
            FeesData feesData = cartFeesResponse.getFeesData().stream().filter(feesData1 -> DELIVERY_FEES.name().equalsIgnoreCase(feesData1.getFeesType()))
                    .findFirst().orElse(null);
            if(feesData.getFeesFinal() > 0){
                return true;
            }else if(orderAmount < configSnapshot.getFees()){
                return false;
            }
        }
        return true;
    }


    public OrderSyncResponseModel minimartOrderSync(OrderSyncRequestModel orderSyncRequestModel) {

        List<UserOrderSyncModel> userOrderSyncModelList = orderSyncRequestModel.getUserOrderSyncModelList();
        
        List<String> posOrderIds = userOrderSyncModelList.stream()
                .map(UserOrderSyncModel::getPosOrderId)
                .filter(Objects::nonNull)
                .distinct()
                .collect(Collectors.toList());
        
        List<String> acquiredLocks = new ArrayList<>();
        try {
            for (String posOrderId : posOrderIds.stream().sorted().collect(Collectors.toList())) {
                String lockKey = MINIMART_ORDER_SYNC_LOCK + posOrderId;
                acquireLock(lockKey, posOrderId);
                acquiredLocks.add(lockKey);
            }
        } catch (Exception e) {
            // Release all acquired locks if any lock acquisition fails
            releaseLocks(acquiredLocks);
            throw e;
        }

        OrderSyncResponseModel orderSyncResponseModel = new OrderSyncResponseModel();
        Map<String, List<OrderDealMappingModel>> posOrderOmsOrderMap = new HashMap<>();
        Map<String, String> ordersSyncStatusMap = new HashMap<>();

        List<String> posOrderIdList = userOrderSyncModelList.stream()
                .map(UserOrderSyncModel::getPosOrderId)
                .collect(Collectors.toList());

        List<POSOrderMapping> posOrderMappingList = posOrderMappingRepository.findByPosOrderIdIn(posOrderIdList);

        Set<String> posOrderIdSet = posOrderMappingList.stream()
                .map(POSOrderMapping::getPosOrderId)
                .collect(Collectors.toSet());

        List<UserOrderSyncModel> existingUserOrderSyncModelList = userOrderSyncModelList.stream()
                .filter(userOrderSyncModel -> posOrderIdSet.contains(userOrderSyncModel.getPosOrderId()))
                .collect(Collectors.toList());

        Map<String, List<POSOrderMapping>> posOrderMappingMap = posOrderMappingList.stream()
                .collect(Collectors.groupingBy(POSOrderMapping::getPosOrderId));

        posOrderIdSet.clear();

        for(UserOrderSyncModel userOrderSyncModel : existingUserOrderSyncModelList) {
            List<POSOrderMapping> posOrderMappings = posOrderMappingMap.get(userOrderSyncModel.getPosOrderId());

            List<OrderDealMappingModel> orderDealMappingModelList = getOrderDealMappingForExistingOrder(posOrderMappings,
                    userOrderSyncModel.getOfferIdOrderSummaryModelMap());

            if(!ObjectUtils.isEmpty(orderDealMappingModelList)) {
                posOrderIdSet.add(userOrderSyncModel.getPosOrderId());
                posOrderOmsOrderMap.put(userOrderSyncModel.getPosOrderId(), orderDealMappingModelList);
            }
        }

        userOrderSyncModelList = userOrderSyncModelList.stream()
                .filter(userOrderSyncModel -> !posOrderIdSet.contains(userOrderSyncModel.getPosOrderId()))
                .collect(Collectors.toList());

        for (UserOrderSyncModel userOrderSyncModel : userOrderSyncModelList) {

            UserInfoModel userInfoModel = userOrderSyncModel.getUserInfoModel();
            try {
                UserCacheModel userCacheModel = userService.getUser(userInfoModel);

                /** userCacheModel and userInfoModel pincode can be different if user is present in db already*/
                Long userAddressId = userAddressService.getUserAddress(userCacheModel).getId();

                List<OrderDealMappingModel> orderDealMappingModelList = userOrderService.syncOrders(userCacheModel,
                        userOrderSyncModel,
                        userAddressId);

                posOrderOmsOrderMap.put(userOrderSyncModel.getPosOrderId(), orderDealMappingModelList);
            } catch (Exception e) {
//                chatServiceClient.sendEmailToMultiple(CommonUtils.prepareEmailRequestModel(EmailSubject.MINIMART_ORDER_SYNC.getValue(), String.format("userOrderSyncModel : %s, Exception : %s", userOrderSyncModel, e)));
                ordersSyncStatusMap.put(userOrderSyncModel.getPosOrderId(), e.getMessage());
                log.error("Something went wrong in saving order : {}, Exception : {}", userOrderSyncModel, e.getMessage());
            }
        }
        orderSyncResponseModel.setPosOrderOmsOrderMap(posOrderOmsOrderMap);
        posOrderOmsOrderMap.keySet().forEach(posOrderId -> ordersSyncStatusMap.put(posOrderId, "Synced Successfully"));
        orderSyncResponseModel.setOrdersSyncStatusMap(ordersSyncStatusMap);

        releaseLocks(acquiredLocks);

        return orderSyncResponseModel;
    }

    private void acquireLock(String lockKey, String posOrderId) {
        try {
            boolean lockAcquired = cacheService.setnx( lockKey, System.currentTimeMillis(),
                    8L, true, TimeUnit.MINUTES);

            if (!lockAcquired) {
                log.error("Concurrent Minimart Order Sync request for posOrderId: {}, lock: {}", posOrderId, lockKey);
                throw new RuntimeException("Minimart Order Sync is already in progress for posOrderId: " + posOrderId);
            }
        } catch (Exception ex) {
            log.error("Redis lock failing for concurrent minimart order sync call with exception: {}, lock: {}, posOrderId: {}", ex.getMessage(), lockKey, posOrderId);
            cacheService.evict(lockKey);
            throw ex;
        }
    }

    private void releaseLocks(List<String> lockKeys) {
        for (String lockKey : lockKeys) {
            try {
                cacheService.evict(lockKey);
                log.debug("Released lock: {}", lockKey);
            } catch (Exception e) {
                log.error("Failed to release lock: {}, exception: {}", lockKey, e.getMessage());
            }
        }
    }

    @Override
    public RevertDiscountBreachResponse getUserCartBreachSummary(String lang,UserBreachDiscountRequest userBreachDiscountRequest) {
        List<CartBreachDiscountRequest> cartDetails = userBreachDiscountRequest.getCartDetails();
        Set<Long> allOrderIds = new HashSet<>();
        cartDetails.forEach(cartDetail -> {
            allOrderIds.addAll(cartDetail.getOrderCancelDiscountUpdateRequests().stream()
                .map(OrderCancelDiscountUpdateRequest::getOrderId).collect(Collectors.toList()));
        });
        Map<Long,List<Order>> cartToOrdersMap = new HashMap<>();
        Map<Long,Long> orderToCartMapping = prepareBulkDiscountRevertMaps(allOrderIds,cartToOrdersMap);
        List<Order> allOrders =
            orderRepository.findAllOrdersByCartIds(new ArrayList<>(orderToCartMapping.values()));
        allOrderIds.addAll(allOrders.stream().map(Order::getId).collect(Collectors.toSet()));

        populateCartIds(cartDetails, orderToCartMapping);

        RevertDiscountBreachRequest revertDiscountBreachRequest = RevertDiscountBreachRequest.builder()
            .userId(allOrders.get(ZERO).getUserId())
            .revertDiscountCartDetails(cartDetails.stream().map(cartBreachDiscountRequest -> {
                Set<Long> cancelledByCustomerFault = new HashSet<>();
                Set<Long> allCancelled = new HashSet<>();

                List<Order> allOrdersOfThisCart = cartToOrdersMap.get(cartBreachDiscountRequest.getCartId());
                updateCancelledOrders(cartBreachDiscountRequest.getOrderCancelDiscountUpdateRequests(), allOrdersOfThisCart,
                    cancelledByCustomerFault,allCancelled);
                Map<Long, OrderCancelDiscountUpdateRequest> orderCancelDiscountUpdateRequestMap =
                    cartBreachDiscountRequest.getOrderCancelDiscountUpdateRequests()
                        .stream().collect(Collectors.toMap(o -> o.getOrderId(), o -> o));

                Map<Long, DealDetail> orderToDealMap = getDealInformationMap(allOrdersOfThisCart);
                Boolean isRestricted = calculateIsRestrictedFlag(cartBreachDiscountRequest, allOrders);
                List<OrderInfo> orderInfos = prepareOrderInfo(allOrdersOfThisCart,cancelledByCustomerFault,orderCancelDiscountUpdateRequestMap, orderToDealMap);

                return RevertDiscountCartDetail.builder()
                    .cartId(cartBreachDiscountRequest.getCartId())
                    .cancelledOrderIds(new ArrayList<>(allCancelled))
                    .isRestricted(isRestricted)
                    .orderInfo(orderInfos)
                    .build();
            }).collect(Collectors.toList()))
            .build();
        RevertDiscountBreachResponse revertDiscountBreachResponse = discountServiceClientWrapper.getDiscountRevertBreach(lang,revertDiscountBreachRequest);
        populateBreachDetails(revertDiscountBreachResponse,allOrders);

        return revertDiscountBreachResponse;
    }

    private void populateCartIds(List<CartBreachDiscountRequest> cartDetails, Map<Long,Long> orderToCartMapping){
        cartDetails.forEach(cartDetail -> {
            cartDetail.setCartId(orderToCartMapping.get(cartDetail.getOrderCancelDiscountUpdateRequests().get(ZERO).getOrderId()));
        });
    }

    private Boolean calculateIsRestrictedFlag(CartBreachDiscountRequest cartBreachDiscountRequest,
                                              List<Order> allOrders){
        Boolean isRestricted = cartBreachDiscountRequest.getSplitDelivery();
//        if(allOrders.stream().anyMatch(o -> PAYMENT_TYPE_PAYTM.equalsIgnoreCase(o.getPaymentType()))
//            && !growthbookService.prepaidDiscountRefundEnabled(allOrders.get(ZERO).getUserId())){
//            isRestricted = Boolean.TRUE;
//        }
        return isRestricted;
    }

    private List<OrderInfo> prepareOrderInfo(List<Order> orders, Set<Long> cancelledByCustomerFault,
                                             Map<Long, OrderCancelDiscountUpdateRequest> orderIdToOrderSyncRequestMap,
                                             Map<Long, DealDetail> orderToDealDetailMap){
        return orders.stream().map(o -> {
            String status = orderIdToOrderSyncRequestMap.containsKey(o.getId()) ?
                                orderIdToOrderSyncRequestMap.get(o.getId()).getStatus() : o.getOrderStatus();
            return OrderInfo.builder()
                .id(o.getId())
                .amount(o.getBilledAmount().longValue())
                .status(status)
                .isCustomerFault(cancelledByCustomerFault.contains(o.getId()))
                .dealDetailRequest(orderToDealDetailMap.get(o.getId()))
                .build();
        }).collect(Collectors.toList());
    }

    private void updateCancelledOrders(List<OrderCancelDiscountUpdateRequest> cartOrderRequests, List<Order> orders,
                                       Set<Long> cancelledByCustomerFault, Set<Long> allCancelled){
        cancelledByCustomerFault.addAll(cartOrderRequests.stream()
            .filter(o -> CANCELLED.getValues().contains(o.getStatus()))
            .filter(OrderCancelDiscountUpdateRequest::getCustomerFault)
            .map(OrderCancelDiscountUpdateRequest::getOrderId).collect(Collectors.toSet()));
        allCancelled.addAll(cartOrderRequests.stream()
            .filter(o -> CANCELLED.getValues().contains(o.getStatus()))
            .map(OrderCancelDiscountUpdateRequest::getOrderId).collect(Collectors.toSet()));

        Set<Long> ordersReceivedForCart = cartOrderRequests.stream()
            .map(OrderCancelDiscountUpdateRequest::getOrderId).collect(Collectors.toSet());
        List<Order> ordersNotReceivedForCart = orders.stream()
            .filter(o -> !ordersReceivedForCart.contains(o.getId())).collect(Collectors.toList());

        ordersNotReceivedForCart.forEach(o -> {
            if(CANCELLED.getValues().contains(o.getOrderStatus()) &&
                CUSTOMER_FAULT_CANCELLED_STATUS.getValues().contains(o.getOrderSubStatus())) {
                cancelledByCustomerFault.add(o.getId());
            }
            if(CANCELLED.getValues().contains(o.getOrderStatus())){
                allCancelled.add(o.getId());
            }
        });
    }

    @Override
    public BulkCartDiscountRevertResponse bulkDiscountRevert(BulkCartDiscountRevertRequest bulkRevertRequest) {
        log.error("Request received in BulkCartDiscountRevertRequest, {}", bulkRevertRequest);
        Map<Long, OrderCancelDiscountUpdateRequest> orderIdToOrderSyncRequestMap =
            bulkRevertRequest.getOrderCancelDiscountUpdateRequests().stream()
                .collect(Collectors.toMap(OrderCancelDiscountUpdateRequest::getOrderId,
                    cancelOrderDetail -> cancelOrderDetail, (l1,l2) -> l2));
        Map<Long,List<Order>> cartOrdersMapping = new HashMap<>();
        Map<Long,Long> orderToCartMapping = prepareBulkDiscountRevertMaps(orderIdToOrderSyncRequestMap.keySet(), cartOrdersMapping);
        Map<Long,Order> allOrdersMap = new HashMap<>();

        List<RevertDiscountRequestV2> revertDiscountRequests =
            prepareRevertDiscountRequests(cartOrdersMapping, allOrdersMap,orderIdToOrderSyncRequestMap);

        BulkCartDiscountRevertResponse bulkCartDiscountRevertResponse =
            discountServiceClientWrapper.getBulKDiscountRevertResponse(revertDiscountRequests);

        Map<String,OrderDiscountingHistory> orderIdKeyPromotionHistoryMap =
            orderDiscountingHistoryRepository.findAllByOrderIdIn(new ArrayList<>(orderToCartMapping.keySet()))
                .stream().collect(Collectors.toMap(CommonUtils::odhKey, odh -> odh , (l1,l2) -> l1));

        Map<Long, OrderDiscountRevertResponse> orderDiscountRevertedPromotionMap = new HashMap<>();
        bulkCartDiscountRevertResponse.getCartDiscountDetails().forEach(cartDiscountRevertResponse ->
            orderDiscountRevertedPromotionMap.putAll(cartDiscountRevertResponse.getOrderDiscountDetails().stream()
            .collect(Collectors.toMap(OrderDiscountRevertResponse::getOrderId,
                orderDiscountResponse -> orderDiscountResponse))));

        List<OrderHistory> orderHistories = new ArrayList<>();
        Map<Long,Integer> cartDiscountAdjustMap = new HashMap<>();

        orderDiscountRevertedPromotionMap.forEach((orderId,value) -> {
            Order order = allOrdersMap.get(orderId);
            int discountToAdjust = cartDiscountAdjustMap.getOrDefault(orderToCartMapping.get(orderId), ZERO);
            for(PlanDiscountData planDiscountData:value.getPlanDiscountData()){
                OrderDiscountingHistory oldODH = orderIdKeyPromotionHistoryMap.get(
                    CommonUtils.odhKey(orderId,planDiscountData.getPlanId().intValue()));
                int discountRemoved = planDiscountData.getDiscountAmount().intValue();
                /*
                todo handle doorstep cancellation byy flag value.getCancelOrder()
                 */
                if(discountRemoved > ZERO) {
                    discountToAdjust += discountRemoved;
                    oldODH.setDiscountAmount(oldODH.getDiscountAmount() - discountRemoved);
                    addToOrderHistoryModels(order, orderHistories, AppConstant.BEFORE_DISCOUNT_REMOVAL,
                        orderId);
                    order.setAmount(order.getAmount() + discountRemoved);
                    order.setDiscountAmount(order.getDiscountAmount() - discountRemoved);
                    addToOrderHistoryModels(order, orderHistories, AppConstant.AFTER_DISCOUNT_REMOVAL,
                        orderId);
                }
            };
            value.setBilledAmount(order.getBilledAmount().longValue());
            value.setNewDiscountAmount(order.getDiscountAmount().longValue());
            value.setNewOrderAmount(order.getAmount().longValue());
            cartDiscountAdjustMap.put(orderToCartMapping.get(orderId),discountToAdjust);
        });

        try {
            orderRepository.saveAll(new ArrayList<>(allOrdersMap.values()));
            orderHistoryRepository.saveAll(orderHistories);
            orderDiscountingHistoryRepository.saveAll(orderIdKeyPromotionHistoryMap.values());
        } catch (Exception e) {
            log.error("cart-discounting-logic saving data to DB failed at bts");
        }
        List<Long> cancelledOrderIds = bulkRevertRequest.getOrderCancelDiscountUpdateRequests().stream()
            .filter(o -> CANCELLED.getValues().contains(o.getStatus()))
            .map(OrderCancelDiscountUpdateRequest::getOrderId).collect(Collectors.toList());
        log.error("Request received in BulkCancelWalletCreditModel, {}",
            new BulkCancelWalletCreditModel(cancelledOrderIds));
        bulkCancelWalletUpdate(new BulkCancelWalletCreditModel(cancelledOrderIds));
        log.error(
            "Request received in bulkRefundUpdate, cartOrdersMapping: {}, cartDiscountAdjustMap: "
                + "{}, cancelledOrderIds: {}",
            cartOrdersMapping, cartDiscountAdjustMap, cancelledOrderIds);
        bulkRefundUpdate(cartOrdersMapping, cartDiscountAdjustMap, cancelledOrderIds);
        return bulkCartDiscountRevertResponse;
    }

    private Map<Long,Long> prepareBulkDiscountRevertMaps(Set<Long> allOrderIds,
                                                         Map<Long,List<Order>> cartOrdersMapping) {
        Map<Long,Long> orderToCartMapping =
            cartOrderMappingRepository.findAllCartsByOrderIdsIn(new ArrayList<>(allOrderIds))
            .stream().collect(Collectors.toMap(CartOrderMapping::getOrderId,CartOrderMapping::getCartId,(l1,l2) -> l1));

        cartOrdersMapping.putAll(orderRepository.findAllOrdersByCartIds(new ArrayList<>(orderToCartMapping.values()))
            .stream().collect(Collectors.groupingBy(o -> orderToCartMapping.get(o.getId()))));
        if(orderToCartMapping.isEmpty()) {
            throw new ValidationException(String.format("No carts found for order %s", allOrderIds));
        }
        return orderToCartMapping;
    }

    private List<RevertDiscountRequestV2> prepareRevertDiscountRequests(Map<Long,List<Order>> cartOrdersMapping, Map<Long,Order> allOrdersMap,
                                                                      Map<Long, OrderCancelDiscountUpdateRequest> orderIdToOrderSyncRequestMap ){
        return cartOrdersMapping.entrySet().stream().map(cartOrders -> {
            allOrdersMap.putAll(cartOrders.getValue().stream().collect(Collectors.toMap(Order::getId, o -> o)));

            RevertDiscountRequestV2 revertDiscountRequest = new RevertDiscountRequestV2();

            Set<Long> cancelledByCustomerFault = new HashSet<>();
            Set<Long> allCancelled = new HashSet<>();
            List<OrderCancelDiscountUpdateRequest> orderCancelDiscountUpdateRequests = cartOrders.getValue()
                .stream().map(o -> orderIdToOrderSyncRequestMap.get(o.getId())).filter(Objects::nonNull)
                .collect(Collectors.toList());

            updateCancelledOrders(orderCancelDiscountUpdateRequests, cartOrders.getValue(),
                cancelledByCustomerFault,allCancelled);

            Map<Long, DealDetail> orderToDealMap = getDealInformationMap(cartOrders.getValue());
            boolean isRestricted = orderCancelDiscountUpdateRequests.stream().anyMatch(o ->
                Objects.nonNull(o.getIsSplitDelivery()) && o.getIsSplitDelivery());
//            if(cartOrders.getValue().stream().anyMatch(o -> PAYMENT_TYPE_PAYTM.equalsIgnoreCase(o.getPaymentType()))){
//                isRestricted = !growthbookService.prepaidDiscountRefundEnabled(cartOrders.getValue().get(ZERO).getUserId());
//            }
            List<OrderInfo> orderInfos = prepareOrderInfo(cartOrders.getValue(),cancelledByCustomerFault,orderIdToOrderSyncRequestMap, orderToDealMap);

            revertDiscountRequest.setIsRestricted(isRestricted);
            revertDiscountRequest.setUserId(cartOrders.getValue().get(ZERO).getUserId());
            revertDiscountRequest.setCartId(cartOrders.getKey());
            revertDiscountRequest.setCancelledOrderIds(new ArrayList<>(allCancelled));
            revertDiscountRequest.setOrderInfo(orderInfos);
            return revertDiscountRequest;
        }).collect(Collectors.toList());
    }

    private void bulkRefundUpdate(Map<Long,List<Order>> cartOrdersMap,Map<Long,Integer> cartDiscountAdjustMap,
                                  List<Long> cancelledOrderIds) {
        List<CartRefundUpdateRequest> cartRefundUpdateRequests = new ArrayList<>();
        cartOrdersMap.forEach((cartId,orders) -> {
            int discountAmountToAdjust = cartDiscountAdjustMap.getOrDefault(cartId,ZERO);
            if(orders.get(ZERO).getPaymentType().equalsIgnoreCase(PAYMENT_TYPE_PAYTM) &&
                discountAmountToAdjust > 0){
                List<OrderRefundUpdateRequest> orderRefundUpdateRequests = new ArrayList<>();
                // first priority for adjusting discounts is cancelled order
                for(Order order:orders){
                    if(cancelledOrderIds.contains(order.getId())) {
                        double refundAmount = order.getAmount();
                        double discountToAdjustInOrder = Math.min(order.getAmount(), discountAmountToAdjust);
                        discountAmountToAdjust -= discountToAdjustInOrder;
                        refundAmount -= discountToAdjustInOrder;
                        orderRefundUpdateRequests.add(new OrderRefundUpdateRequest(order.getId(),(long)refundAmount));
                    } else {
                        orderRefundUpdateRequests.add(new OrderRefundUpdateRequest(order.getId(),order.getAmount().longValue()));
                    }
                }
                if(!orderRefundUpdateRequests.isEmpty()) {
                    cartRefundUpdateRequests.add(new CartRefundUpdateRequest(cartId, orderRefundUpdateRequests));
                }
            }
        });
        if(cartRefundUpdateRequests.isEmpty()){
            return;
        }
        BulkRefundUpdateRequest bulkRefundUpdateRequest = new BulkRefundUpdateRequest(cartRefundUpdateRequests);
        try {
            paymentServiceClient.bulkRefundAmountUpdate(bulkRefundUpdateRequest);
        } catch (Exception ex){
            log.error("Error in updating refund amount {}", ex.getMessage());
        }
    }

    private void populateBreachDetails(RevertDiscountBreachResponse revertDiscountBreachResponse,
                                       List<Order> orders) {
        Map<Long, Order> ordersMap =
            orders.stream().collect(Collectors.toMap(Order::getId, o -> o));

        revertDiscountBreachResponse.getCartBreachDetails()
            .forEach(revertDiscountBreachCartDetail -> {
                long cartValue = 0L, newTotalOrderAmount = 0L, newTotalDiscountAmount = 0L;
                for (OrderPromotionData orderPromotionData : revertDiscountBreachCartDetail
                    .getOrderPromotions()) {
                    Order order = ordersMap.get(orderPromotionData.getOrderId());
                    cartValue += order.getBilledAmount().longValue();
                    long newOrderAmount = order.getAmount().longValue(), newDiscountAmount =
                        order.getDiscountAmount();
                    for (PlanDiscountData planDiscountData : orderPromotionData
                        .getPlanDiscounts()) {
                        newOrderAmount += planDiscountData.getDiscountAmount();
                        newDiscountAmount -= planDiscountData.getDiscountAmount();
                    }
                    orderPromotionData.setBilledAmount(order.getBilledAmount().longValue());
                    orderPromotionData.setNewOrderAmount(newOrderAmount);
                    orderPromotionData.setNewDiscountAmount(newDiscountAmount);

                    newTotalOrderAmount += orderPromotionData.getNewOrderAmount();
                    newTotalDiscountAmount += orderPromotionData.getNewDiscountAmount();
                }
                revertDiscountBreachCartDetail.setNewTotalCartAmount(cartValue);
                revertDiscountBreachCartDetail.setNewTotalDiscountAmount(newTotalDiscountAmount);
                revertDiscountBreachCartDetail.setNewTotalOrderAmount(newTotalOrderAmount);
            });
    }

    private List<OrderDealMappingModel> getOrderDealMappingForExistingOrder(List<POSOrderMapping> posOrderMappingList,
                                                                            Map<String, OrderSummaryModel> offerIdOrderSummaryModelMap) {

        List<OrderSummaryModel> orderSummaryModelList = new ArrayList<>(offerIdOrderSummaryModelMap.values());
        Map<String, POSOrderMapping> posOrderMappingMap = new HashMap<>();
        for(POSOrderMapping posOrderMapping : posOrderMappingList) {
            String key = posOrderMapping.getOfferId() + ":" + posOrderMapping.getStatus();
            posOrderMappingMap.put(key, posOrderMapping);
        }
        List<OrderDealMappingModel> orderDealMappingModelList = new ArrayList<>();

        for(OrderSummaryModel orderSummaryModel : orderSummaryModelList) {
            Long orderId = orderSummaryModel.getOrderId();
            OrderProductDetailModel orderProductDetailModel = orderSummaryModel.getOrderProductDetailModel();
            String posOrderMappingMapKey = orderProductDetailModel.getOfferId() + ":" + orderSummaryModel.getStatus();
            POSOrderMapping posOrderMapping = posOrderMappingMap.getOrDefault(posOrderMappingMapKey, null);
            if(ObjectUtils.isEmpty(posOrderMapping) || !isExistingSyncRequest(orderSummaryModel, posOrderMapping)) {
                return new ArrayList<>();
            }

            OrderDealMappingModel orderDealMappingModel = new OrderDealMappingModel();
            orderDealMappingModel.setOrderId(posOrderMapping.getOrderId());
            orderDealMappingModel.setStatus(orderSummaryModel.getStatus());
            orderDealMappingModel.setIsOrderPresent(orderSummaryModel.getIsOrderPresent());
            orderDealMappingModel.setSkuQtyMappingModels(orderProductDetailModel.getSkus());

            orderDealMappingModelList.add(orderDealMappingModel);
        }
        return  orderDealMappingModelList;
    }

    public List<Long> getActiveCartIds(ActiveCartIdsRequestModel activeCartIdsRequestModel){
        List<Long> activeCartIds = new ArrayList<>();
        Optional<List<Cart>> activeCarts = cartRepository.findActiveCartsForUserOrderByCreatedDate(activeCartIdsRequestModel.getUserId(),
                                        activeCartIdsRequestModel.getCartType(),
                                        activeCartIdsRequestModel.getOrderStatus(),null);
        if(activeCarts.isPresent()) activeCartIds = activeCarts.get().stream().map(Cart::getId).collect(Collectors.toList());
        return activeCartIds;
    }

    private boolean isExistingSyncRequest(OrderSummaryModel orderSummaryModel, POSOrderMapping posOrderMapping) {
        if(!orderSummaryModel.getIsOrderPresent()) {
            return true;
        }

        if (orderSummaryModel.getIsOrderPresent() && Objects.equals(orderSummaryModel.getOrderId(), posOrderMapping.getOrderId())
                && Objects.equals(orderSummaryModel.getStatus(), posOrderMapping.getStatus().toString())) {
            return true;
        }
        return false;
    }


    public void cancelPendingOrdersPaymentSuccessFull() {
        List<Order> pendingOrders = orderRepository.findPendingOrdersForPaymentSuccessFull();
        if (pendingOrders.isEmpty()) {
            log.info("No pending orders found for payment success full cancellation");
            return;
        }
        log.error("Found {} pending orders for payment success full cancellation", pendingOrders);
        for (Order order : pendingOrders) {
            try {
                order.setOrderStatus("cancel");
                order.setPaymentStatus(PAYMENT_SUCCESSFUL);
                orderRepository.save(order);
            } catch (Exception e) {
                log.error("Error cancelling order {}: {}", order.getId(), e.getMessage());
            }
        }
    }

    public List<ApologySmsDto> prepareSMSData(List<Order> orders){
        List<Long> orderIds = orders.stream().map(Order::getId).collect(Collectors.toList());
        Map<Long,Order> orderIdToOrder = orders.stream()
                .collect(Collectors.toMap(Order::getId, order -> order));
        List<CartOrderMapping> cartMappings = cartOrderMappingRepository.findAllByOrderIdIn(orderIds)
                .orElse(Collections.emptyList());
        Map<Long, List<Long>> cartToOrders = cartMappings.stream()
                .collect(Collectors.groupingBy(
                        CartOrderMapping::getCartId,
                        Collectors.mapping(CartOrderMapping::getOrderId, Collectors.toList())
                ));

        List<ApologySmsDto> apologySmsDtosList = new ArrayList<>() ;
        List<String> offerIds = orders.stream().map(Order :: getOfferId).collect(Collectors.toList());
        Map<String, OfferResponseModel> offerDetails = userCartService.orderIdsToOfferMap(offerIds);
        for (Map.Entry<Long, List<Long>> entry : cartToOrders.entrySet()) {
            ApologySmsDto apologySmsDtos = new ApologySmsDto();
            apologySmsDtos.setCartId(entry.getKey());
            apologySmsDtos.setOrderIds(entry.getValue());


            Integer numberOfOrders = apologySmsDtos.getOrderIds().size();
            String productName = "";

            if (!apologySmsDtos.getOrderIds().isEmpty()) {
                Long firstOrderId = apologySmsDtos.getOrderIds().get(0);
                Order order = orderIdToOrder.get(firstOrderId);
                apologySmsDtos.setPhone(order.getPhone());
                if (order != null) {
                    String name = offerDetails.get(order.getOfferId()).getTitle().get("en");
                    productName = name.length() > 20 ? name.substring(0, 20) : name;
                }
            }
            apologySmsDtos.setProductNamePrefix(productName);
            apologySmsDtos.setQuantity(numberOfOrders);
            apologySmsDtosList.add(apologySmsDtos);

        }
        return apologySmsDtosList;
    }

}


=== REVERSE DEPENDENCY ===
# /Users/dealshare/Downloads/cart-service/src/main/java/com/dealshare/service/cartservice/services/helper/CartConfigCacheHelper.java

package com.dealshare.service.cartservice.services.helper;


import com.dealshare.service.cartservice.entities.CartConfig;
import com.dealshare.service.cartservice.repositories.CartConfigRepository;
import com.dealshare.service.cartservice.services.CartConfigService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheConfig;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.stereotype.Service;

import javax.transaction.Transactional;

import static com.dealshare.service.cartservice.constants.AppCacheTypes.APP_CACHE_CART_CONFIG;

@Service
@CacheConfig(cacheNames = APP_CACHE_CART_CONFIG)
public class CartConfigCacheHelper {

    @Autowired
    private CartConfigRepository cartConfigRepository;

    @CacheEvict(key = "#config.id")
    @Transactional
    public CartConfig saveAndRefreshCache(CartConfig config) {
        return cartConfigRepository.save(config);
    }
}


=== REVERSE DEPENDENCY ===
# /Users/dealshare/Downloads/cart-service/src/main/java/com/dealshare/service/cartservice/controllers/CartConfigController.java

package com.dealshare.service.cartservice.controllers;

import com.dealshare.service.cartservice.models.ActiveClusterUserMovModel;
import com.dealshare.service.cartservice.models.CartConfigModel;
import com.dealshare.service.cartservice.models.ClusterMovRequestModel;
import com.dealshare.service.cartservice.services.CartConfigService;
import com.dealshare.service.cartservice.services.DeliveryFeeService;
import com.dealshare.service.cartservice.utils.CommonUtils;
import io.github.resilience4j.ratelimiter.annotation.RateLimiter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid;
import java.io.IOException;
import java.util.List;

@RestController
@Slf4j
@RequestMapping("/v1/cart-config")
@CrossOrigin(origins = "*", maxAge = 3600)
public class CartConfigController {

    @Autowired
    private CartConfigService cartConfigService;

    @Autowired
    private DeliveryFeeService deliveryFeeService;

    @Autowired
    private CommonUtils commonUtils;

    @PostMapping()
    public ResponseEntity<?> createCartConfig(@Valid @RequestBody CartConfigModel cartConfigModel) throws IOException {
        return new ResponseEntity<>(cartConfigService.createConfig(cartConfigModel), HttpStatus.OK);
    }

    @PutMapping()
    public ResponseEntity<?> updateCartConfig(@Valid @RequestBody CartConfigModel cartConfigModel,
                                              @RequestHeader(name = "useMeta", defaultValue = "false", required = false) Boolean useMeta) throws IOException {
        return new ResponseEntity<>(cartConfigService.updateConfig(cartConfigModel, useMeta), HttpStatus.OK);
    }

    @GetMapping("/{id}")
    public ResponseEntity<?> getCartConfigById(@PathVariable(value = "id") Long configId) throws IOException {
        return new ResponseEntity<>(cartConfigService.getCartConfigData(configId), HttpStatus.OK);
    }

    @GetMapping("/all")
    public ResponseEntity<?> getAllCartConfig(@RequestParam(value = "source", defaultValue = "B2C", required = false) String source) throws Exception {
        return new ResponseEntity<>(cartConfigService.getAllCartConfig(source), HttpStatus.OK);
    }

    @GetMapping("/cache/all")
    public ResponseEntity<?> cacheAllCartConfigInRedis() {
        cartConfigService.cacheAllConfigInRedis();
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

    @RateLimiter(name = "deliveryConfigRateLimiter")
    @GetMapping(value = "/delivery-config")
    public  ResponseEntity<?> deliveryConfig(@RequestParam(value = "userId")Long userId,
                                             @RequestParam(value = "phone") String phone,
                                             @RequestParam(value = "pinCode") String pinCode,
                                             @RequestParam(value = "cartType", defaultValue = "B2C", required = false) String cartType,
                                             @RequestParam(value = "clusterIds") List<Integer> clusterIds,
                                             HttpServletRequest request)throws Exception {
        Long userIdFinal = commonUtils.getFinalValidUserId(request, userId);
        return new ResponseEntity<>(deliveryFeeService.deliveryFeeConfig(userIdFinal,phone,pinCode,cartType,clusterIds),HttpStatus.OK);
    }

    @RateLimiter(name = "ordDeliveryConfigRateLimiter")
    @GetMapping(value = "/ord-delivery-fee-config")
    public  ResponseEntity<?> cartConfig(@RequestParam(value = "userId")Long userId,
                                         @RequestParam(value = "phone") String phone,
                                         @RequestParam(value = "pincode") String pincode,
                                         @RequestParam(value = "userRank") String userRank,
                                         @RequestParam(value = "source", defaultValue = "B2C", required = false) String source,
                                         @RequestParam(value = "clusterIds") List<Integer> clusterIds,
                                         @RequestHeader(value = "Accept-Language", defaultValue = "en", required = false) String lang
                                         ) {
        return new ResponseEntity<>(cartConfigService.getCartConfig(userId,
                phone,
                pincode,
                clusterIds,
                userRank,
                source,
                lang),HttpStatus.OK);
    }


    @PostMapping("/ord-panel/cluster-ord-mov")
    public ResponseEntity<?> createClusterMov(@Valid @RequestBody ClusterMovRequestModel clusterMovRequestModel) throws Exception {
        return new ResponseEntity<>(cartConfigService.addClusterOrdMov(clusterMovRequestModel), HttpStatus.OK);
    }
    @GetMapping("/ord-panel/cluster-ord-mov")
    public ResponseEntity<?> getActiveClusterMov() throws Exception {
        return new ResponseEntity<>(cartConfigService.getActiveClusterOrdMov(), HttpStatus.OK);
    }
    @DeleteMapping("/ord-panel/cluster-ord-mov")
    public ResponseEntity<?> deleteClusterMov(@Valid @RequestBody ActiveClusterUserMovModel activeClusterUserMovModel) throws Exception {
        return new ResponseEntity<>(cartConfigService.deleteClusterOrdMov(activeClusterUserMovModel), HttpStatus.OK);
    }


}


